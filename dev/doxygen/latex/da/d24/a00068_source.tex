\hypertarget{a00068_source}{}\doxysection{nonlinearoperator.\+hh}
\label{a00068_source}\index{nonlinearoperator.hh@{nonlinearoperator.hh}}
\mbox{\hyperlink{a00068}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2021-\/2024 The Ikarus Developers mueller@ibb.uni-\/stuttgart.de}}
\DoxyCodeLine{2 \textcolor{comment}{// SPDX-\/License-\/Identifier: LGPL-\/3.0-\/or-\/later}}
\DoxyCodeLine{3 }
\DoxyCodeLine{4 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{6 }
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <dune/common/hybridutilities.hh>}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{a00149}{ikarus/utils/traits.hh}}>}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{keyword}{namespace }\mbox{\hyperlink{a00219}{Ikarus}} \{}
\DoxyCodeLine{12 }
\DoxyCodeLine{13   \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{14     \textcolor{keyword}{template} <\textcolor{keyword}{class }F, \textcolor{keyword}{class }Tuple, std::size\_t... I>}
\DoxyCodeLine{15     \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto}) applyAndRemoveRefererenceWrapper(F\&\& f, Tuple\&\& t, std::index\_sequence<I...>) \{}
\DoxyCodeLine{16       \textcolor{keywordflow}{return} std::invoke(}
\DoxyCodeLine{17           std::forward<F>(f),}
\DoxyCodeLine{18           std::get<I>(std::forward<Tuple>(t)).get()...);  \textcolor{comment}{//.get gets the impl type of std::referenceWrapper}}
\DoxyCodeLine{19     \}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21     \textcolor{keyword}{template} <\textcolor{keyword}{class} F, \textcolor{keyword}{class} Tuple>}
\DoxyCodeLine{22     \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto}) applyAndRemoveReferenceWrapper(F\&\& f, Tuple\&\& t) \{}
\DoxyCodeLine{23       \textcolor{keywordflow}{return} applyAndRemoveRefererenceWrapper(}
\DoxyCodeLine{24           std::forward<F>(f), std::forward<Tuple>(t),}
\DoxyCodeLine{25           std::make\_index\_sequence<std::tuple\_size\_v<std::remove\_reference\_t<Tuple>>>\{\});}
\DoxyCodeLine{26     \}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{29     \textcolor{keyword}{auto} forwardasReferenceWrapperIfIsReference(T\&\& t) \{}
\DoxyCodeLine{30       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_lvalue\_reference\_v<\textcolor{keyword}{decltype}(t)>)}
\DoxyCodeLine{31         \textcolor{keywordflow}{return} std::ref(t);}
\DoxyCodeLine{32       \textcolor{keywordflow}{else}}
\DoxyCodeLine{33         \textcolor{keywordflow}{return} t;}
\DoxyCodeLine{34     \}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36     \textcolor{keyword}{template} <\textcolor{keyword}{class }Pars, \textcolor{keyword}{class }Tuple, std::size\_t... I>}
\DoxyCodeLine{37     \textcolor{keyword}{constexpr} \textcolor{keyword}{decltype}(\textcolor{keyword}{auto}) makeTupleOfValuesAndReferences(Tuple\&\& t, Pars\&\& p, std::index\_sequence<I...>) \{}
\DoxyCodeLine{38       \textcolor{keywordflow}{return} std::make\_tuple(}
\DoxyCodeLine{39           forwardasReferenceWrapperIfIsReference(applyAndRemoveReferenceWrapper(std::get<I>(t), p.args))...);}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{43     \textcolor{keyword}{struct }Functions \{}
\DoxyCodeLine{44       std::tuple<std::reference\_wrapper<std::remove\_reference\_t<Args>>...> args;}
\DoxyCodeLine{45     \};}
\DoxyCodeLine{46 }
\DoxyCodeLine{47     \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{48     \textcolor{keyword}{struct }Parameter \{}
\DoxyCodeLine{49       std::tuple<std::reference\_wrapper<std::remove\_reference\_t<Args>>...> args;}
\DoxyCodeLine{50     \};}
\DoxyCodeLine{51 }
\DoxyCodeLine{52   \}  \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{55   \textcolor{keyword}{auto} \mbox{\hyperlink{a00219_ac00abda505aa8ccc73ce59afd165ce49}{parameter}}(Args\&\&... args) \{}
\DoxyCodeLine{56     \textcolor{keywordflow}{return} Impl::Parameter<Args\&\&...>\{std::forward\_as\_tuple(std::forward<Args>(args)...)\};}
\DoxyCodeLine{57   \}}
\DoxyCodeLine{58 }
\DoxyCodeLine{59   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{60   \textcolor{keyword}{auto} \mbox{\hyperlink{a00219_ab787b670f0d338c870988f417cf85f76}{functions}}(Args\&\&... args) \{}
\DoxyCodeLine{61     \textcolor{keywordflow}{return} Impl::Functions<Args\&\&...>\{std::forward\_as\_tuple(std::forward<Args>(args)...)\};}
\DoxyCodeLine{62   \}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... DerivativeArgs, \textcolor{keyword}{typename}... ParameterArgs>}
\DoxyCodeLine{65   \textcolor{keyword}{auto} \mbox{\hyperlink{a00219_ac4a51a33b91a6e959c61fb4a71cef19c}{initResults}}(\textcolor{keyword}{const} Impl::Functions<DerivativeArgs...>\& derivativesFunctions,}
\DoxyCodeLine{66                    \textcolor{keyword}{const} Impl::Parameter<ParameterArgs...>\& parameterI) \{}
\DoxyCodeLine{67     \textcolor{keywordflow}{return} Impl::makeTupleOfValuesAndReferences(}
\DoxyCodeLine{68         derivativesFunctions.args, parameterI,}
\DoxyCodeLine{69         std::make\_index\_sequence<std::tuple\_size\_v<std::remove\_reference\_t<\textcolor{keyword}{decltype}(derivativesFunctions.args)>>>\{\});}
\DoxyCodeLine{70   \}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72   \textcolor{keyword}{template} <\textcolor{keyword}{typename} TypeListOne, \textcolor{keyword}{typename} TypeListTwo>}
\DoxyCodeLine{73   \textcolor{keyword}{class }\mbox{\hyperlink{a01253}{NonLinearOperator}} \{}
\DoxyCodeLine{74   \textcolor{keyword}{public}:}
\DoxyCodeLine{75     \mbox{\hyperlink{a01253_a2308f86b14266d7b7049b0a12cf20cdc}{NonLinearOperator}}([[maybe\_unused]] \textcolor{keyword}{const} TypeListOne\& derivativesFunctions,}
\DoxyCodeLine{76                       [[maybe\_unused]] \textcolor{keyword}{const} TypeListTwo\& args) \{}
\DoxyCodeLine{77       \textcolor{keyword}{static\_assert}(!\textcolor{keyword}{sizeof}(TypeListOne),}
\DoxyCodeLine{78                     \textcolor{stringliteral}{"{}This type should not be instantiated. check that your arguments satisfies the template below"{}});}
\DoxyCodeLine{79     \}}
\DoxyCodeLine{80   \};}
\DoxyCodeLine{81 }
\DoxyCodeLine{82   \textcolor{comment}{/* NonLinearOperator is a class taking linear algebra function and their arguments.}}
\DoxyCodeLine{83 \textcolor{comment}{   * The fcuntion are assumed to be derivatvies of each other. */}}
\DoxyCodeLine{84   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... DerivativeArgs, \textcolor{keyword}{typename}... ParameterArgs>}
\DoxyCodeLine{85   \textcolor{keyword}{class }NonLinearOperator<Impl::Functions<DerivativeArgs...>, Impl::Parameter<ParameterArgs...>> \{}
\DoxyCodeLine{86   \textcolor{keyword}{public}:}
\DoxyCodeLine{87     \textcolor{keyword}{using }FunctionReturnValues = std::tuple<\mbox{\hyperlink{a00232_a8a73882aa4613b1db650ae7126112c7d}{Ikarus::Std::ReturnType}}<DerivativeArgs, ParameterArgs\&...>...>;}
\DoxyCodeLine{88     \textcolor{keyword}{using }ParameterValues      = std::tuple<ParameterArgs...>;}
\DoxyCodeLine{89     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} n>}
\DoxyCodeLine{90     \textcolor{keyword}{using }FunctionReturnType = std::tuple\_element\_t<n, FunctionReturnValues>;}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} n>}
\DoxyCodeLine{93     \textcolor{keyword}{using }ParameterValue = std::remove\_cvref\_t<std::tuple\_element\_t<n, ParameterValues>>;}
\DoxyCodeLine{94 }
\DoxyCodeLine{95     \textcolor{keyword}{using }ValueType      = std::remove\_cvref\_t<std::tuple\_element\_t<0, FunctionReturnValues>>;}
\DoxyCodeLine{96     \textcolor{keyword}{using }DerivativeType = std::remove\_cvref\_t<std::tuple\_element\_t<1, FunctionReturnValues>>;}
\DoxyCodeLine{97 }
\DoxyCodeLine{98     \textcolor{keyword}{explicit} \mbox{\hyperlink{a01253_a2308f86b14266d7b7049b0a12cf20cdc}{NonLinearOperator}}(\textcolor{keyword}{const} Impl::Functions<DerivativeArgs...>\& derivativesFunctions,}
\DoxyCodeLine{99                                \textcolor{keyword}{const} Impl::Parameter<ParameterArgs...>\& parameterI)}
\DoxyCodeLine{100         : derivatives\_\{derivativesFunctions.args\},}
\DoxyCodeLine{101           args\_\{parameterI.args\},}
\DoxyCodeLine{102           derivativesEvaluated\_(\mbox{\hyperlink{a00219_ac4a51a33b91a6e959c61fb4a71cef19c}{initResults}}(derivativesFunctions, parameterI)) \{\}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104     \textcolor{comment}{/* Evaluates all functions. Usually called if the parameters changes */}}
\DoxyCodeLine{105     \textcolor{keywordtype}{void} updateAll() \{}
\DoxyCodeLine{106       Dune::Hybrid::forEach(}
\DoxyCodeLine{107           Dune::Hybrid::integralRange(Dune::index\_constant<\textcolor{keyword}{sizeof}...(DerivativeArgs)>()), [\&](\textcolor{keyword}{const} \textcolor{keyword}{auto} i) \{}
\DoxyCodeLine{108             std::get<i>(derivativesEvaluated\_) = Impl::applyAndRemoveReferenceWrapper(std::get<i>(derivatives\_), args\_);}
\DoxyCodeLine{109           \});}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112     \textcolor{comment}{/* Evaluates the n-\/th function */}}
\DoxyCodeLine{113     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} n>}
\DoxyCodeLine{114     \textcolor{keywordtype}{void} update() \{}
\DoxyCodeLine{115       std::get<n>(derivativesEvaluated\_) = Impl::applyAndRemoveReferenceWrapper(std::get<n>(derivatives\_), args\_);}
\DoxyCodeLine{116     \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118     \textcolor{comment}{/* Returns the value of the zeros function, e.g. the energy value as reference */}}
\DoxyCodeLine{119     \textcolor{keyword}{auto}\& value() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(DerivativeArgs) > 0) \{ \textcolor{keywordflow}{return} nthDerivative<0>(); \}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     \textcolor{comment}{/* Returns the derivative value, e.g. the gradient of an energy */}}
\DoxyCodeLine{122     \textcolor{keyword}{auto}\& derivative() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(DerivativeArgs) > 1) \{ \textcolor{keywordflow}{return} nthDerivative<1>(); \}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124     \textcolor{comment}{/* Returns the second derivative value, e.g. the Hessian of an energy */}}
\DoxyCodeLine{125     \textcolor{keyword}{auto}\& secondDerivative() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(DerivativeArgs) > 2) \{ \textcolor{keywordflow}{return} nthDerivative<2>(); \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     \textcolor{comment}{/* Returns the n-\/th derivative value */}}
\DoxyCodeLine{128     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} n>}
\DoxyCodeLine{129     \textcolor{keyword}{auto}\& nthDerivative() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(DerivativeArgs) > n) \{}
\DoxyCodeLine{130       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\textcolor{keyword}{requires} \{ std::get<n>(derivativesEvaluated\_).get(); \})}
\DoxyCodeLine{131         \textcolor{keywordflow}{return} std::get<n>(derivativesEvaluated\_).get();}
\DoxyCodeLine{132       \textcolor{keywordflow}{else}}
\DoxyCodeLine{133         \textcolor{keywordflow}{return} std::get<n>(derivativesEvaluated\_);}
\DoxyCodeLine{134     \}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136     \textcolor{comment}{/* Returns the last parameter value */}}
\DoxyCodeLine{137     \textcolor{keyword}{auto}\& lastParameter() \{ \textcolor{keywordflow}{return} nthParameter<\textcolor{keyword}{sizeof}...(ParameterArgs) -\/ 1>(); \}}
\DoxyCodeLine{138     \textcolor{comment}{/* Returns the first parameter value */}}
\DoxyCodeLine{139     \textcolor{keyword}{auto}\& firstParameter() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(ParameterArgs) > 0) \{ \textcolor{keywordflow}{return} nthParameter<0>(); \}}
\DoxyCodeLine{140     \textcolor{comment}{/* Returns the second parameter value */}}
\DoxyCodeLine{141     \textcolor{keyword}{auto}\& secondParameter() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(ParameterArgs) > 1) \{ \textcolor{keywordflow}{return} nthParameter<1>(); \}}
\DoxyCodeLine{142     \textcolor{comment}{/* Returns the n-\/th parameter value */}}
\DoxyCodeLine{143     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} n>}
\DoxyCodeLine{144     \textcolor{keyword}{auto}\& nthParameter() \textcolor{keyword}{requires}(\textcolor{keyword}{sizeof}...(ParameterArgs) >= n) \{}
\DoxyCodeLine{145       \textcolor{keywordflow}{return} std::get<n>(args\_).get();}
\DoxyCodeLine{146     \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \textcolor{comment}{/* Returns a new NonLinearOperator from the given indices */}}
\DoxyCodeLine{149     \textcolor{keyword}{template} <\textcolor{keywordtype}{int}... Derivatives>}
\DoxyCodeLine{150     \textcolor{keyword}{auto} subOperator() \{}
\DoxyCodeLine{151       \textcolor{keywordflow}{return} \mbox{\hyperlink{a01253}{Ikarus::NonLinearOperator}}(\mbox{\hyperlink{a00219_ab787b670f0d338c870988f417cf85f76}{functions}}(std::get<Derivatives>(derivatives\_)...),}
\DoxyCodeLine{152                                        Impl::applyAndRemoveReferenceWrapper(parameter<ParameterArgs...>, args\_));}
\DoxyCodeLine{153     \}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keyword}{private}:}
\DoxyCodeLine{156     \textcolor{keyword}{using }FunctionReturnValuesWrapper = std::tuple<std::conditional\_t<}
\DoxyCodeLine{157         std::is\_reference\_v<\mbox{\hyperlink{a00232_a8a73882aa4613b1db650ae7126112c7d}{Ikarus::Std::ReturnType}}<DerivativeArgs, ParameterArgs\&...>>,}
\DoxyCodeLine{158         std::reference\_wrapper<std::remove\_cvref\_t<\mbox{\hyperlink{a00232_a8a73882aa4613b1db650ae7126112c7d}{Ikarus::Std::ReturnType}}<DerivativeArgs, ParameterArgs\&...>>>,}
\DoxyCodeLine{159         std::remove\_cvref\_t<\mbox{\hyperlink{a00232_a8a73882aa4613b1db650ae7126112c7d}{Ikarus::Std::ReturnType}}<DerivativeArgs, ParameterArgs\&...>>>...>;}
\DoxyCodeLine{160     std::tuple<std::conditional\_t<std::is\_reference\_v<DerivativeArgs>,}
\DoxyCodeLine{161                                   std::reference\_wrapper<std::remove\_cvref\_t<DerivativeArgs>>,}
\DoxyCodeLine{162                                   std::remove\_cvref\_t<DerivativeArgs>>...>}
\DoxyCodeLine{163         derivatives\_;}
\DoxyCodeLine{164     std::tuple<std::conditional\_t<std::is\_reference\_v<ParameterArgs>,}
\DoxyCodeLine{165                                   std::reference\_wrapper<std::remove\_cvref\_t<ParameterArgs>>,}
\DoxyCodeLine{166                                   std::remove\_cvref\_t<ParameterArgs>>...>}
\DoxyCodeLine{167         args\_;}
\DoxyCodeLine{168     FunctionReturnValuesWrapper derivativesEvaluated\_\{\};}
\DoxyCodeLine{169   \};}
\DoxyCodeLine{170 \}  \textcolor{comment}{// namespace Ikarus}}

\end{DoxyCode}

\hypertarget{a00304}{}\doxysection{Ikarus\+::utils Namespace Reference}
\label{a00304}\index{Ikarus::utils@{Ikarus::utils}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{a01482}{Check\+Flags}}
\begin{DoxyCompactList}\small\item\em Struct to hold flags for function checks. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01446}{Load\+Default}}
\begin{DoxyCompactList}\small\item\em Empty struct representing a default load operation. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01438}{Solver\+Default}}
\begin{DoxyCompactList}\small\item\em Default functor for solving operations. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01442}{Update\+Default}}
\begin{DoxyCompactList}\small\item\em Default functor for updating operations. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{a00292_ga6e36d8f5163f232e3142ecbd0575e8b4}{make\+Unique\+And\+Sort}} (std\+::ranges\+::random\+\_\+access\+\_\+range auto \&r)
\begin{DoxyCompactList}\small\item\em Sorts and removes duplicate elements from a random access range.

$\ast$. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Value $>$ }\\auto \mbox{\hyperlink{a00292_ga8f6d2c90383de63c518cefeaccee76f8}{append\+Unique}} (std\+::ranges\+::random\+\_\+access\+\_\+range auto \&r, Value \&\&v)
\begin{DoxyCompactList}\small\item\em Appends a value to the range if it is not already present. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Container $>$ }\\void \mbox{\hyperlink{a00292_ga11bb80da2430170954d6b7519f9498a6}{print\+Content}} (Container \&\&c, std\+::ostream \&os=std\+::cout)
\begin{DoxyCompactList}\small\item\em Prints the contents of a container to the specified output stream. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Container $>$ }\\auto \mbox{\hyperlink{a00292_ga5f3a9e195a06ac4419ccb479f8819d62}{transform\+Value\+Range\+To\+Pointer\+Range}} (Container \&cont)
\begin{DoxyCompactList}\small\item\em Transforms a value range to a pointer range. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Container $>$ }\\auto \mbox{\hyperlink{a00292_gaabfee41eeb4843cb2fa37b5f381e9fef}{transform\+Pointer\+Range\+To\+Reference\+Range}} (Container \&cont)
\begin{DoxyCompactList}\small\item\em Transforms a pointer range to a reference range. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\constexpr size\+\_\+t \mbox{\hyperlink{a00292_gaf75511e781bb89056badd33413222010}{find\+\_\+if}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Finds the index of the first element in the tuple satisfying a predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\bool \mbox{\hyperlink{a00292_ga33284bcf99d7d3870e0aff06f6651aa2}{none\+\_\+of}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if none of the elements in the tuple satisfy a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\bool \mbox{\hyperlink{a00292_gab6d955a70ec9215ae9a8f3841582ab49}{any\+\_\+of}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Checks if any of the elements in the tuple satisfy a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\auto \mbox{\hyperlink{a00292_gad9f30d486a3d9151d534ec1b0fad5341}{filter}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Filters the elements of a tuple based on a given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Types$>$ }\\constexpr auto \mbox{\hyperlink{a00292_ga12de8f77a63ef488a87a5aa8536146ee}{unique}} (std\+::tuple$<$ Types... $>$ \&\&tuple)
\begin{DoxyCompactList}\small\item\em Creates a tuple with unique types from the given tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple , typename Predicate $>$ }\\constexpr size\+\_\+t \mbox{\hyperlink{a00292_gae9a7254f583151ee431db537c9980865}{count\+\_\+if}} (Tuple \&\&tuple, Predicate pred)
\begin{DoxyCompactList}\small\item\em Counts the number of elements in the tuple satisfying the given predicate. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr int \mbox{\hyperlink{a00292_ga62d8ab565d41e49db75f0641bcdf0740}{find\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Finds the index of the first element in the tuple that is a specialization of the given template type. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\auto \mbox{\hyperlink{a00292_ga05a5ccea0f87d41fc69956f55a2c1dbd}{get\+Specialization}} (Tuple \&\&tuple)
\begin{DoxyCompactList}\small\item\em Gets the specialization of the given template type from the tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr bool \mbox{\hyperlink{a00292_gaec2a5de0482441ef1e1c68fb7ff8a0bc}{has\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Checks if a tuple has a specialization of a template type. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\constexpr bool \mbox{\hyperlink{a00292_gadf919f3a9b0c1d50134f9d041a3ce9f7}{count\+Type\+Specialization}} ()
\begin{DoxyCompactList}\small\item\em Counts the occurrences of a specialization of a template type in a tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$int N, class Tuple $>$ }\\constexpr auto \mbox{\hyperlink{a00292_ga32de94604b9d1a7423134f33f49d613f}{make\+Tuple\+Subset}} (Tuple \&\&t)
\begin{DoxyCompactList}\small\item\em Creates a subset tuple with the first N elements from the given tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Tuple , std\+::size\+\_\+t... I$>$ }\\constexpr auto \mbox{\hyperlink{a00292_gaef801f15c9f18ae16e4241a497c33e96}{make\+Tuple\+From\+Tuple\+Indices}} (Tuple \&\&t)
\begin{DoxyCompactList}\small\item\em Creates a new tuple using indices from the original tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Types$>$ }\\auto \mbox{\hyperlink{a00304_a4c617d2458cc6d792f5ba3e6c64a0c7f}{make\+Nested\+Tuple\+Flat}} (std\+::tuple$<$ Types... $>$)
\begin{DoxyCompactList}\small\item\em Creates a flattened nested tuple. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tuple $>$ }\\auto \mbox{\hyperlink{a00304_a162c64656f5917b717a6b44ebf4c9ebf}{make\+Nested\+Tuple\+Flat\+And\+Store\+References}} (Tuple \&\&tup)
\begin{DoxyCompactList}\small\item\em Creates a flattened nested tuple and stores references. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ \newline
requires traits\+::\+Pointer$<$T$>$}\\auto \& \mbox{\hyperlink{a00304_aa156028e47fc302b02a7e70dea888034}{return\+Reference\+Or\+Nullopt\+If\+Object\+Is\+Null\+Ptr}} (T v)
\begin{DoxyCompactList}\small\item\em Returns a reference or std\+::nullopt if the object is a nullptr. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Fun , typename... Vars, typename... Args, typename U , typename G , typename H $>$ }\\void \mbox{\hyperlink{a00290_ga2a6c26beeb8d52283e82939ca585dc20}{hessianN}} (const Fun \&f, const autodiff\+::\+Wrt$<$ Vars... $>$ \&wrt, const autodiff\+::\+At$<$ Args... $>$ \&at, U \&u, std\+::array$<$ G, U\+::\+Rows\+At\+Compile\+Time $>$ \&g, std\+::array$<$ H, U\+::\+Rows\+At\+Compile\+Time $>$ \&h)
\begin{DoxyCompactList}\small\item\em Computes the Hessian matrix for each parameter of a given function.

The Hessian matrix represents the second-\/order partial derivatives of the function with respect to the specified variables. \end{DoxyCompactList}\item 
std\+::tuple$<$ Dune\+::\+Functions\+::\+Polynomial$<$ double $>$, decltype(Eigen\+::seq(0, 0))$>$ \mbox{\hyperlink{a00290_ga16e7d5f51cc42190c090e727495c1609}{find\+Line\+Segment}} (const Eigen\+::\+Vector\+Xd \&x, const Eigen\+::\+Vector\+Xd \&y, int segment\+Size)
\begin{DoxyCompactList}\small\item\em Find a linear segment in a set of data points. \end{DoxyCompactList}\item 
{\footnotesize template$<$int order, int size, typename Local\+View $>$ }\\void \mbox{\hyperlink{a00290_gae2fcf07da1bfae04148b8d570590930c}{obtain\+Lagrange\+Node\+Positions}} (const Local\+View \&local\+View, std\+::vector$<$ \mbox{\hyperlink{a01326}{Dune\+::\+Field\+Vector}}$<$ double, size $>$ $>$ \&lagrange\+Node\+Coords)
\begin{DoxyCompactList}\small\item\em A function to obtain the global positions of the nodes of an element with Lagrangian basis, see \mbox{\hyperlink{a00299}{Dune}} book page 314. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00290_gacb9e813539bfd84df99ad097cabc9de9}{check\+Gradient}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01482}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01482}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the gradient of a nonlinear operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00290_ga553465359c199ef676945832587d2869}{check\+Jacobian}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01482}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01482}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the Jacobian of a nonlinear operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Nonlinear\+Operator , typename Update\+Type  = typename Nonlinear\+Operator\+::template Parameter\+Value$<$0$>$$>$ }\\bool \mbox{\hyperlink{a00290_ga5d1a87964a3d6b6ddc994532e93b6798}{check\+Hessian}} (Nonlinear\+Operator \&non\+Lin\+Op, \mbox{\hyperlink{a01482}{Check\+Flags}} check\+Flags=\mbox{\hyperlink{a01482}{Check\+Flags}}(), std\+::function$<$ void(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&, const Update\+Type \&)$>$ p\+\_\+update\+Function=\mbox{[}$\,$\mbox{]}(typename Nonlinear\+Operator\+::template Parameter\+Value$<$ 0 $>$ \&a, const Update\+Type \&b) \{ a+=b;\})
\begin{DoxyCompactList}\small\item\em Checks the Hessian of a nonlinear operator. \end{DoxyCompactList}\item 
std\+::tuple$<$ Dune\+::\+Functions\+::\+Polynomial$<$ double $>$, double $>$ \mbox{\hyperlink{a00290_ga0d3a38551806e4de3ff44f311847ba51}{polyfit}} (const Eigen\+::\+Ref$<$ const Eigen\+::\+Vector\+Xd $>$ \&x, const Eigen\+::\+Ref$<$ const Eigen\+::\+Vector\+Xd $>$ \&y, int deg)
\begin{DoxyCompactList}\small\item\em Fits a polynomial of a given degree to the given data points. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$template$<$ auto... $>$ class Type, typename Tuple $>$ }\\static constexpr bool \mbox{\hyperlink{a00292_ga62ee166e690831f40395df076e9cdddb}{count\+Type\+Specialization\+\_\+v}} = \mbox{\hyperlink{a00292_gadf919f3a9b0c1d50134f9d041a3ce9f7}{count\+Type\+Specialization}}$<$Type, Tuple$>$()
\begin{DoxyCompactList}\small\item\em Variable template for counting the occurrences of a specialization of a template type in a tuple. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00304_a4c617d2458cc6d792f5ba3e6c64a0c7f}\label{a00304_a4c617d2458cc6d792f5ba3e6c64a0c7f}} 
\index{Ikarus::utils@{Ikarus::utils}!makeNestedTupleFlat@{makeNestedTupleFlat}}
\index{makeNestedTupleFlat@{makeNestedTupleFlat}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{makeNestedTupleFlat()}{makeNestedTupleFlat()}}
{\footnotesize\ttfamily template$<$typename... Types$>$ \\
auto Ikarus\+::utils\+::make\+Nested\+Tuple\+Flat (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ Types... $>$}]{ }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em Types} & Types contained in the original tuple. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
A new flattened nested tuple. 
\end{DoxyReturn}
\mbox{\Hypertarget{a00304_a162c64656f5917b717a6b44ebf4c9ebf}\label{a00304_a162c64656f5917b717a6b44ebf4c9ebf}} 
\index{Ikarus::utils@{Ikarus::utils}!makeNestedTupleFlatAndStoreReferences@{makeNestedTupleFlatAndStoreReferences}}
\index{makeNestedTupleFlatAndStoreReferences@{makeNestedTupleFlatAndStoreReferences}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{makeNestedTupleFlatAndStoreReferences()}{makeNestedTupleFlatAndStoreReferences()}}
{\footnotesize\ttfamily template$<$typename Tuple $>$ \\
auto Ikarus\+::utils\+::make\+Nested\+Tuple\+Flat\+And\+Store\+References (\begin{DoxyParamCaption}\item[{Tuple \&\&}]{tup }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em Tuple} & Type of the original tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tup} & The original tuple. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new tuple with stored references.
\end{DoxyReturn}
This function creates a flattened nested tuple and stores references. \mbox{\Hypertarget{a00304_aa156028e47fc302b02a7e70dea888034}\label{a00304_aa156028e47fc302b02a7e70dea888034}} 
\index{Ikarus::utils@{Ikarus::utils}!returnReferenceOrNulloptIfObjectIsNullPtr@{returnReferenceOrNulloptIfObjectIsNullPtr}}
\index{returnReferenceOrNulloptIfObjectIsNullPtr@{returnReferenceOrNulloptIfObjectIsNullPtr}!Ikarus::utils@{Ikarus::utils}}
\doxysubsubsection{\texorpdfstring{returnReferenceOrNulloptIfObjectIsNullPtr()}{returnReferenceOrNulloptIfObjectIsNullPtr()}}
{\footnotesize\ttfamily template$<$typename T $>$ \newline
requires traits\+::\+Pointer$<$T$>$\\
auto \& Ikarus\+::utils\+::return\+Reference\+Or\+Nullopt\+If\+Object\+Is\+Null\+Ptr (\begin{DoxyParamCaption}\item[{T}]{v }\end{DoxyParamCaption})}


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the pointer. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em v} & Pointer value. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference or std\+::nullopt. 
\end{DoxyReturn}

\doxysection{Concepts}
Here is a list of all concepts with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{a01565}{Ikarus\+::\+Concepts\+::\+Adaptive\+Step\+Sizing\+Strategy}} \\*Concept to check if a type implements all the needed functions to be an adaptive step sizing method }{\pageref{a01565}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01569}{Ikarus\+::\+Concepts\+::\+Add\+Able}} \\*Concept defining the requirements for types that support addition }{\pageref{a01569}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01573}{Ikarus\+::\+Concepts\+::\+Add\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place addition }{\pageref{a01573}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01562}{Ikarus\+::\+Concepts\+::\+Blocked\+Index\+Basis}} \\*Concept to check if a basis uses either Blocked\+Lexicographic or Blocked\+Interleaved indexing strategy }{\pageref{a01562}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01559}{Ikarus\+::\+Concepts\+::\+Blocked\+Inter\+Leaved\+Basis}} \\*Concept to check if a basis uses Blocked\+Interleaved indexing strategy }{\pageref{a01559}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01560}{Ikarus\+::\+Concepts\+::\+Blocked\+Lexicographic\+Basis}} \\*Concept to check if a basis uses Blocked\+Lexicographic indexing strategy }{\pageref{a01560}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01575}{Ikarus\+::\+Concepts\+::\+Divide\+Able}} \\*Concept defining the requirements for types that support division }{\pageref{a01575}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01572}{Ikarus\+::\+Concepts\+::\+Divide\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place division }{\pageref{a01572}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01561}{Ikarus\+::\+Concepts\+::\+Dune\+Local\+Basis}} \\*Concept to check if a local basis is a dune\+Local\+Basis }{\pageref{a01561}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01579}{Ikarus\+::\+Concepts\+::\+Eigen\+Vector}} \\*Concept defining the requirements for \mbox{\hyperlink{a00298}{Eigen}} vectors }{\pageref{a01579}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01558}{Ikarus\+::\+Concepts\+::\+Flat\+Index\+Basis}} \\*Concept to check if a basis uses Flat\+Index indexing strategy }{\pageref{a01558}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01556}{Ikarus\+::\+Concepts\+::\+Flat\+Inter\+Leaved\+Basis}} \\*Concept to check if a basis uses Flat\+Interleaved indexing strategy }{\pageref{a01556}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01557}{Ikarus\+::\+Concepts\+::\+Flat\+Lexicographic\+Basis}} \\*Concept to check if a basis uses Flat\+Lexicographic indexing strategy }{\pageref{a01557}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01578}{Ikarus\+::\+Concepts\+::\+Is\+Functor\+With\+Args}} \\*Concept defining the requirements for functors with arguments }{\pageref{a01578}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01580}{Ikarus\+::\+Concepts\+::\+Is\+Material}} \\*Concept defining the requirements for a material type }{\pageref{a01580}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01566}{Ikarus\+::\+Concepts\+::\+Linear\+Solver\+Check}} \\*Concept to check if a linear solver implements all the needed functions for given vector and matrix types }{\pageref{a01566}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01568}{Ikarus\+::\+Concepts\+::\+Multiply\+Able}} \\*Concept defining the requirements for types that support multiplication }{\pageref{a01568}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01571}{Ikarus\+::\+Concepts\+::\+Multiply\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place multiplication }{\pageref{a01571}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01576}{Ikarus\+::\+Concepts\+::\+Negate\+Able}} \\*Concept defining the requirements for types that support negation }{\pageref{a01576}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01567}{Ikarus\+::\+Concepts\+::\+Non\+Linear\+Solver\+Check\+For\+Path\+Following}} \\*Concept to check if a non-\/linear solver with its non-\/linear operator satisfies requirements for path following }{\pageref{a01567}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01564}{Ikarus\+::\+Concepts\+::\+Path\+Following\+Strategy}} \\*Concept defining the requirements for a path-\/following strategy }{\pageref{a01564}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01563}{Ikarus\+::\+Concepts\+::\+Power\+Basis}} \\*Concept to check if a basis uses power indexing strategy }{\pageref{a01563}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01570}{Ikarus\+::\+Concepts\+::\+Substract\+Able}} \\*Concept defining the requirements for types that support subtraction }{\pageref{a01570}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01574}{Ikarus\+::\+Concepts\+::\+Substract\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place subtraction }{\pageref{a01574}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01577}{Ikarus\+::\+Concepts\+::\+Transpose\+Able}} \\*Concept defining the requirements for types that support transposition }{\pageref{a01577}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01554}{Ikarus\+::\+Correct\+Strain\+Size}} \\*Template concept for ensuring correct strain size }{\pageref{a01554}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01552}{Ikarus\+::\+FEAffordance}} \\*Concept to check if a given type is one of the predefined affordance enums or the Affordance\+Collection\+Impl }{\pageref{a01552}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01555}{Ikarus\+::\+Material\+Parameter\+Tuple}} \\*Concept for checking if a type is a valid material parameter tuple }{\pageref{a01555}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01553}{Ikarus\+::\+Result\+Type\+Concept}} }{\pageref{a01553}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01581}{Ikarus\+::traits\+::\+Pointer}} \\*Concept to check if a type is a pointer or nullptr\+\_\+t }{\pageref{a01581}}{}
\end{DoxyCompactList}

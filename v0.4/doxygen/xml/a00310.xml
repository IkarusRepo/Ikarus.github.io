<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.4" xml:lang="en-US">
  <compounddef id="a00310" kind="group">
    <compoundname>algos</compoundname>
    <title>Algorithms</title>
      <sectiondef kind="var">
      <memberdef kind="variable" id="a00310_1ga62ee166e690831f40395df076e9cdddb" prot="public" static="yes" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::utils::countTypeSpecialization_v</definition>
        <argsstring></argsstring>
        <name>countTypeSpecialization_v</name>
        <qualifiedname>Ikarus::utils::countTypeSpecialization_v</qualifiedname>
        <initializer>= countTypeSpecialization&lt;Type, Tuple&gt;()</initializer>
        <briefdescription>
<para>Variable template for counting the occurrences of a specialization of a template type in a tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to count occurrences for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This variable template provides a compile-time constant for the count of occurrences of a specialization of a template type in a tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="414" column="25" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="414" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="a00310_1ga6e36d8f5163f232e3142ecbd0575e8b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Ikarus::utils::makeUniqueAndSort</definition>
        <argsstring>(std::ranges::random_access_range auto &amp;r)</argsstring>
        <name>makeUniqueAndSort</name>
        <qualifiedname>Ikarus::utils::makeUniqueAndSort</qualifiedname>
        <param>
          <type>std::ranges::random_access_range auto &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Sorts and removes duplicate elements from a random access range.</para>
<para>*. </para>
        </briefdescription>
        <detaileddescription>
<para>This function sorts the elements of the given random access range and removes duplicate elements, leaving only unique elements in the range.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>The random access range to be modified. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="28" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="28" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga8f6d2c90383de63c518cefeaccee76f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::appendUnique</definition>
        <argsstring>(std::ranges::random_access_range auto &amp;r, Value &amp;&amp;v)</argsstring>
        <name>appendUnique</name>
        <qualifiedname>Ikarus::utils::appendUnique</qualifiedname>
        <param>
          <type>std::ranges::random_access_range auto &amp;</type>
          <declname>r</declname>
        </param>
        <param>
          <type>Value &amp;&amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Appends a value to the range if it is not already present. </para>
        </briefdescription>
        <detaileddescription>
<para>This function appends a value to the given random access range only if the value is not already present in the range. It returns the index of the value in the range, whether it was added or already existed. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Value</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be appended. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>The random access range to be modified. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be appended. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The index of the value in the range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="44" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="44" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga11bb80da2430170954d6b7519f9498a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Ikarus::utils::printContent</definition>
        <argsstring>(Container &amp;&amp;c, std::ostream &amp;os=std::cout)</argsstring>
        <name>printContent</name>
        <qualifiedname>Ikarus::utils::printContent</qualifiedname>
        <param>
          <type>Container &amp;&amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
          <defval>std::cout</defval>
        </param>
        <briefdescription>
<para>Prints the contents of a container to the specified output stream. </para>
        </briefdescription>
        <detaileddescription>
<para>This function prints the contents of the given container to the specified output stream.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the container to be printed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>The container whose contents will be printed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>os</parametername>
</parameternamelist>
<parameterdescription>
<para>The output stream where the contents will be printed. Default is std::cout. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="63" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="63" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga5f3a9e195a06ac4419ccb479f8819d62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::transformValueRangeToPointerRange</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>transformValueRangeToPointerRange</name>
        <qualifiedname>Ikarus::utils::transformValueRangeToPointerRange</qualifiedname>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
<para>Transforms a value range to a pointer range. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the container containing values. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>The container whose values will be transformed to pointers. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A subrange containing pointers to the values. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="76" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="76" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1gaabfee41eeb4843cb2fa37b5f381e9fef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::transformPointerRangeToReferenceRange</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>transformPointerRangeToReferenceRange</name>
        <qualifiedname>Ikarus::utils::transformPointerRangeToReferenceRange</qualifiedname>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
<para>Transforms a pointer range to a reference range. </para>
        </briefdescription>
        <detaileddescription>
<para>This function transforms a range of pointers to a range of references.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the container containing pointers. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>The container whose pointers will be transformed to references. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A subrange containing references to the pointed objects. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="91" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="91" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1gaf75511e781bb89056badd33413222010" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>constexpr size_t Ikarus::utils::find_if</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>find_if</name>
        <qualifiedname>Ikarus::utils::find_if</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Finds the index of the first element in the tuple satisfying a predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to check each element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the first element satisfying the predicate. If no element satisfies the predicate, it returns the size of the tuple.</para>
</simplesect>
This function takes a tuple and a predicate function and finds the index of the first element in the tuple that satisfies the given predicate. It uses Dune::Hybrid::forEach to iterate through the tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="215" column="20" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="215" bodyend="228"/>
        <referencedby refid="a00310_1ga62d8ab565d41e49db75f0641bcdf0740" compoundref="a00044" startline="338" endline="342">Ikarus::utils::findTypeSpecialization</referencedby>
        <referencedby refid="a00310_1gaec2a5de0482441ef1e1c68fb7ff8a0bc" compoundref="a00044" startline="378" endline="383">Ikarus::utils::hasTypeSpecialization</referencedby>
        <referencedby refid="a00310_1ga33284bcf99d7d3870e0aff06f6651aa2" compoundref="a00044" startline="243" endline="245">Ikarus::utils::none_of</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga33284bcf99d7d3870e0aff06f6651aa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::none_of</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>none_of</name>
        <qualifiedname>Ikarus::utils::none_of</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Checks if none of the elements in the tuple satisfy a given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to check each element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>bool True if none of the elements satisfy the predicate, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="243" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="243" bodyend="245"/>
        <referencedby refid="a00310_1gab6d955a70ec9215ae9a8f3841582ab49" compoundref="a00044" startline="260" endline="262">Ikarus::utils::any_of</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00310_1gab6d955a70ec9215ae9a8f3841582ab49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Ikarus::utils::any_of</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>any_of</name>
        <qualifiedname>Ikarus::utils::any_of</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Checks if any of the elements in the tuple satisfy a given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to check each element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>bool True if any of the elements satisfy the predicate, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="260" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="260" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1gad9f30d486a3d9151d534ec1b0fad5341" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::filter</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>filter</name>
        <qualifiedname>Ikarus::utils::filter</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Filters the elements of a tuple based on a given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function to filter the elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Tuple containing elements that satisfy the predicate.</para>
</simplesect>
This function applies the given predicate to each element of the tuple. It constructs a new tuple containing only those elements for which the predicate returns true. The resulting tuple is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="279" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="279" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga12de8f77a63ef488a87a5aa8536146ee" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::utils::unique</definition>
        <argsstring>(std::tuple&lt; Types... &gt; &amp;&amp;tuple)</argsstring>
        <name>unique</name>
        <qualifiedname>Ikarus::utils::unique</qualifiedname>
        <param>
          <type>std::tuple&lt; Types... &gt; &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <briefdescription>
<para>Creates a tuple with unique types from the given tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Types</parametername>
</parameternamelist>
<parameterdescription>
<para>Variadic template parameters representing types. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>auto Tuple with unique types.</para>
</simplesect>
This function takes a tuple and returns a new tuple containing only unique types from the input tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="299" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="299" bodyend="301"/>
        <referencedby refid="a00310_1ga6e36d8f5163f232e3142ecbd0575e8b4" compoundref="a00044" startline="28" endline="31">Ikarus::utils::makeUniqueAndSort</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00310_1gae9a7254f583151ee431db537c9980865" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Tuple</type>
          </param>
          <param>
            <type>typename Predicate</type>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>constexpr size_t Ikarus::utils::count_if</definition>
        <argsstring>(Tuple &amp;&amp;tuple, Predicate pred)</argsstring>
        <name>count_if</name>
        <qualifiedname>Ikarus::utils::count_if</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Counts the number of elements in the tuple satisfying the given predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function determining whether an element satisfies the condition. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Input tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Predicate function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr size_t Number of elements satisfying the predicate.</para>
</simplesect>
This function counts the number of elements in the tuple that satisfy the given predicate. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="317" column="20" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="317" bodyend="323"/>
        <referencedby refid="a00310_1gadf919f3a9b0c1d50134f9d041a3ce9f7" compoundref="a00044" startline="397" endline="400">Ikarus::utils::countTypeSpecialization</referencedby>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga62d8ab565d41e49db75f0641bcdf0740" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr int</type>
        <definition>constexpr int Ikarus::utils::findTypeSpecialization</definition>
        <argsstring>()</argsstring>
        <name>findTypeSpecialization</name>
        <qualifiedname>Ikarus::utils::findTypeSpecialization</qualifiedname>
        <briefdescription>
<para>Finds the index of the first element in the tuple that is a specialization of the given template type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to search for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Index of the first specialization in the tuple</para>
</simplesect>
This function finds the index of the first element in the tuple that is a specialization of the given template type. It returns the size of the tuple if the template type is not found </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="338" column="17" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="338" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga05a5ccea0f87d41fc69956f55a2c1dbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Ikarus::utils::getSpecialization</definition>
        <argsstring>(Tuple &amp;&amp;tuple)</argsstring>
        <name>getSpecialization</name>
        <qualifiedname>Ikarus::utils::getSpecialization</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <briefdescription>
<para>Gets the specialization of the given template type from the tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to search for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>The tuple containing elements. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The specialization element</para>
</simplesect>
This function retrieves the specialization of a template type from the tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="357" column="8" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="357" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1gaec2a5de0482441ef1e1c68fb7ff8a0bc" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::utils::hasTypeSpecialization</definition>
        <argsstring>()</argsstring>
        <name>hasTypeSpecialization</name>
        <qualifiedname>Ikarus::utils::hasTypeSpecialization</qualifiedname>
        <briefdescription>
<para>Checks if a tuple has a specialization of a template type. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to check for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the tuple has the specialization; otherwise, false.</para>
</simplesect>
This function checks if a tuple has a specialization of a template type. It uses <computeroutput>find_if</computeroutput> to search for the type and returns true if the index is less than the tuple size; otherwise, false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="378" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="378" bodyend="383"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1gadf919f3a9b0c1d50134f9d041a3ce9f7" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; auto... &gt; class</type>
            <declname>Type</declname>
            <defname>Type</defname>
          </param>
          <param>
            <type>typename Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Ikarus::utils::countTypeSpecialization</definition>
        <argsstring>()</argsstring>
        <name>countTypeSpecialization</name>
        <qualifiedname>Ikarus::utils::countTypeSpecialization</qualifiedname>
        <briefdescription>
<para>Counts the occurrences of a specialization of a template type in a tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Type</parametername>
</parameternamelist>
<parameterdescription>
<para>Template type to count occurrences for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The count of occurrences of the specialization.</para>
</simplesect>
This function counts the occurrences of a specialization of a template type in a tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="397" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="397" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1ga32de94604b9d1a7423134f33f49d613f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>class Tuple</type>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::utils::makeTupleSubset</definition>
        <argsstring>(Tuple &amp;&amp;t)</argsstring>
        <name>makeTupleSubset</name>
        <qualifiedname>Ikarus::utils::makeTupleSubset</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Creates a subset tuple with the first N elements from the given tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements in the subset. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new tuple containing the first N elements of the original tuple.</para>
</simplesect>
This function creates a subset tuple with the first N elements from the given tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="429" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="429" bodyend="434"/>
      </memberdef>
      <memberdef kind="function" id="a00310_1gaef801f15c9f18ae16e4241a497c33e96" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tuple</type>
          </param>
          <param>
            <type>std::size_t...</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto Ikarus::utils::makeTupleFromTupleIndices</definition>
        <argsstring>(Tuple &amp;&amp;t)</argsstring>
        <name>makeTupleFromTupleIndices</name>
        <qualifiedname>Ikarus::utils::makeTupleFromTupleIndices</qualifiedname>
        <param>
          <type>Tuple &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Creates a new tuple using indices from the original tuple. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the original tuple. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices to include in the new tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The original tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A new tuple containing elements from the original tuple based on the specified indices.</para>
</simplesect>
This function creates a new tuple using indices from the original tuple. It uses <computeroutput>makeTupleFromTupleIndicesImpl</computeroutput> from the <computeroutput>Impl</computeroutput> namespace to implement the tuple creation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" line="450" column="18" bodyfile="/__w/ikarus/ikarus/repo/ikarus/utils/algorithms.hh" bodystart="450" bodyend="452"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Stl-like algorithms for runtime and compile time. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>

\doxysection{Concepts}
Here is a list of all concepts with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{a01765}{Ikarus\+::\+Concepts\+::\+Adaptive\+Step\+Sizing\+Strategy}} \\*Concept to check if a type implements all the needed functions to be an adaptive step sizing method }{\pageref{a01765}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01769}{Ikarus\+::\+Concepts\+::\+Add\+Able}} \\*Concept defining the requirements for types that support addition }{\pageref{a01769}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01773}{Ikarus\+::\+Concepts\+::\+Add\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place addition }{\pageref{a01773}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01763}{Ikarus\+::\+Concepts\+::\+Blocked\+Index\+Basis}} \\*Concept to check if a basis uses either Blocked\+Lexicographic or Blocked\+Interleaved indexing strategy }{\pageref{a01763}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01760}{Ikarus\+::\+Concepts\+::\+Blocked\+Inter\+Leaved\+Basis}} \\*Concept to check if a basis uses Blocked\+Interleaved indexing strategy }{\pageref{a01760}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01761}{Ikarus\+::\+Concepts\+::\+Blocked\+Lexicographic\+Basis}} \\*Concept to check if a basis uses Blocked\+Lexicographic indexing strategy }{\pageref{a01761}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01775}{Ikarus\+::\+Concepts\+::\+Divide\+Able}} \\*Concept defining the requirements for types that support division }{\pageref{a01775}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01772}{Ikarus\+::\+Concepts\+::\+Divide\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place division }{\pageref{a01772}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01762}{Ikarus\+::\+Concepts\+::\+Dune\+Local\+Basis}} \\*Concept to check if a local basis is a dune\+Local\+Basis }{\pageref{a01762}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01780}{Ikarus\+::\+Concepts\+::\+Eigen\+Matrix}} \\*Concept defining the requirements for \mbox{\hyperlink{a00361}{Eigen}} matrices. This also includes \mbox{\hyperlink{a00361}{Eigen}} vectors }{\pageref{a01780}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01779}{Ikarus\+::\+Concepts\+::\+Eigen\+Vector}} \\*Concept defining the requirements for \mbox{\hyperlink{a00361}{Eigen}} vectors }{\pageref{a01779}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01784}{Ikarus\+::\+Concepts\+::\+Flat\+Assembler}} \\*Concept representing the requirements for a Flat\+Assembler.

A type T satisfies Flat\+Assembler if it provides the necessary member functions and data types for assembling sparse matrices in a flat structure }{\pageref{a01784}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01759}{Ikarus\+::\+Concepts\+::\+Flat\+Index\+Basis}} \\*Concept to check if a basis uses Flat\+Index indexing strategy }{\pageref{a01759}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01755}{Ikarus\+::\+Concepts\+::\+Flat\+Inter\+Leaved\+Basis}} \\*Concept to check if a basis uses Flat\+Interleaved indexing strategy }{\pageref{a01755}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01758}{Ikarus\+::\+Concepts\+::\+Flat\+Lexicographic\+Basis}} \\*Concept to check if a basis uses Flat\+Lexicographic indexing strategy }{\pageref{a01758}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01778}{Ikarus\+::\+Concepts\+::\+Is\+Functor\+With\+Args}} \\*Concept defining the requirements for functors with arguments }{\pageref{a01778}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01781}{Ikarus\+::\+Concepts\+::\+Is\+Material}} \\*Concept defining the requirements for a material type }{\pageref{a01781}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01756}{Ikarus\+::\+Concepts\+::\+Lagrange\+Node}} \\*Concept to check if a node in a basis tree is a Lagrangian node }{\pageref{a01756}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01757}{Ikarus\+::\+Concepts\+::\+Lagrange\+Node\+Of\+Order}} }{\pageref{a01757}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01766}{Ikarus\+::\+Concepts\+::\+Linear\+Solver\+Check}} \\*Concept to check if a linear solver implements all the needed functions for given vector and matrix types }{\pageref{a01766}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01768}{Ikarus\+::\+Concepts\+::\+Multiply\+Able}} \\*Concept defining the requirements for types that support multiplication }{\pageref{a01768}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01771}{Ikarus\+::\+Concepts\+::\+Multiply\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place multiplication }{\pageref{a01771}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01776}{Ikarus\+::\+Concepts\+::\+Negate\+Able}} \\*Concept defining the requirements for types that support negation }{\pageref{a01776}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01767}{Ikarus\+::\+Concepts\+::\+Non\+Linear\+Solver\+Check\+For\+Path\+Following}} \\*Concept to check if a non-\/linear solver with its non-\/linear operator satisfies requirements for path following }{\pageref{a01767}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01764}{Ikarus\+::\+Concepts\+::\+Path\+Following\+Strategy}} \\*Concept defining the requirements for a path-\/following strategy }{\pageref{a01764}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01783}{Ikarus\+::\+Concepts\+::\+Result\+Type}} \\*A concept to check if a template type satisfies the Result\+Type requirements }{\pageref{a01783}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01770}{Ikarus\+::\+Concepts\+::\+Substract\+Able}} \\*Concept defining the requirements for types that support subtraction }{\pageref{a01770}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01774}{Ikarus\+::\+Concepts\+::\+Substract\+Assign\+Able}} \\*Concept defining the requirements for types that support in-\/place subtraction }{\pageref{a01774}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01777}{Ikarus\+::\+Concepts\+::\+Transpose\+Able}} \\*Concept defining the requirements for types that support transposition }{\pageref{a01777}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01753}{Ikarus\+::\+Correct\+Strain\+Size}} \\*Template concept for ensuring correct strain size }{\pageref{a01753}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01752}{Ikarus\+::\+FEAffordance}} \\*Concept to check if a given type is one of the predefined affordance enums or the Affordance\+Collection }{\pageref{a01752}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01754}{Ikarus\+::\+MPTuple}} \\*Concept for checking if a type is a valid material parameter tuple }{\pageref{a01754}}{}
\item\contentsline{section}{\mbox{\hyperlink{a01785}{Ikarus\+::traits\+::\+Pointer}} \\*Concept to check if a type is a pointer or nullptr\+\_\+t }{\pageref{a01785}}{}
\end{DoxyCompactList}

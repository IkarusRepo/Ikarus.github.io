{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6","title":"Home"},{"location":"#welcome-to-mkdocs","text":"","title":"Welcome to MkDocs"},{"location":"BuildTheDocumentationLocally/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the installation page . On Windows: Make sure Python , Drawio and Git are installed on your computer. Admin rights are required for the installation, contact your admin if it's not installed. On Ubuntu: execute (one-by-one): sudo apt-get install git -y sudo apt-get install python3 -y wget https://github.com/jgraph/drawio-desktop/releases/download/v14.6.13/drawio-amd64-14.6.13.deb sudo apt-get install libappindicator3-1 sudo dpkg -i drawio-amd64-14.6.13.deb sudo apt-get -y -f install sudo apt install libasound2 xvfb Preview the documentation locally \u00b6 Execute (double-click) Ikarus/docs/BuildLocally/InstalldepsForDocBuild.sh Another window should open now which installs python packages. Wait until it closes itself. Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser You can edit the documentation in CLion. STRG + s saves the documentation and updates it in your browser window. Cancel the build process to stop the live preview","title":"Build the documentation locally"},{"location":"BuildTheDocumentationLocally/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"BuildTheDocumentationLocally/#prerequisites","text":"Ikarus cloned on your computer, see the installation page . On Windows: Make sure Python , Drawio and Git are installed on your computer. Admin rights are required for the installation, contact your admin if it's not installed. On Ubuntu: execute (one-by-one): sudo apt-get install git -y sudo apt-get install python3 -y wget https://github.com/jgraph/drawio-desktop/releases/download/v14.6.13/drawio-amd64-14.6.13.deb sudo apt-get install libappindicator3-1 sudo dpkg -i drawio-amd64-14.6.13.deb sudo apt-get -y -f install sudo apt install libasound2 xvfb","title":"Prerequisites"},{"location":"BuildTheDocumentationLocally/#preview-the-documentation-locally","text":"Execute (double-click) Ikarus/docs/BuildLocally/InstalldepsForDocBuild.sh Another window should open now which installs python packages. Wait until it closes itself. Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser You can edit the documentation in CLion. STRG + s saves the documentation and updates it in your browser window. Cancel the build process to stop the live preview","title":"Preview the documentation locally"},{"location":"howToEdit/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the installation page . Edit a page \u00b6 Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated Add a new page \u00b6 Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated Insert a latex formula \u00b6 $$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$ is compiled to \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\] Insert C++ code \u00b6 Look at the markdown file of this page to see how C++ code can be inserted. double complicatedCalculation ( double number , double anotherNumber ) { return number * anotherNumber ; }; Insert a table \u00b6 Look at the markdown file of this page to see how a table can be inserted. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl ) Insert a warning \u00b6 This should only be done in case it is really important: Warning Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.","title":"How to edit the documentation"},{"location":"howToEdit/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"howToEdit/#prerequisites","text":"Ikarus cloned on your computer, see the installation page .","title":"Prerequisites"},{"location":"howToEdit/#edit-a-page","text":"Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Edit a page"},{"location":"howToEdit/#add-a-new-page","text":"Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Add a new page"},{"location":"howToEdit/#insert-a-latex-formula","text":"$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$ is compiled to \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]","title":"Insert a latex formula"},{"location":"howToEdit/#insert-c-code","text":"Look at the markdown file of this page to see how C++ code can be inserted. double complicatedCalculation ( double number , double anotherNumber ) { return number * anotherNumber ; };","title":"Insert C++ code"},{"location":"howToEdit/#insert-a-table","text":"Look at the markdown file of this page to see how a table can be inserted. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl )","title":"Insert a table"},{"location":"howToEdit/#insert-a-warning","text":"This should only be done in case it is really important: Warning Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.","title":"Insert a warning"},{"location":"installation/","text":"Installation of Ikarus \u00b6 This installation guide is tested on Windows. Get a working C++ environment \u00b6 CLion needs to be installed on your computer. Download MinGW with GCC 11 (C++ compiler) from Winlibs . Choose GCC 11.1.0 + LLVM/Clang/LLD/LLDB 12.0.0 + MinGW-w64 9.0.0 - release 2 Win64. 7-zip or zip makes no difference Unpack it in any location of your choice Tell CLion to use the recently downloaded GCC. In CLion Go to File --> Settings --> Build, Execution, Deployment --> Toolchains In the field Environment , copy the path where you unpacked the download e.g. C:\\myFolder\\mySubFolder\\mingw64 CLion should now detect CMake, the compilers and the debugger Clone Ikarus \u00b6 Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below Further reading: \u00b6 As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Installation"},{"location":"installation/#installation-of-ikarus","text":"This installation guide is tested on Windows.","title":"Installation of Ikarus"},{"location":"installation/#get-a-working-c-environment","text":"CLion needs to be installed on your computer. Download MinGW with GCC 11 (C++ compiler) from Winlibs . Choose GCC 11.1.0 + LLVM/Clang/LLD/LLDB 12.0.0 + MinGW-w64 9.0.0 - release 2 Win64. 7-zip or zip makes no difference Unpack it in any location of your choice Tell CLion to use the recently downloaded GCC. In CLion Go to File --> Settings --> Build, Execution, Deployment --> Toolchains In the field Environment , copy the path where you unpacked the download e.g. C:\\myFolder\\mySubFolder\\mingw64 CLion should now detect CMake, the compilers and the debugger","title":"Get a working C++ environment"},{"location":"installation/#clone-ikarus","text":"Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below","title":"Clone Ikarus"},{"location":"installation/#further-reading","text":"As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Further reading:"},{"location":"theory/theoryFiniteElement/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Topics \u00b6 How is the geometry implemented","title":"Finite Elements"},{"location":"theory/theoryFiniteElement/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"theory/theoryFiniteElement/#topics","text":"How is the geometry implemented","title":"Topics"},{"location":"theory/theoryGeometry/","text":"Geometry type and description \u00b6 Geometry type \u00b6 Geometry description \u00b6 As described in the interface of the grid entity on the grid theory page , a grid entity has to be able to provide a geometry description, i.e. it has to return an object which satisfies the geometry interface described below. Geometry interface \u00b6 ToDo: description of the geometry interface Geometry implementation \u00b6 ToDo: description of the available implementations","title":"Geometry"},{"location":"theory/theoryGeometry/#geometry-type-and-description","text":"","title":"Geometry type and description"},{"location":"theory/theoryGeometry/#geometry-type","text":"","title":"Geometry type"},{"location":"theory/theoryGeometry/#geometry-description","text":"As described in the interface of the grid entity on the grid theory page , a grid entity has to be able to provide a geometry description, i.e. it has to return an object which satisfies the geometry interface described below.","title":"Geometry description"},{"location":"theory/theoryGeometry/#geometry-interface","text":"ToDo: description of the geometry interface","title":"Geometry interface"},{"location":"theory/theoryGeometry/#geometry-implementation","text":"ToDo: description of the available implementations","title":"Geometry implementation"},{"location":"theory/theoryGrid/","text":"Description of the grid \u00b6 In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. provide a unique identifier (element number) provide a description of the reference geometry (element shape in physical space, shape functions, etc.) provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . This page explains the relationship and the ideas behind everything that has to do with the grid. The relationship is visualized in the following diagram: On this page, we will go through it using the following example: Grid \u00b6 The grid is a collection of grid entities. In the example above, the grid consists of three surfaces, ten edges and eight vertices, i.e. it consists of 21 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job. Interface of the grid \u00b6 leafGridView() : returns a grid view , i.e. an object which can iterate over the grid. Available grid implementations \u00b6 SimpleGrid : Currently the only available grid implementation. To construct it, use SimpleGridFactory , as a grid view use SimpleGridView . It has the following capabilities : It is a template: SimpleGrid<dim,wdim> where dim is the dimension of the grid entities and wdim is the dimension of the world. Dimension of grid entity in this case means: dim=1: e.g. truss elements, beams (one element-internal coordinate xi exists) dim=2: e.g. plate elements (two element-internal coordinates xi and eta exist) dim=3: 3d elements All meaningful combinations up to three dimensions can be instantiated, e.g. truss elements (dim=1) in 2d (wdim=2) Different types of grid entities are supported in the same grid as long as they have the dimension specified by dim (for details on these types see TODO): dim=1: linearLine dim=2: linearTriangle, linearQuadrilateral dim=3: linearTetrahedron, pyramid, prism, linearHexahedron Some restrictions apply: You can't insert grid entities of different dimensions into the same SimpleGrid Other types than the ones mentioned above are not supported The world dimension is limited to 3. Grid entity \u00b6 A grid entity provides all information related to the element geometry. Interface of grid entity \u00b6 A grid entity has the following properties: geometry() : returns the geometrical realization, i.e. an object that satisfies the geometry interface. Further details about this interface and what the returned object is able to do can be found on the geometry theory page . type() : returns the geometrical type, e.g. it can be a vertex, a linear line defined by two point or a quadrilateral with linear edges. The difference between type() and geometry() is that type() only returns a name whereas geometry() returns an object with functionality. vertices(gridEntity) , edges(gridEntity) , surfaces(gridEntity) and volumes(gridEntity) : Each entity has sub-entities of lower dimension. In the example above, surface S1 has the following sub-entities: four edges (number 1,2,4,6) and four vertices (number 1,2,4,5). vertices(S1) returns a span of vertices. The other functions work similarly. entities(gridEntity, dimension) does the same as the functions above, i.e. entities(gridEntity, 0) does the same as vertices(gridEntity) . entities(gridEntity, 1) does the same as edges(gridEntity) . ... subEntities(codimension) returns the number of subentities. Codimension in this case is the dimension of the grid entity minus the dimension of the requested subentity. Example: The grid entity is a 3d volume. subEntities(1) returns the number of surfaces of this volume because codimension=1 means your query is about the subentities one dimension lower than the object itself. getID() : returns a unique identifier Implementation of grid entity \u00b6 There is currently one implementation of the GridEntity interface available, which is DefaultGridEntity . It is supposed to be used together with the grid implementation SimpleGrid . template < int griddim , int cogriddim , int wdim > class DefaultGridEntity { // ... }; It is based on three template parameters griddim (dimension of the grid), cogriddim (???) and wdim (dimension of the world). Grid factory \u00b6 To construct a grid, a grid factory can be used. To construct a grid, vertices and element definitions are inserted into the factory. The grid is then constructed by the createGrid() function. Interface of the grid factory \u00b6 insertVertex(Eigen::Vector<double, dimensionworld>) : Vertices are inserted as a Eigen::Vector of double. Its size is equal to the dimensions of the world (e.g. 2 if it is a 2d simulation etc.) insertElement(Ikarus::GeometryType type, std::span<size_t> vertices) : An element is defined by its geometrical type and the vertex numbers. For the ordering of the node numbers, see ToDo Implementation of grid factory \u00b6 SimpleGridFactory : Constructs a SimpleGrid . The same restrictions apply as stated above for SimpleGrid . Grid view \u00b6 Interface of grid view \u00b6 The interface of a grid view consists of four free functions. Each of them provides a span of certain grid objects: vertices(GridView) : returns a span of all vertices in this grid edges(GridView) : returns a span of all edges in this grid surfaces(GridView) : returns a span of all surfaces in this grid volumes(GridView) : returns a span of all volumes in this grid Implementation of grid view \u00b6 SimpleGridView : Provides iterators for SimpleGrid .","title":"Grid"},{"location":"theory/theoryGrid/#description-of-the-grid","text":"In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. provide a unique identifier (element number) provide a description of the reference geometry (element shape in physical space, shape functions, etc.) provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . This page explains the relationship and the ideas behind everything that has to do with the grid. The relationship is visualized in the following diagram: On this page, we will go through it using the following example:","title":"Description of the grid"},{"location":"theory/theoryGrid/#grid","text":"The grid is a collection of grid entities. In the example above, the grid consists of three surfaces, ten edges and eight vertices, i.e. it consists of 21 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job.","title":"Grid"},{"location":"theory/theoryGrid/#interface-of-the-grid","text":"leafGridView() : returns a grid view , i.e. an object which can iterate over the grid.","title":"Interface of the grid"},{"location":"theory/theoryGrid/#available-grid-implementations","text":"SimpleGrid : Currently the only available grid implementation. To construct it, use SimpleGridFactory , as a grid view use SimpleGridView . It has the following capabilities : It is a template: SimpleGrid<dim,wdim> where dim is the dimension of the grid entities and wdim is the dimension of the world. Dimension of grid entity in this case means: dim=1: e.g. truss elements, beams (one element-internal coordinate xi exists) dim=2: e.g. plate elements (two element-internal coordinates xi and eta exist) dim=3: 3d elements All meaningful combinations up to three dimensions can be instantiated, e.g. truss elements (dim=1) in 2d (wdim=2) Different types of grid entities are supported in the same grid as long as they have the dimension specified by dim (for details on these types see TODO): dim=1: linearLine dim=2: linearTriangle, linearQuadrilateral dim=3: linearTetrahedron, pyramid, prism, linearHexahedron Some restrictions apply: You can't insert grid entities of different dimensions into the same SimpleGrid Other types than the ones mentioned above are not supported The world dimension is limited to 3.","title":"Available grid implementations"},{"location":"theory/theoryGrid/#grid-entity","text":"A grid entity provides all information related to the element geometry.","title":"Grid entity"},{"location":"theory/theoryGrid/#interface-of-grid-entity","text":"A grid entity has the following properties: geometry() : returns the geometrical realization, i.e. an object that satisfies the geometry interface. Further details about this interface and what the returned object is able to do can be found on the geometry theory page . type() : returns the geometrical type, e.g. it can be a vertex, a linear line defined by two point or a quadrilateral with linear edges. The difference between type() and geometry() is that type() only returns a name whereas geometry() returns an object with functionality. vertices(gridEntity) , edges(gridEntity) , surfaces(gridEntity) and volumes(gridEntity) : Each entity has sub-entities of lower dimension. In the example above, surface S1 has the following sub-entities: four edges (number 1,2,4,6) and four vertices (number 1,2,4,5). vertices(S1) returns a span of vertices. The other functions work similarly. entities(gridEntity, dimension) does the same as the functions above, i.e. entities(gridEntity, 0) does the same as vertices(gridEntity) . entities(gridEntity, 1) does the same as edges(gridEntity) . ... subEntities(codimension) returns the number of subentities. Codimension in this case is the dimension of the grid entity minus the dimension of the requested subentity. Example: The grid entity is a 3d volume. subEntities(1) returns the number of surfaces of this volume because codimension=1 means your query is about the subentities one dimension lower than the object itself. getID() : returns a unique identifier","title":"Interface of grid entity"},{"location":"theory/theoryGrid/#implementation-of-grid-entity","text":"There is currently one implementation of the GridEntity interface available, which is DefaultGridEntity . It is supposed to be used together with the grid implementation SimpleGrid . template < int griddim , int cogriddim , int wdim > class DefaultGridEntity { // ... }; It is based on three template parameters griddim (dimension of the grid), cogriddim (???) and wdim (dimension of the world).","title":"Implementation of grid entity"},{"location":"theory/theoryGrid/#grid-factory","text":"To construct a grid, a grid factory can be used. To construct a grid, vertices and element definitions are inserted into the factory. The grid is then constructed by the createGrid() function.","title":"Grid factory"},{"location":"theory/theoryGrid/#interface-of-the-grid-factory","text":"insertVertex(Eigen::Vector<double, dimensionworld>) : Vertices are inserted as a Eigen::Vector of double. Its size is equal to the dimensions of the world (e.g. 2 if it is a 2d simulation etc.) insertElement(Ikarus::GeometryType type, std::span<size_t> vertices) : An element is defined by its geometrical type and the vertex numbers. For the ordering of the node numbers, see ToDo","title":"Interface of the grid factory"},{"location":"theory/theoryGrid/#implementation-of-grid-factory","text":"SimpleGridFactory : Constructs a SimpleGrid . The same restrictions apply as stated above for SimpleGrid .","title":"Implementation of grid factory"},{"location":"theory/theoryGrid/#grid-view","text":"","title":"Grid view"},{"location":"theory/theoryGrid/#interface-of-grid-view","text":"The interface of a grid view consists of four free functions. Each of them provides a span of certain grid objects: vertices(GridView) : returns a span of all vertices in this grid edges(GridView) : returns a span of all edges in this grid surfaces(GridView) : returns a span of all surfaces in this grid volumes(GridView) : returns a span of all volumes in this grid","title":"Interface of grid view"},{"location":"theory/theoryGrid/#implementation-of-grid-view","text":"SimpleGridView : Provides iterators for SimpleGrid .","title":"Implementation of grid view"},{"location":"theory/theoryOverview/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Seperation of interface and implementation \u00b6 On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car. Interface of a car \u00b6 Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then: brand() : a function which returns the brand as a string maxvelocity() : a function which returns the maximum velocity as a double This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above. Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double. Implementation of a car \u00b6 Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar . Summary \u00b6 Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface Member functions and free functions \u00b6 In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like brand(car) in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for MyCar then looks like this: std :: string brand ( MyCar carObject ) { return \"MyBrand\" ;} This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).","title":"Overview"},{"location":"theory/theoryOverview/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"theory/theoryOverview/#seperation-of-interface-and-implementation","text":"On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car.","title":"Seperation of interface and implementation"},{"location":"theory/theoryOverview/#interface-of-a-car","text":"Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then: brand() : a function which returns the brand as a string maxvelocity() : a function which returns the maximum velocity as a double This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above. Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double.","title":"Interface of a car"},{"location":"theory/theoryOverview/#implementation-of-a-car","text":"Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar .","title":"Implementation of a car"},{"location":"theory/theoryOverview/#summary","text":"Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface","title":"Summary"},{"location":"theory/theoryOverview/#member-functions-and-free-functions","text":"In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like brand(car) in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for MyCar then looks like this: std :: string brand ( MyCar carObject ) { return \"MyBrand\" ;} This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).","title":"Member functions and free functions"},{"location":"tutorials/tutGrid/","text":"Grid tutorials \u00b6 This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project . SimpleGrid \u00b6 This tutorial explains how to use SimpleGrid<dim,wdim> . SimpleGrid<dim,wdim> uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions.","title":"Grid"},{"location":"tutorials/tutGrid/#grid-tutorials","text":"This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project .","title":"Grid tutorials"},{"location":"tutorials/tutGrid/#simplegrid","text":"This tutorial explains how to use SimpleGrid<dim,wdim> . SimpleGrid<dim,wdim> uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions.","title":"SimpleGrid"},{"location":"tutorials/tutorialsOverview/","text":"Tutorials \u00b6 This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the underlying theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section . Topics \u00b6 To be added","title":"Overview"},{"location":"tutorials/tutorialsOverview/#tutorials","text":"This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the underlying theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section .","title":"Tutorials"},{"location":"tutorials/tutorialsOverview/#topics","text":"To be added","title":"Topics"}]}
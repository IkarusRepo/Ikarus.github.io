{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the documentation of Ikarus \u00b6 Ikarus is a finite element software originated at the Institute for Structural Mechanics at the university of Stuttgart. This project tries to provide an easy to read and an easy to use finite element framework. It is heavily inspired by the finite element softwares DUNE , the book DUNE \u2014 The Distributed and Unified Numerics Environment , deal.II and Kratos . Furthermore it directly used several modules from DUNE . We favor value semantics and readability. Concerning the design of CI and the documentation we were inspired by Autodiff and Kratos . The documentation is build using Material for MkDocs .","title":"Home"},{"location":"#welcome-to-the-documentation-of-ikarus","text":"Ikarus is a finite element software originated at the Institute for Structural Mechanics at the university of Stuttgart. This project tries to provide an easy to read and an easy to use finite element framework. It is heavily inspired by the finite element softwares DUNE , the book DUNE \u2014 The Distributed and Unified Numerics Environment , deal.II and Kratos . Furthermore it directly used several modules from DUNE . We favor value semantics and readability. Concerning the design of CI and the documentation we were inspired by Autodiff and Kratos . The documentation is build using Material for MkDocs .","title":"Welcome to the documentation of Ikarus"},{"location":"AdvancedTopics/","text":"Advanced topics \u00b6 The following topics are probably not relevant for your daily work, but you might need this knowledge at some point. Add additional dependencies or update existing dependencies to a newer version \u00b6 All the dependencies of Ikarus are shipped in a docker container. The corresponding docker image is available at https://github.com/IkarusRepo/DockerContainer . In order to modify the dependencies, you need to create a modified version of this dockerfile, create a new docker container and execute your code in this docker container (i.e. change the docker image to be used in the CLion settings).","title":"Advanced Topics"},{"location":"AdvancedTopics/#advanced-topics","text":"The following topics are probably not relevant for your daily work, but you might need this knowledge at some point.","title":"Advanced topics"},{"location":"AdvancedTopics/#add-additional-dependencies-or-update-existing-dependencies-to-a-newer-version","text":"All the dependencies of Ikarus are shipped in a docker container. The corresponding docker image is available at https://github.com/IkarusRepo/DockerContainer . In order to modify the dependencies, you need to create a modified version of this dockerfile, create a new docker container and execute your code in this docker container (i.e. change the docker image to be used in the CLion settings).","title":"Add additional dependencies or update existing dependencies to a newer version"},{"location":"cppRef/","text":"C++ recommendations \u00b6 As you may know by now Ikarus is written in C++. On this page we summerize recommendation to dig deeper into C++ coding. Should i write a member function or a free- function? \u00b6 Scott Meyers recommends the following algorithm: Link When to use const? \u00b6 Arthur O'Dwyer blog How should i pass my parameters to a function? \u00b6 Herb Sutter Cppcon Talk 2014 Best practices \u00b6 C++ Core Guidelines (A lot to learn there and you can just search some topic.) Jason Turner's collection of best practices More C++ idioms Further references \u00b6 Cppcon Videos These videos are released after every conference. For beginners the Back to basics track can be recommended. Godblot Online compiler with assembler output. Nice to test fast if something would be fast or slow. Also Eigen can be added. Also any other header found on the internet can be include with the link. Videos \u00b6 Here we collect usefull videos on coding or coding c++ - Clean Code - Uncle Bob / Lesson 1 How to write code cleanly, see also 1 - CppCon 2014: Herb Sutter \"Back to the Basics! Essentials of Modern C++ Style\" - CppCon 2018: Jonathan Boccara \u201c105 STL Algorithms in Less Than an Hour\u201d \"Almost\" all algorithms in the STL - Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019 How to do modern \"Object-Oriented Programming\" (If you really have to) - [CppCon 2021 - Back To Basics] ( https://www.youtube.com/watch?v=Bt3zcJZIalk&list=PLHTh1InhhwT4TJaHBVWzvBOYhp27UO7mI ) - CppCon 2019 Back to Basics Books \u00b6 2 3 4 5 Robert C Martin. Clean Code . Pearson Education, 2008. \u21a9 Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software . Pearson Deutschland GmbH, 1995. \u21a9 Martin Reddy. API Design for C++ . Elsevier, 2011. \u21a9 Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs . Pearson Education, 2005. \u21a9 Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version . Pearson Education, 1995. \u21a9","title":"C++ recommendations"},{"location":"cppRef/#c-recommendations","text":"As you may know by now Ikarus is written in C++. On this page we summerize recommendation to dig deeper into C++ coding.","title":"C++ recommendations"},{"location":"cppRef/#should-i-write-a-member-function-or-a-free-function","text":"Scott Meyers recommends the following algorithm: Link","title":"Should i write a member function or a free- function?"},{"location":"cppRef/#when-to-use-const","text":"Arthur O'Dwyer blog","title":"When to use const?"},{"location":"cppRef/#how-should-i-pass-my-parameters-to-a-function","text":"Herb Sutter Cppcon Talk 2014","title":"How should i pass my parameters to a function?"},{"location":"cppRef/#best-practices","text":"C++ Core Guidelines (A lot to learn there and you can just search some topic.) Jason Turner's collection of best practices More C++ idioms","title":"Best practices"},{"location":"cppRef/#further-references","text":"Cppcon Videos These videos are released after every conference. For beginners the Back to basics track can be recommended. Godblot Online compiler with assembler output. Nice to test fast if something would be fast or slow. Also Eigen can be added. Also any other header found on the internet can be include with the link.","title":"Further references"},{"location":"cppRef/#videos","text":"Here we collect usefull videos on coding or coding c++ - Clean Code - Uncle Bob / Lesson 1 How to write code cleanly, see also 1 - CppCon 2014: Herb Sutter \"Back to the Basics! Essentials of Modern C++ Style\" - CppCon 2018: Jonathan Boccara \u201c105 STL Algorithms in Less Than an Hour\u201d \"Almost\" all algorithms in the STL - Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019 How to do modern \"Object-Oriented Programming\" (If you really have to) - [CppCon 2021 - Back To Basics] ( https://www.youtube.com/watch?v=Bt3zcJZIalk&list=PLHTh1InhhwT4TJaHBVWzvBOYhp27UO7mI ) - CppCon 2019 Back to Basics","title":"Videos"},{"location":"cppRef/#books","text":"2 3 4 5 Robert C Martin. Clean Code . Pearson Education, 2008. \u21a9 Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software . Pearson Deutschland GmbH, 1995. \u21a9 Martin Reddy. API Design for C++ . Elsevier, 2011. \u21a9 Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs . Pearson Education, 2005. \u21a9 Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version . Pearson Education, 1995. \u21a9","title":"Books"},{"location":"download/","text":"Installation of Ikarus \u00b6 Change links on this website when final accounts for repository and docker container are fixed and remove this warning. Graphical output is currently not supported on Windows 10 (but will probably be available in the future). Therefore, working on Windows 11 is recommended. The installations on Windows relies on WSL 2, i.e. although working with Windows, the code is compiled and executed in Linux. Installation on Windows using Docker Container \u00b6 Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. wsl --install wsl --set-default-version 2 #(Is not needed for Windows 11) Download and install Docker for Windows . During the installation, select the option \"Install requred Windows components for WSL 2\" Install debian from WindowsAppStore Open the debian app Give yourself a username and password Close the debian app Open the PowerShell and execute: wsl --list --all Debian should appear as one of the available Linux distributions. In the PowerShell execute: wsl --setdefault Debian Try to start Docker. If it works, continue with the next step. If a message occurs that you are not allowed to use docker because you are not in the docker user group, follow these instructions . In short: Open Computerverwaltung as admin Go to Lokale Benutzer und Gruppen and find docker-users Add your Account (or a group of which you are a member) to the group. Restart your computer In Docker, go to Settings \u2192 General and select autostart for docker (otherwise you have to start it manually each time you want to work with Ikarus). In the Docker settings, select that Docker uses your WSL2 distribution Debian as shown in the picture. In cases docker says that you don't have a WSL 2 distribution, go to the PowerShell and execute wsl --set-default-version 2 #(just to be sure that you didn't forgot this at the beginning) wsl --set-version Debian 2 #(Converts debian to version 2) You should now be able to change the docker settings according to the picture above. Open the PowerShell and execute: docker pull rath3t/ikarus-debian-bookworm:latest Download and install CLion EAP Version . In CLion EAP Version, go to File and Settings and apply the following settings for the toolchain: Edit the Container settings and paste the following command into Run options : -e DISPLAY=:0 -v \\\\wsl$\\debian\\mnt\\wslg\\.X11-unix:/tmp/.X11-unix -v \\\\wsl$\\debian\\mnt\\wslg:/mnt/wslg -p 8000:8000 Clone Ikarus Clone Ikarus \u00b6 Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below Installation on Windows using WSL \u00b6 This installation procedure is not recommended The installation using Docker described above has several advantages and should be the standard. This section will be removed in the future Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. wsl --install wsl --set-default-version 2 #(Is not needed for Windows 11) Install debian from .tar file OR alternatively (3) wsl --import debian <install location> debian_bookworm.tar Install debian manually Install from WindowsAppStore Open the debian app Give yourself a username and password Execute in debian sudo sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list Execute the following list of commands in debian sudo apt update && \\ sudo apt full-upgrade -y && \\ sudo apt -y install lsb-release && \\ sudo apt -y install build-essential \\ libssl-dev \\ git \\ wget \\ apt-utils \\ software-properties-common \\ gfortran \\ gcc-11 \\ g++-11 \\ gcovr \\ clang \\ libmetis-dev \\ clang-tidy \\ libclang-13-dev \\ clang-format-13 \\ libc++-13-dev \\ libc++abi-13-dev \\ llvm-13-dev \\ liblapack-dev \\ libopenblas-dev \\ libsuitesparse-dev \\ libdune-common-dev \\ libdune-geometry-dev \\ libdune-grid-dev \\ libdune-functions-dev \\ libdune-typetree-dev \\ libdune-localfunctions-dev \\ libdune-uggrid-dev \\ libdune-grid-glue-dev \\ libdune-istl-dev \\ libspdlog-dev \\ libbenchmark-dev \\ libgtest-dev \\ gnuplot \\ python3 \\ pip \\ clang-format-12 \\ gnuplot-x11 \\ curl \\ cppcheck && \\ sudo apt-get install libayatana-appindicator3-1 -y && \\ sudo apt-get -y -f install && \\ sudo apt install libasound2 xvfb -y && \\ wget https://github.com/jgraph/drawio-desktop/releases/download/v16.5.1/drawio-amd64-16.5.1.deb && \\ sudo dpkg -i drawio-amd64-16.5.1.deb && \\ pip install cmakelang == 0 .6.13 pyyaml && \\ pip install mkdocs && \\ pip install mkdocs-material && \\ pip install mkdocs-macros-plugin && \\ pip install mkdocs-drawio-exporter && \\ && \\ sudo cp /usr/bin/clang-format-12 /usr/bin/clang-format && \\ cd /usr/local/bin && \\ sudo ln -s $HOME /.local/bin/cmake-format cmake-format && \\ sudo ln -s $HOME /.local/bin/mkdocs mkdocs && \\ cd ~ && \\ mkdir -p iwyu && \\ cd iwyu && \\ git clone https://github.com/include-what-you-use/include-what-you-use.git && \\ cd include-what-you-use && \\ git checkout clang_13 && \\ cd .. && \\ mkdir -p build && cd build && \\ cmake -G \"Unix Makefiles\" -DIWYU_LLVM_ROOT_PATH = /usr/lib/llvm-13 ../include-what-you-use && \\ make && \\ sudo make install && \\ cd /usr/src/googletest && \\ cmake . && \\ sudo cmake --build . --target install && \\ cd ~ && \\ git clone https://gitlab.com/libeigen/eigen.git && \\ cd eigen && \\ git checkout 3 .4 && \\ mkdir build && \\ cd build && \\ cmake ../ && \\ sudo make install && \\ cd ~ && \\ rm -rf eigen && \\ git clone https://github.com/alandefreitas/matplotplusplus.git && \\ cd matplotplusplus && \\ mkdir -p build && \\ cd build && \\ cmake .. -DCMAKE_BUILD_TYPE = Release -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF && \\ cmake --build . --parallel 4 --config Release && \\ sudo cmake --install . && \\ cd ~ && \\ rm -rf matplotplusplus && \\ git clone https://github.com/autodiff/autodiff && \\ cd autodiff/ && \\ mkdir .build && \\ cd .build/ && \\ cmake .. -DAUTODIFF_BUILD_PYTHON = 0 -DAUTODIFF_BUILD_EXAMPLES = 0 -DAUTODIFF_BUILD_DOCS = 0 -DAUTODIFF_BUILD_TESTS = 0 && \\ sudo cmake --build . --target install && \\ cd ../.. && \\ mkdir -p dune && \\ cd dune && \\ git clone https://gitlab.dune-project.org/extensions/dune-alugrid.git && \\ git clone https://gitlab.dune-project.org/extensions/dune-foamgrid.git && \\ dunecontrol git checkout releases/2.8 && \\ git clone https://github.com/rath3t/dune-iga.git && \\ dunecontrol cmake \"-DCMAKE_BUILD_TYPE=Release\" && \\ dunecontrol make && \\ sudo dunecontrol make install && \\ cd .. && \\ rm -rf dune && \\ sudo apt-get auto-remove -y && \\ sudo apt-get clean wget https://raw.githubusercontent.com/JetBrains/clion-wsl/master/ubuntu_setup_env.sh && bash ubuntu_setup_env.sh In Clion, go to File and Settings and apply the following settings for the toolchain: Build, Execution, Deployment \u2192 Toolchains: Add with the + -sign a WSL configuration Make sure it is used as defaultm i.e. it has to be the first item in the list. Move it up with the arrow buttons otherwise.","title":"Download"},{"location":"download/#installation-of-ikarus","text":"Change links on this website when final accounts for repository and docker container are fixed and remove this warning. Graphical output is currently not supported on Windows 10 (but will probably be available in the future). Therefore, working on Windows 11 is recommended. The installations on Windows relies on WSL 2, i.e. although working with Windows, the code is compiled and executed in Linux.","title":"Installation of Ikarus"},{"location":"download/#installation-on-windows-using-docker-container","text":"Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. wsl --install wsl --set-default-version 2 #(Is not needed for Windows 11) Download and install Docker for Windows . During the installation, select the option \"Install requred Windows components for WSL 2\" Install debian from WindowsAppStore Open the debian app Give yourself a username and password Close the debian app Open the PowerShell and execute: wsl --list --all Debian should appear as one of the available Linux distributions. In the PowerShell execute: wsl --setdefault Debian Try to start Docker. If it works, continue with the next step. If a message occurs that you are not allowed to use docker because you are not in the docker user group, follow these instructions . In short: Open Computerverwaltung as admin Go to Lokale Benutzer und Gruppen and find docker-users Add your Account (or a group of which you are a member) to the group. Restart your computer In Docker, go to Settings \u2192 General and select autostart for docker (otherwise you have to start it manually each time you want to work with Ikarus). In the Docker settings, select that Docker uses your WSL2 distribution Debian as shown in the picture. In cases docker says that you don't have a WSL 2 distribution, go to the PowerShell and execute wsl --set-default-version 2 #(just to be sure that you didn't forgot this at the beginning) wsl --set-version Debian 2 #(Converts debian to version 2) You should now be able to change the docker settings according to the picture above. Open the PowerShell and execute: docker pull rath3t/ikarus-debian-bookworm:latest Download and install CLion EAP Version . In CLion EAP Version, go to File and Settings and apply the following settings for the toolchain: Edit the Container settings and paste the following command into Run options : -e DISPLAY=:0 -v \\\\wsl$\\debian\\mnt\\wslg\\.X11-unix:/tmp/.X11-unix -v \\\\wsl$\\debian\\mnt\\wslg:/mnt/wslg -p 8000:8000 Clone Ikarus","title":"Installation on Windows using Docker Container"},{"location":"download/#clone-ikarus","text":"Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below","title":"Clone Ikarus"},{"location":"download/#installation-on-windows-using-wsl","text":"This installation procedure is not recommended The installation using Docker described above has several advantages and should be the standard. This section will be removed in the future Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. wsl --install wsl --set-default-version 2 #(Is not needed for Windows 11) Install debian from .tar file OR alternatively (3) wsl --import debian <install location> debian_bookworm.tar Install debian manually Install from WindowsAppStore Open the debian app Give yourself a username and password Execute in debian sudo sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list Execute the following list of commands in debian sudo apt update && \\ sudo apt full-upgrade -y && \\ sudo apt -y install lsb-release && \\ sudo apt -y install build-essential \\ libssl-dev \\ git \\ wget \\ apt-utils \\ software-properties-common \\ gfortran \\ gcc-11 \\ g++-11 \\ gcovr \\ clang \\ libmetis-dev \\ clang-tidy \\ libclang-13-dev \\ clang-format-13 \\ libc++-13-dev \\ libc++abi-13-dev \\ llvm-13-dev \\ liblapack-dev \\ libopenblas-dev \\ libsuitesparse-dev \\ libdune-common-dev \\ libdune-geometry-dev \\ libdune-grid-dev \\ libdune-functions-dev \\ libdune-typetree-dev \\ libdune-localfunctions-dev \\ libdune-uggrid-dev \\ libdune-grid-glue-dev \\ libdune-istl-dev \\ libspdlog-dev \\ libbenchmark-dev \\ libgtest-dev \\ gnuplot \\ python3 \\ pip \\ clang-format-12 \\ gnuplot-x11 \\ curl \\ cppcheck && \\ sudo apt-get install libayatana-appindicator3-1 -y && \\ sudo apt-get -y -f install && \\ sudo apt install libasound2 xvfb -y && \\ wget https://github.com/jgraph/drawio-desktop/releases/download/v16.5.1/drawio-amd64-16.5.1.deb && \\ sudo dpkg -i drawio-amd64-16.5.1.deb && \\ pip install cmakelang == 0 .6.13 pyyaml && \\ pip install mkdocs && \\ pip install mkdocs-material && \\ pip install mkdocs-macros-plugin && \\ pip install mkdocs-drawio-exporter && \\ && \\ sudo cp /usr/bin/clang-format-12 /usr/bin/clang-format && \\ cd /usr/local/bin && \\ sudo ln -s $HOME /.local/bin/cmake-format cmake-format && \\ sudo ln -s $HOME /.local/bin/mkdocs mkdocs && \\ cd ~ && \\ mkdir -p iwyu && \\ cd iwyu && \\ git clone https://github.com/include-what-you-use/include-what-you-use.git && \\ cd include-what-you-use && \\ git checkout clang_13 && \\ cd .. && \\ mkdir -p build && cd build && \\ cmake -G \"Unix Makefiles\" -DIWYU_LLVM_ROOT_PATH = /usr/lib/llvm-13 ../include-what-you-use && \\ make && \\ sudo make install && \\ cd /usr/src/googletest && \\ cmake . && \\ sudo cmake --build . --target install && \\ cd ~ && \\ git clone https://gitlab.com/libeigen/eigen.git && \\ cd eigen && \\ git checkout 3 .4 && \\ mkdir build && \\ cd build && \\ cmake ../ && \\ sudo make install && \\ cd ~ && \\ rm -rf eigen && \\ git clone https://github.com/alandefreitas/matplotplusplus.git && \\ cd matplotplusplus && \\ mkdir -p build && \\ cd build && \\ cmake .. -DCMAKE_BUILD_TYPE = Release -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF && \\ cmake --build . --parallel 4 --config Release && \\ sudo cmake --install . && \\ cd ~ && \\ rm -rf matplotplusplus && \\ git clone https://github.com/autodiff/autodiff && \\ cd autodiff/ && \\ mkdir .build && \\ cd .build/ && \\ cmake .. -DAUTODIFF_BUILD_PYTHON = 0 -DAUTODIFF_BUILD_EXAMPLES = 0 -DAUTODIFF_BUILD_DOCS = 0 -DAUTODIFF_BUILD_TESTS = 0 && \\ sudo cmake --build . --target install && \\ cd ../.. && \\ mkdir -p dune && \\ cd dune && \\ git clone https://gitlab.dune-project.org/extensions/dune-alugrid.git && \\ git clone https://gitlab.dune-project.org/extensions/dune-foamgrid.git && \\ dunecontrol git checkout releases/2.8 && \\ git clone https://github.com/rath3t/dune-iga.git && \\ dunecontrol cmake \"-DCMAKE_BUILD_TYPE=Release\" && \\ dunecontrol make && \\ sudo dunecontrol make install && \\ cd .. && \\ rm -rf dune && \\ sudo apt-get auto-remove -y && \\ sudo apt-get clean wget https://raw.githubusercontent.com/JetBrains/clion-wsl/master/ubuntu_setup_env.sh && bash ubuntu_setup_env.sh In Clion, go to File and Settings and apply the following settings for the toolchain: Build, Execution, Deployment \u2192 Toolchains: Add with the + -sign a WSL configuration Make sure it is used as defaultm i.e. it has to be the first item in the list. Move it up with the arrow buttons otherwise.","title":"Installation on Windows using WSL"},{"location":"howtocontribute/","text":"How to contribute \u00b6 Thanks for your interest in contributing to this code base. If your are interested the following task are vacant. Local functions \u00b6 Implementing a unit normal field function 1 and its derivatives w.r.t. its coefficients \\( \\boldsymbol{x}_i \\) \\[ \\boldsymbol{n} = \\frac{\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2}{||\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2||}, \\quad \\text{with } \\boldsymbol{a}_{\\alpha} = \\sum_{i=1}^n N^i_{,\\alpha}(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\] To implement these see link . Support second derivatives Add \\( \\operatorname{div} \\) and \\( \\operatorname{curl} \\) wrapper Controlroutines \u00b6 Arclength method Dynamics (Explicit/ implicit time stepping) Controlroutines addons \u00b6 Extended systems Finite element helper \u00b6 Implement default implemented mass matrix Finite elements \u00b6 Nonlinear Reissner-Mindlin shell 2 Kirchhoff-Love shell 3D-Beam Implement forces and stiffness matrix of NonLinearElasticityFE Local Basis \u00b6 Support second derivatives Addons \u00b6 Add Python binding pybind11 Add Muesli Code style \u00b6 The directories and filenames use camelCase The source files have a cpp extension and the header files hh . Every public member function or free function needs a brief description /* */ We also use a clang-format file which needs to be executed in each file before a PR can be merged For comments in the code we follow: !!! note \"Quote of Robert Martin in VideoLink \" The proper use of comments is: To compensate for our failure to express ourselves in code This is usually needed for a Kirchhoff-Love shell implementation, see 3 . \u21a9 Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering , pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7 . \u21a9 J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering , 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013 . \u21a9","title":"How to contribute"},{"location":"howtocontribute/#how-to-contribute","text":"Thanks for your interest in contributing to this code base. If your are interested the following task are vacant.","title":"How to contribute"},{"location":"howtocontribute/#local-functions","text":"Implementing a unit normal field function 1 and its derivatives w.r.t. its coefficients \\( \\boldsymbol{x}_i \\) \\[ \\boldsymbol{n} = \\frac{\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2}{||\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2||}, \\quad \\text{with } \\boldsymbol{a}_{\\alpha} = \\sum_{i=1}^n N^i_{,\\alpha}(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\] To implement these see link . Support second derivatives Add \\( \\operatorname{div} \\) and \\( \\operatorname{curl} \\) wrapper","title":"Local functions"},{"location":"howtocontribute/#controlroutines","text":"Arclength method Dynamics (Explicit/ implicit time stepping)","title":"Controlroutines"},{"location":"howtocontribute/#controlroutines-addons","text":"Extended systems","title":"Controlroutines addons"},{"location":"howtocontribute/#finite-element-helper","text":"Implement default implemented mass matrix","title":"Finite element helper"},{"location":"howtocontribute/#finite-elements","text":"Nonlinear Reissner-Mindlin shell 2 Kirchhoff-Love shell 3D-Beam Implement forces and stiffness matrix of NonLinearElasticityFE","title":"Finite elements"},{"location":"howtocontribute/#local-basis","text":"Support second derivatives","title":"Local Basis"},{"location":"howtocontribute/#addons","text":"Add Python binding pybind11 Add Muesli","title":"Addons"},{"location":"howtocontribute/#code-style","text":"The directories and filenames use camelCase The source files have a cpp extension and the header files hh . Every public member function or free function needs a brief description /* */ We also use a clang-format file which needs to be executed in each file before a PR can be merged For comments in the code we follow: !!! note \"Quote of Robert Martin in VideoLink \" The proper use of comments is: To compensate for our failure to express ourselves in code This is usually needed for a Kirchhoff-Love shell implementation, see 3 . \u21a9 Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering , pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7 . \u21a9 J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering , 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013 . \u21a9","title":"Code style"},{"location":"01_theory/Assembler/","text":"Assembler \u00b6 The purpose of an assembler is to assemble global quantities (global stiffness matrix, global force vector, global energy, ...) by looping over finite elements and composing the corresponding local structures to a global structure. This page describes the available assemblers and how they can be used. Each of the assemblers is constructed as follows: AssemblerName ( const Basis & basis , const FEContainer & fes , const std :: vector < bool >& dirichFlags ) basis is the basis that was used to construct the finite elements. ToDo add comment about FLAT. fes is a container that contains all the finite elements that should be assembled dirichFlags is of type std :: vector < bool > . dirichFlags [ i ] = true means that degree of freedom i is fixed. The corresponding row / column / entry will be eliminated when you ask for reduced matrix / vector. SparseFlatAssembler \u00b6 The SparseFlatAssembler has to public member functions: Eigen :: SparseMatrix < double >& getMatrix ( const RequirementType & fErequirements ) It assembles the reqested matrix and returns a sparse matrix. A call to this function could look as follows: SparseFlatAssembler myAssembler (...) // (1) // other code const auto & K = myAssembler . getMatrix ( stiffness ) // (2) This line represents the construction of the SparseFlatAssembler as explained above. To learn what alternatives for stiffness are available and how this works, read the available requirements section below. Eigen :: SparseMatrix < double >& getReducedMatrix ( const RequirementType & fErequirements ) returns the reduced matrix, i.e. the rows and columns which are flagged with 1 in dirichFlags are eliminated. VectorFlatAssembler \u00b6 It offers the functions Eigen :: VectorXd & getVector ( const RequirementType & fErequirements ) Eigen :: VectorXd & getReducedVector ( const RequirementType & fErequirements ) They work the same way as the matrix assembling functions of SparseFlatAssembler . The available requirements are explained in the available requirements section below. ScalarAssembler \u00b6 It offers only one function double & getScalar ( const RequirementType & fErequirements ) This assembler can be used when you are only interested in a scalar quantity and assembling of matrices or vectors is not relevant for you. The available requirements are explained in the available requirements section below. dirichletFlags is not used in this assembler. DenseFlatSimpleAssembler \u00b6 It offers the functions Eigen :: MatrixXd & getMatrix ( const Ikarus :: MatrixAffordances & p_matrixAffordances , const Eigen :: VectorXd & displacement , const double & lambda ) Eigen :: VectorXd & getVector ( const Ikarus :: VectorAffordances & p_vectorAffordances , const Eigen :: VectorXd & displacement , const double & lambda ) double getScalar ( const Ikarus :: ScalarAffordances & p_scalarAffordances , const Eigen :: VectorXd & displacement , const double & lambda ) This assembler should be used when your assembling process requires displacement, e.g. if you are using nonlinear load control. The result are dense matrices. p_matrixAffordances describes what matrix you want to assemble, see the available requirements section . displacement is the global displacement vector of the state that you want to assemble lambda is the load factor you want to use DenseFlatAssembler \u00b6 It offers the functions Eigen :: MatrixXd & getMatrix ( const RequirementType & fErequirements ) Eigen :: MatrixXd & getReducedMatrix ( const RequirementType & fErequirements ) Eigen :: VectorXd & getVector ( const RequirementType & fErequirements ) Eigen :: VectorXd & getReducedVector ( const RequirementType & fErequirements ) double getScalar ( const RequirementType & fErequirements ) auto createFullVector ( const Eigen :: VectorXd & reducedVector ) One function is only available in this assembler and was therefore not yet discussed: createFullVector . You can used it to expand a vector of reduced size (e.g from solving the linear system) to a vector of full size where entries corresponding to the fixed degrees of freedom are set to zero. Available requirements \u00b6","title":"Assembler"},{"location":"01_theory/Assembler/#assembler","text":"The purpose of an assembler is to assemble global quantities (global stiffness matrix, global force vector, global energy, ...) by looping over finite elements and composing the corresponding local structures to a global structure. This page describes the available assemblers and how they can be used. Each of the assemblers is constructed as follows: AssemblerName ( const Basis & basis , const FEContainer & fes , const std :: vector < bool >& dirichFlags ) basis is the basis that was used to construct the finite elements. ToDo add comment about FLAT. fes is a container that contains all the finite elements that should be assembled dirichFlags is of type std :: vector < bool > . dirichFlags [ i ] = true means that degree of freedom i is fixed. The corresponding row / column / entry will be eliminated when you ask for reduced matrix / vector.","title":"Assembler"},{"location":"01_theory/Assembler/#sparseflatassembler","text":"The SparseFlatAssembler has to public member functions: Eigen :: SparseMatrix < double >& getMatrix ( const RequirementType & fErequirements ) It assembles the reqested matrix and returns a sparse matrix. A call to this function could look as follows: SparseFlatAssembler myAssembler (...) // (1) // other code const auto & K = myAssembler . getMatrix ( stiffness ) // (2) This line represents the construction of the SparseFlatAssembler as explained above. To learn what alternatives for stiffness are available and how this works, read the available requirements section below. Eigen :: SparseMatrix < double >& getReducedMatrix ( const RequirementType & fErequirements ) returns the reduced matrix, i.e. the rows and columns which are flagged with 1 in dirichFlags are eliminated.","title":"SparseFlatAssembler"},{"location":"01_theory/Assembler/#vectorflatassembler","text":"It offers the functions Eigen :: VectorXd & getVector ( const RequirementType & fErequirements ) Eigen :: VectorXd & getReducedVector ( const RequirementType & fErequirements ) They work the same way as the matrix assembling functions of SparseFlatAssembler . The available requirements are explained in the available requirements section below.","title":"VectorFlatAssembler"},{"location":"01_theory/Assembler/#scalarassembler","text":"It offers only one function double & getScalar ( const RequirementType & fErequirements ) This assembler can be used when you are only interested in a scalar quantity and assembling of matrices or vectors is not relevant for you. The available requirements are explained in the available requirements section below. dirichletFlags is not used in this assembler.","title":"ScalarAssembler"},{"location":"01_theory/Assembler/#denseflatsimpleassembler","text":"It offers the functions Eigen :: MatrixXd & getMatrix ( const Ikarus :: MatrixAffordances & p_matrixAffordances , const Eigen :: VectorXd & displacement , const double & lambda ) Eigen :: VectorXd & getVector ( const Ikarus :: VectorAffordances & p_vectorAffordances , const Eigen :: VectorXd & displacement , const double & lambda ) double getScalar ( const Ikarus :: ScalarAffordances & p_scalarAffordances , const Eigen :: VectorXd & displacement , const double & lambda ) This assembler should be used when your assembling process requires displacement, e.g. if you are using nonlinear load control. The result are dense matrices. p_matrixAffordances describes what matrix you want to assemble, see the available requirements section . displacement is the global displacement vector of the state that you want to assemble lambda is the load factor you want to use","title":"DenseFlatSimpleAssembler"},{"location":"01_theory/Assembler/#denseflatassembler","text":"It offers the functions Eigen :: MatrixXd & getMatrix ( const RequirementType & fErequirements ) Eigen :: MatrixXd & getReducedMatrix ( const RequirementType & fErequirements ) Eigen :: VectorXd & getVector ( const RequirementType & fErequirements ) Eigen :: VectorXd & getReducedVector ( const RequirementType & fErequirements ) double getScalar ( const RequirementType & fErequirements ) auto createFullVector ( const Eigen :: VectorXd & reducedVector ) One function is only available in this assembler and was therefore not yet discussed: createFullVector . You can used it to expand a vector of reduced size (e.g from solving the linear system) to a vector of full size where entries corresponding to the fixed degrees of freedom are set to zero.","title":"DenseFlatAssembler"},{"location":"01_theory/Assembler/#available-requirements","text":"","title":"Available requirements"},{"location":"01_theory/ControlRoutines/","text":"Control routines \u00b6","title":"Control routines"},{"location":"01_theory/ControlRoutines/#control-routines","text":"","title":"Control routines"},{"location":"01_theory/FiniteElements/","text":"Finite elements \u00b6 Several disciplines associate to finite elements different meanings. In Ikarus finite elements have two different tasks. The first one is to provide the evaluation of scalars, vectors and matrices. These are associated to an algebraic representation of discrete energies, weak forms or bilinear forms These algebraic objects are usually constructed using some combination of local function and parameters steeming from the underlying physical problem, e.g. load factor, Young's modulus or viscocity. The second task of finite elements is to evaluate derived results in the element parameter space. E.g. stresses or geometric quantities. This boils down to the following interface. Interface \u00b6 Local functions provide the following interface void evaluateScalar ( const DomainType & local ); void evaluateVector ( const unsigned int & integrationPointIndex ); void evaluateMatrix ( const DomainType & local ,...); void globalIndices ( const unsigned int & integrationPointIndex ,...); auto calculateAt ();","title":"Finite Elements"},{"location":"01_theory/FiniteElements/#finite-elements","text":"Several disciplines associate to finite elements different meanings. In Ikarus finite elements have two different tasks. The first one is to provide the evaluation of scalars, vectors and matrices. These are associated to an algebraic representation of discrete energies, weak forms or bilinear forms These algebraic objects are usually constructed using some combination of local function and parameters steeming from the underlying physical problem, e.g. load factor, Young's modulus or viscocity. The second task of finite elements is to evaluate derived results in the element parameter space. E.g. stresses or geometric quantities. This boils down to the following interface.","title":"Finite elements"},{"location":"01_theory/FiniteElements/#interface","text":"Local functions provide the following interface void evaluateScalar ( const DomainType & local ); void evaluateVector ( const unsigned int & integrationPointIndex ); void evaluateMatrix ( const DomainType & local ,...); void globalIndices ( const unsigned int & integrationPointIndex ,...); auto calculateAt ();","title":"Interface"},{"location":"01_theory/LocalBasis/","text":"Local Basis \u00b6 Each finite element does have some kind of local basis in terms of ansatz functions. These ansatz function need to be evaluated at the parameter domain of the finite element. Interface \u00b6 Local basis provide the following interface LocalBasis ( const DuneLocalBasis & p_basis ) // Constructor (1) void evaluateFunction ( const DomainType & local , Eigen :: VectorX < RangeFieldType >& N ); void evaluateJacobian ( const DomainType & local , Eigen :: Matrix < RangeFieldType , Eigen :: Dynamic , gridDim >& dN ); void evaluateFunctionAndJacobian ( const DomainType & local , Eigen :: VectorX < RangeFieldType >& N , Eigen :: Matrix < RangeFieldType , Eigen :: Dynamic , gridDim >& dN ); const Eigen :: VectorX < RangeFieldType >& evaluateFunction ( const unsigned int & integrationPointIndex ); const Eigen :: Matrix < RangeFieldType , Eigen :: Dynamic , gridDim >& evaluateJacobian ( const unsigned int & integrationPointIndex ); auto viewOverIntegrationPoints (); // (2) template < typename IntegrationRule , typename ... Ints > void bind ( IntegrationRule && p_rule , Derivatives < Ints ... >&& ints ); Using the concept Concepts::DuneLocalBasis the constructor only accepts local basis that satisfies this concept. This also allows a local basis which behave lik a local basis of dune in the spirit of duck-typing. This return a vector of structs of the integration point and its index. Therefore the syntax is usually for ( const auto & [ gpIndex , gp ] : localFunction . viewOverIntegrationPoints ()) {...} The first two function calls of evaluateFunction and evaluateJacobian can be used to calculate the function values \\( N(\\boldsymbol{\\xi}) \\) and the spatial derivatives \\( N_{,\\boldsymbol{\\xi}}(\\boldsymbol{\\xi}) \\) . The objects where this is stored you have to allocate yourself and have to pass as mutable reference. In contrast to this there exists two other methods that receive an integration point index. These methods return a const reference to the evaluated ansatz function values and derivatives. This functionality depends on an earlier call to bind(...) . This binds the local basis to one quadrature rule and caches the passed bindDerivatives(..) . If one calls evaluateFunction ( const unsigned int & integrationPointIndex ) before bind an error is thrown. Finally, to bind to an integration rule and cache the value and the ansatz function jacobian one would call: Usage with integration point index using integration point coordinates 1 2 3 4 5 6 7 const auto & rule = Dune :: QuadratureRules < double , Traits :: mydim >:: rule ( localView_ . element (). type (), order ); localBasis . bind ( rule , bindDerivatives ( 0 , 1 )); for ( const auto & [ gpIndex , gp ] : localBasis . viewOverIntegrationPoints ()) { const auto & N = localBasis . evaluateFunction ( gpIndex ); const auto & dN = localBasis . evaluateJacobian ( gpIndex ); } 1 2 3 4 5 6 7 8 9 const auto & rule = Dune :: QuadratureRules < double , Traits :: mydim >:: rule ( localView_ . element (). type (), order ); Eigen :: VectorXd N ; Eigen :: Matrix < double , Eigen :: Dynamic , gridDim > dN ; for ( auto & gp : rule ){ localFunction . evaluateFunction ( gp . position (), N ); localFunction . evaluateJacobian ( gp . position (), dN ); localFunction . evaluateFunctionAndJacobian ( gp . position (), N , dN ); // (1) } Alternative to the two lines above (Line 6 and 7)","title":"Local basis"},{"location":"01_theory/LocalBasis/#local-basis","text":"Each finite element does have some kind of local basis in terms of ansatz functions. These ansatz function need to be evaluated at the parameter domain of the finite element.","title":"Local Basis"},{"location":"01_theory/LocalBasis/#interface","text":"Local basis provide the following interface LocalBasis ( const DuneLocalBasis & p_basis ) // Constructor (1) void evaluateFunction ( const DomainType & local , Eigen :: VectorX < RangeFieldType >& N ); void evaluateJacobian ( const DomainType & local , Eigen :: Matrix < RangeFieldType , Eigen :: Dynamic , gridDim >& dN ); void evaluateFunctionAndJacobian ( const DomainType & local , Eigen :: VectorX < RangeFieldType >& N , Eigen :: Matrix < RangeFieldType , Eigen :: Dynamic , gridDim >& dN ); const Eigen :: VectorX < RangeFieldType >& evaluateFunction ( const unsigned int & integrationPointIndex ); const Eigen :: Matrix < RangeFieldType , Eigen :: Dynamic , gridDim >& evaluateJacobian ( const unsigned int & integrationPointIndex ); auto viewOverIntegrationPoints (); // (2) template < typename IntegrationRule , typename ... Ints > void bind ( IntegrationRule && p_rule , Derivatives < Ints ... >&& ints ); Using the concept Concepts::DuneLocalBasis the constructor only accepts local basis that satisfies this concept. This also allows a local basis which behave lik a local basis of dune in the spirit of duck-typing. This return a vector of structs of the integration point and its index. Therefore the syntax is usually for ( const auto & [ gpIndex , gp ] : localFunction . viewOverIntegrationPoints ()) {...} The first two function calls of evaluateFunction and evaluateJacobian can be used to calculate the function values \\( N(\\boldsymbol{\\xi}) \\) and the spatial derivatives \\( N_{,\\boldsymbol{\\xi}}(\\boldsymbol{\\xi}) \\) . The objects where this is stored you have to allocate yourself and have to pass as mutable reference. In contrast to this there exists two other methods that receive an integration point index. These methods return a const reference to the evaluated ansatz function values and derivatives. This functionality depends on an earlier call to bind(...) . This binds the local basis to one quadrature rule and caches the passed bindDerivatives(..) . If one calls evaluateFunction ( const unsigned int & integrationPointIndex ) before bind an error is thrown. Finally, to bind to an integration rule and cache the value and the ansatz function jacobian one would call: Usage with integration point index using integration point coordinates 1 2 3 4 5 6 7 const auto & rule = Dune :: QuadratureRules < double , Traits :: mydim >:: rule ( localView_ . element (). type (), order ); localBasis . bind ( rule , bindDerivatives ( 0 , 1 )); for ( const auto & [ gpIndex , gp ] : localBasis . viewOverIntegrationPoints ()) { const auto & N = localBasis . evaluateFunction ( gpIndex ); const auto & dN = localBasis . evaluateJacobian ( gpIndex ); } 1 2 3 4 5 6 7 8 9 const auto & rule = Dune :: QuadratureRules < double , Traits :: mydim >:: rule ( localView_ . element (). type (), order ); Eigen :: VectorXd N ; Eigen :: Matrix < double , Eigen :: Dynamic , gridDim > dN ; for ( auto & gp : rule ){ localFunction . evaluateFunction ( gp . position (), N ); localFunction . evaluateJacobian ( gp . position (), dN ); localFunction . evaluateFunctionAndJacobian ( gp . position (), N , dN ); // (1) } Alternative to the two lines above (Line 6 and 7)","title":"Interface"},{"location":"01_theory/LocalFunctions/","text":"Local functions \u00b6 This section explains the concept of local functions. Local functions are functions which are bound to single grid elements. Therefore they are constructed from some local basis and a coefficient vector. Usually local functions need to be evaluated in the local coordinate system \\( \\mathbb{\\xi} \\in T_{\\text{ref}} \\subset\\mathbb{R}^n \\) : \\[ f: \\boldsymbol{\\xi}^n \\rightarrow \\mathbb{R}^m \\] where \\(T_{\\text{ref}}\\) is the reference element, e.g. for a cube \\(T_{\\text{ref}}= [0,1]^d\\) . Interface \u00b6 Local functions provide the following interface FunctionReturnType evaluateFunction ( const DomainType & local ); FunctionReturnType evaluateFunction ( const unsigned int & integrationPointIndex ); auto evaluateDerivative ( const DomainType & local ,...); auto evaluateDerivative ( const unsigned int & integrationPointIndex ,...); auto viewOverIntegrationPoints (); // (1) template < typename IntegrationRule , typename ... Ints > void bind ( IntegrationRule && p_rule , Derivatives < Ints ... >&& ints ); // (2) This returns a vector of structs of the integration point and its index. Therefore the syntax is usually for ( const auto & [ gpIndex , gp ] : localFunction . viewOverIntegrationPoints ()) {...} This function is passed through to the given localBasis . See Link The \"...\" in the evaluateDerivative function call are several variadic templates. In action this looks like Usage with integration point index using integration point coordinates using namespace Ikarus :: DerivativeDirections ; localFunction . bind ( rule , bindDerivatives ( 0 , 1 )); for ( auto & [ gpIndex , gp ] : localFunction . viewOverIntegrationPoints ()){ localFunction . evaluateDerivative ( gpIndex , wrt ( spatialall )); // (1) localFunction . evaluateDerivative ( gpIndex , wrt ( spatialall ), transformWith ( Jinv )); // (2) } Compute the spatial Jacobian of localFunction Compute the spatial Jacobian of localFunction and transform it to physical coordinates using namespace Ikarus :: DerivativeDirections ; for ( auto & gp : rule ){ localFunction . evaluateDerivative ( gp . position (), wrt ( spatialall )); // (1) localFunction . evaluateDerivative ( gp . position (), wrt ( spatialall ), transformWith ( Jinv )); // (2) } Compute the spatial Jacobian of localFunction Compute the spatial Jacobian of localFunction and transform it to physical coordinates where the first call implements \\[ \\operatorname{grad}_\\boldsymbol{\\xi} f : \\boldsymbol{\\xi} \\rightarrow \\mathbb{R}^{m \\times d}. \\] The second one respect the fact that the local function in reality is defined in some physical space \\(X\\) with the coordinate \\(\\boldsymbol{x}\\) . Therefore, it transforms the Jacobian from the reference element \\(\\operatorname{grad}_{\\boldsymbol{\\xi}}\\) to the Jacobian in physical space \\(\\operatorname{grad}_\\boldsymbol{x}\\) . E.g. it usually implements \\[ \\operatorname{grad}_\\boldsymbol{x} = \\operatorname{grad}_{\\boldsymbol{\\xi}} \\boldsymbol{J}^{-1} \\] where \\(J\\) is the Jacobian of the mapping from the reference element \\(T_{\\text{ref}}\\) to the element living in physical space \\(T\\) . For details see 1 page 22. Instead of passing spatialall to wrt(..) , there are other helper such as localFunction . evaluateDerivative ( gpIndex , wrt ( spatial ( 0 ))); // (1) localFunction . evaluateDerivative ( gpIndex , wrt ( spatial ( 1 ))); // (2) Compute the first column of the spatial Jacobian of localFunction Compute the second column of the spatial Jacobian of localFunction which can also be combined with transformWith(Jinv) . Derivatives w.r.t. coefficients \u00b6 localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs ), coeffIndices ( j )); which implements for simple interpolation in vector space valued functions,e.g. \\(f(\\boldsymbol{\\xi}) = \\sum_{I=1}^n N^I(\\boldsymbol{\\xi}) \\boldsymbol{x}_I\\) the following \\[ [\\boldsymbol{A}]_{ij} = A_{ij} = \\frac{\\partial f_i(\\boldsymbol{\\xi})}{\\partial \\boldsymbol{x}_j} \\] and the second derivative localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs ), along ( q ), coeffIndices ( j , k )); \\[ [\\boldsymbol{B}]_{jk} = B_{jk} = q_i A_{ijk} = \\frac{\\partial^2 (q_i f_i(\\boldsymbol{\\xi}))}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k} \\] where \\(\\boldsymbol{q}\\) is an arbitrary vector of the same size as \\(f\\) , i.e. it is the direction of the derivative in this case. $ \\boldsymbol{A} $ and $ \\boldsymbol{B} $ is simply the returned matrix and they do not have a special meaning. If we would not pass the vector the result would be a third order tensor for a vector valued function \\(f\\) . Therefore the simply return a matrix. This helps for readablilty and for speed. See the example for details. Derivatives w.r.t. coefficients and spatial derivatives \u00b6 Spatial derivatives and derivatives w.r.t. the coefficients can be combined. Therefore, it is legal to call auto B = localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatialall ), along ( q ), coeffIndices ( j , k )); auto B0 = localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatial ( 0 )), along ( q ), coeffIndices ( j , k )); auto B1 = localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatial ( 1 )), along ( q ), coeffIndices ( j , k )); The first line is then equivalent to \\[ [\\boldsymbol{B}]_{ljk} = B_{ljk} = q_i A_{iljk} = \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{\\xi} f(\\boldsymbol{\\xi})]_{il} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] this returns an object where the first index contains the spatial derivative w.r.t. \\(\\xi_0\\) . Thus we have \\[\\begin{align} \\boldsymbol{B}[0]_{jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^0} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}, \\\\ \\boldsymbol{B}[1]_{jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^1} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\end{align}\\] These objects are also returned when the second and third line above are used. Again all of these function calls can be combined with transformWith() as localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatialall ), along ( q ), transformWith ( Jinv ), coeffIndices ( j , k )); which computes \\[ \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{x} f(\\boldsymbol{\\xi})]_{il} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] Warning Currently only first order spatial derivatives and second order derivatives w.r.t. the coefficients are supported. Example Dirichlet energy \u00b6 This examples shows how the energy, gradient and Hessian of a dirichlet energy can be calculated. $$ E(\\boldsymbol{u}) = \\frac{1}{2} \\int_\\Omega ||\\operatorname{grad}_\\boldsymbol{x} \\boldsymbol{u}(\\boldsymbol{x})|| ^2 \\textrm{d} \\boldsymbol{x} $$ If we want to mimize this energy w.r.t. the coefficients of the nodes, we need to calculate the energy, gradient and the Hessia w.r.t. the coefficents. Of course this depends on the optimization algorithms, but for now lets keep it simple. auto dirichletEnergy () { double energy = 0 ; //... bind localBasis to some integration rule // and create uNodalCoeffs Ikarus :: StandardLocalFunction uFunction ( localBasis , uNodalCoeffs ); for ( const auto & [ gpIndex , gp ] : uFunction . viewOverIntegrationPoints ()) { //.. calculate the inverse Jacobian of the geometry const auto gradu = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall ), transformWith ( Jinv )); energy += 0.5 * ( gradu . transpose () * gradu ). trace () * ( \"weight from integration point and geo.integrationElement\" ); } } auto gradientDirichletEnergy ( Eigen :: VectorXd & g ) { //... bind localBasis to some integration rule // and create uNodalCoeffs constexpr int size = // spatial size of u Ikarus :: StandardLocalFunction uFunction ( localBasis , uNodalCoeffs ); for ( const auto & [ gpIndex , gp ] : uFunction . viewOverIntegrationPoints ()) { //.. calculate the inverse Jacobian of the geometry const auto gradu = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall ), transformWith ( Jinv )); for ( auto i : fe . size ()) { //loop over coeffs, i.e.nodes of the finite element const auto graduDCoeffs = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall , coeffs ), transformWith ( Jinv ), coeffIndices ( i )); Eigen :: Vector < double , size > tmp ; tmp . setZero (); for ( int k = 0 ; k < gridDimension ; ++ k ) tmp += graduDCoeffs [ k ] * gradu . col ( k ); // (1) g . segment < size > ( i * size ) += tmp * ( \"weight from integration point and geo.integrationElement\" ); } } } graduDCoeffs contains in graduDCoeffs[0] the derivatives w.r.t.the coefficient of the first column and at [1] w.r.t.the second colum of gradu auto hessianDirichletEnergy ( Matrix & h ) { //... bind localBasis to some integration rule // and create uNodalCoeffs constexpr int size = // spatial size of u Ikarus :: StandardLocalFunction uFunction ( localBasis , uNodalCoeffs ); for ( const auto & [ gpIndex , gp ] : uFunction . viewOverIntegrationPoints ()) { //.. calculate the inverse Jacobian of the geometry for ( auto i : loop over coeffs , i . e . nodes of the finite element ) { const auto graduDCoeffsI = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall , coeffs ), transformWith ( Jinv ), coeffIndices ( i )); for ( auto j : fe . size ()) { //loop over coeffs, i.e.nodes of the finite element const auto graduDCoeffsJ = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall , coeffs ), transformWith ( Jinv ), coeffIndices ( j )); Eigen :: Matrix < double , size , size > tmp ; tmp . setZero (); for ( int k = 0 ; k < gridDimension ; ++ k ) tmp += graduDCoeffsI [ k ] * graduDCoeffsJ [ k ]; h . block < size , size > ( i * size , j * size ) += tmp * ( \"weight from integration point and geo.integrationElement\" ); } } } } Implementations \u00b6 In the following we summarize the local functions that are currently available. In the follwing table \\(N^i(\\boldsymbol{\\xi})\\) are the ansatz functions. Name Interpolation formula Note Header Standard $$ \\boldsymbol{x} = \\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i $$ standardLocalFunction.hh Projection-Based 2 $$ \\boldsymbol{x} = P\\left(\\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\right) $$ This is one version of geometric finite elements. These are finite elements suited for interpolation on manifolds. Here \\(P: \\mathbb{R}^m \\rightarrow \\mathcal{M}\\) is an operator that projects the usual linear interpolation onto some manifold projectionBasedLocalFunction.hh How to implement your own local functions \u00b6 If you are interested in implementing your own local function we have prepared the file ikarus/LocalFunctions/LocalFunctionTemplate.h . You can copy the file rename the class to your preferred name and then implement the following functions. If you don't need a function you need to delete the corresponding function. Then if someone calls the corresponding derivative the call fails at compile time. FunctionReturnType evaluateEmbeddingFunctionImpl ( const Eigen :: VectorXd & N ) const { return FunctionReturnType {}; } // (0) Jacobian evaluateDerivativeWRTSpaceAllImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN ) const {...} // (1) JacobianColType evaluateDerivativeWRTSpaceSingleImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , int spaceIndex ) const {...} // (2) CoeffDerivMatrix evaluateDerivativeWRTCoeffsImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , int coeffsIndex ) const {...} // (3) CoeffDerivMatrix evaluateSecondDerivativeWRTCoeffs ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & , const AlongType & along , const std :: array < size_t , gridDim >& coeffsIndex ) const {...} // (4) std :: array < CoeffDerivMatrix , gridDim > evaluateDerivativeWRTCoeffsANDSpatialImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , int coeffsIndex ) const {...} // (5) CoeffDerivMatrix evaluateDerivativeWRTCoeffsANDSpatialSingleImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , const int coeffsIndex , const int spatialIndex ) const {...} // (6) std :: array < CoeffDerivMatrix , gridDim > evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , const AlongType & along , const std :: array < size_t , gridDim >& coeffsIndex ) const {...} // (7) CoeffDerivMatrix evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialSingleImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , const AlongType & along , const std :: array < size_t , gridDim >& coeffsIndex , c const int spatialIndex ) const {...} // (8) This is called by localFunction.evaluateFunction(...) . This is called by localFunction.evaluateDerivative(..., wrt(spatialall)) . This is called by localFunction.evaluateDerivative(..., wrt(spatial(i))) . This is called by localFunction.evaluateDerivative(..., wrt(coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(coeff,coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatialall,coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatial(i),coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatialall,coeff,coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatial(i),coeff,coeff)) . Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9 Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal , 57(1):404\u2013428, 2019. doi:10.1137/18M1176798 . \u21a9","title":"Local functions"},{"location":"01_theory/LocalFunctions/#local-functions","text":"This section explains the concept of local functions. Local functions are functions which are bound to single grid elements. Therefore they are constructed from some local basis and a coefficient vector. Usually local functions need to be evaluated in the local coordinate system \\( \\mathbb{\\xi} \\in T_{\\text{ref}} \\subset\\mathbb{R}^n \\) : \\[ f: \\boldsymbol{\\xi}^n \\rightarrow \\mathbb{R}^m \\] where \\(T_{\\text{ref}}\\) is the reference element, e.g. for a cube \\(T_{\\text{ref}}= [0,1]^d\\) .","title":"Local functions"},{"location":"01_theory/LocalFunctions/#interface","text":"Local functions provide the following interface FunctionReturnType evaluateFunction ( const DomainType & local ); FunctionReturnType evaluateFunction ( const unsigned int & integrationPointIndex ); auto evaluateDerivative ( const DomainType & local ,...); auto evaluateDerivative ( const unsigned int & integrationPointIndex ,...); auto viewOverIntegrationPoints (); // (1) template < typename IntegrationRule , typename ... Ints > void bind ( IntegrationRule && p_rule , Derivatives < Ints ... >&& ints ); // (2) This returns a vector of structs of the integration point and its index. Therefore the syntax is usually for ( const auto & [ gpIndex , gp ] : localFunction . viewOverIntegrationPoints ()) {...} This function is passed through to the given localBasis . See Link The \"...\" in the evaluateDerivative function call are several variadic templates. In action this looks like Usage with integration point index using integration point coordinates using namespace Ikarus :: DerivativeDirections ; localFunction . bind ( rule , bindDerivatives ( 0 , 1 )); for ( auto & [ gpIndex , gp ] : localFunction . viewOverIntegrationPoints ()){ localFunction . evaluateDerivative ( gpIndex , wrt ( spatialall )); // (1) localFunction . evaluateDerivative ( gpIndex , wrt ( spatialall ), transformWith ( Jinv )); // (2) } Compute the spatial Jacobian of localFunction Compute the spatial Jacobian of localFunction and transform it to physical coordinates using namespace Ikarus :: DerivativeDirections ; for ( auto & gp : rule ){ localFunction . evaluateDerivative ( gp . position (), wrt ( spatialall )); // (1) localFunction . evaluateDerivative ( gp . position (), wrt ( spatialall ), transformWith ( Jinv )); // (2) } Compute the spatial Jacobian of localFunction Compute the spatial Jacobian of localFunction and transform it to physical coordinates where the first call implements \\[ \\operatorname{grad}_\\boldsymbol{\\xi} f : \\boldsymbol{\\xi} \\rightarrow \\mathbb{R}^{m \\times d}. \\] The second one respect the fact that the local function in reality is defined in some physical space \\(X\\) with the coordinate \\(\\boldsymbol{x}\\) . Therefore, it transforms the Jacobian from the reference element \\(\\operatorname{grad}_{\\boldsymbol{\\xi}}\\) to the Jacobian in physical space \\(\\operatorname{grad}_\\boldsymbol{x}\\) . E.g. it usually implements \\[ \\operatorname{grad}_\\boldsymbol{x} = \\operatorname{grad}_{\\boldsymbol{\\xi}} \\boldsymbol{J}^{-1} \\] where \\(J\\) is the Jacobian of the mapping from the reference element \\(T_{\\text{ref}}\\) to the element living in physical space \\(T\\) . For details see 1 page 22. Instead of passing spatialall to wrt(..) , there are other helper such as localFunction . evaluateDerivative ( gpIndex , wrt ( spatial ( 0 ))); // (1) localFunction . evaluateDerivative ( gpIndex , wrt ( spatial ( 1 ))); // (2) Compute the first column of the spatial Jacobian of localFunction Compute the second column of the spatial Jacobian of localFunction which can also be combined with transformWith(Jinv) .","title":"Interface"},{"location":"01_theory/LocalFunctions/#derivatives-wrt-coefficients","text":"localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs ), coeffIndices ( j )); which implements for simple interpolation in vector space valued functions,e.g. \\(f(\\boldsymbol{\\xi}) = \\sum_{I=1}^n N^I(\\boldsymbol{\\xi}) \\boldsymbol{x}_I\\) the following \\[ [\\boldsymbol{A}]_{ij} = A_{ij} = \\frac{\\partial f_i(\\boldsymbol{\\xi})}{\\partial \\boldsymbol{x}_j} \\] and the second derivative localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs ), along ( q ), coeffIndices ( j , k )); \\[ [\\boldsymbol{B}]_{jk} = B_{jk} = q_i A_{ijk} = \\frac{\\partial^2 (q_i f_i(\\boldsymbol{\\xi}))}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k} \\] where \\(\\boldsymbol{q}\\) is an arbitrary vector of the same size as \\(f\\) , i.e. it is the direction of the derivative in this case. $ \\boldsymbol{A} $ and $ \\boldsymbol{B} $ is simply the returned matrix and they do not have a special meaning. If we would not pass the vector the result would be a third order tensor for a vector valued function \\(f\\) . Therefore the simply return a matrix. This helps for readablilty and for speed. See the example for details.","title":"Derivatives w.r.t. coefficients"},{"location":"01_theory/LocalFunctions/#derivatives-wrt-coefficients-and-spatial-derivatives","text":"Spatial derivatives and derivatives w.r.t. the coefficients can be combined. Therefore, it is legal to call auto B = localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatialall ), along ( q ), coeffIndices ( j , k )); auto B0 = localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatial ( 0 )), along ( q ), coeffIndices ( j , k )); auto B1 = localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatial ( 1 )), along ( q ), coeffIndices ( j , k )); The first line is then equivalent to \\[ [\\boldsymbol{B}]_{ljk} = B_{ljk} = q_i A_{iljk} = \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{\\xi} f(\\boldsymbol{\\xi})]_{il} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] this returns an object where the first index contains the spatial derivative w.r.t. \\(\\xi_0\\) . Thus we have \\[\\begin{align} \\boldsymbol{B}[0]_{jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^0} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}, \\\\ \\boldsymbol{B}[1]_{jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^1} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\end{align}\\] These objects are also returned when the second and third line above are used. Again all of these function calls can be combined with transformWith() as localFunction . evaluateDerivative ( gpIndex , wrt ( coeffs , coeffs , spatialall ), along ( q ), transformWith ( Jinv ), coeffIndices ( j , k )); which computes \\[ \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{x} f(\\boldsymbol{\\xi})]_{il} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] Warning Currently only first order spatial derivatives and second order derivatives w.r.t. the coefficients are supported.","title":"Derivatives w.r.t. coefficients and spatial derivatives"},{"location":"01_theory/LocalFunctions/#example-dirichlet-energy","text":"This examples shows how the energy, gradient and Hessian of a dirichlet energy can be calculated. $$ E(\\boldsymbol{u}) = \\frac{1}{2} \\int_\\Omega ||\\operatorname{grad}_\\boldsymbol{x} \\boldsymbol{u}(\\boldsymbol{x})|| ^2 \\textrm{d} \\boldsymbol{x} $$ If we want to mimize this energy w.r.t. the coefficients of the nodes, we need to calculate the energy, gradient and the Hessia w.r.t. the coefficents. Of course this depends on the optimization algorithms, but for now lets keep it simple. auto dirichletEnergy () { double energy = 0 ; //... bind localBasis to some integration rule // and create uNodalCoeffs Ikarus :: StandardLocalFunction uFunction ( localBasis , uNodalCoeffs ); for ( const auto & [ gpIndex , gp ] : uFunction . viewOverIntegrationPoints ()) { //.. calculate the inverse Jacobian of the geometry const auto gradu = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall ), transformWith ( Jinv )); energy += 0.5 * ( gradu . transpose () * gradu ). trace () * ( \"weight from integration point and geo.integrationElement\" ); } } auto gradientDirichletEnergy ( Eigen :: VectorXd & g ) { //... bind localBasis to some integration rule // and create uNodalCoeffs constexpr int size = // spatial size of u Ikarus :: StandardLocalFunction uFunction ( localBasis , uNodalCoeffs ); for ( const auto & [ gpIndex , gp ] : uFunction . viewOverIntegrationPoints ()) { //.. calculate the inverse Jacobian of the geometry const auto gradu = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall ), transformWith ( Jinv )); for ( auto i : fe . size ()) { //loop over coeffs, i.e.nodes of the finite element const auto graduDCoeffs = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall , coeffs ), transformWith ( Jinv ), coeffIndices ( i )); Eigen :: Vector < double , size > tmp ; tmp . setZero (); for ( int k = 0 ; k < gridDimension ; ++ k ) tmp += graduDCoeffs [ k ] * gradu . col ( k ); // (1) g . segment < size > ( i * size ) += tmp * ( \"weight from integration point and geo.integrationElement\" ); } } } graduDCoeffs contains in graduDCoeffs[0] the derivatives w.r.t.the coefficient of the first column and at [1] w.r.t.the second colum of gradu auto hessianDirichletEnergy ( Matrix & h ) { //... bind localBasis to some integration rule // and create uNodalCoeffs constexpr int size = // spatial size of u Ikarus :: StandardLocalFunction uFunction ( localBasis , uNodalCoeffs ); for ( const auto & [ gpIndex , gp ] : uFunction . viewOverIntegrationPoints ()) { //.. calculate the inverse Jacobian of the geometry for ( auto i : loop over coeffs , i . e . nodes of the finite element ) { const auto graduDCoeffsI = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall , coeffs ), transformWith ( Jinv ), coeffIndices ( i )); for ( auto j : fe . size ()) { //loop over coeffs, i.e.nodes of the finite element const auto graduDCoeffsJ = uFunction . evaluateDerivative ( gpIndex , wrt ( spatialall , coeffs ), transformWith ( Jinv ), coeffIndices ( j )); Eigen :: Matrix < double , size , size > tmp ; tmp . setZero (); for ( int k = 0 ; k < gridDimension ; ++ k ) tmp += graduDCoeffsI [ k ] * graduDCoeffsJ [ k ]; h . block < size , size > ( i * size , j * size ) += tmp * ( \"weight from integration point and geo.integrationElement\" ); } } } }","title":"Example Dirichlet energy"},{"location":"01_theory/LocalFunctions/#implementations","text":"In the following we summarize the local functions that are currently available. In the follwing table \\(N^i(\\boldsymbol{\\xi})\\) are the ansatz functions. Name Interpolation formula Note Header Standard $$ \\boldsymbol{x} = \\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i $$ standardLocalFunction.hh Projection-Based 2 $$ \\boldsymbol{x} = P\\left(\\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\right) $$ This is one version of geometric finite elements. These are finite elements suited for interpolation on manifolds. Here \\(P: \\mathbb{R}^m \\rightarrow \\mathcal{M}\\) is an operator that projects the usual linear interpolation onto some manifold projectionBasedLocalFunction.hh","title":"Implementations"},{"location":"01_theory/LocalFunctions/#how-to-implement-your-own-local-functions","text":"If you are interested in implementing your own local function we have prepared the file ikarus/LocalFunctions/LocalFunctionTemplate.h . You can copy the file rename the class to your preferred name and then implement the following functions. If you don't need a function you need to delete the corresponding function. Then if someone calls the corresponding derivative the call fails at compile time. FunctionReturnType evaluateEmbeddingFunctionImpl ( const Eigen :: VectorXd & N ) const { return FunctionReturnType {}; } // (0) Jacobian evaluateDerivativeWRTSpaceAllImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN ) const {...} // (1) JacobianColType evaluateDerivativeWRTSpaceSingleImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , int spaceIndex ) const {...} // (2) CoeffDerivMatrix evaluateDerivativeWRTCoeffsImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , int coeffsIndex ) const {...} // (3) CoeffDerivMatrix evaluateSecondDerivativeWRTCoeffs ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & , const AlongType & along , const std :: array < size_t , gridDim >& coeffsIndex ) const {...} // (4) std :: array < CoeffDerivMatrix , gridDim > evaluateDerivativeWRTCoeffsANDSpatialImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , int coeffsIndex ) const {...} // (5) CoeffDerivMatrix evaluateDerivativeWRTCoeffsANDSpatialSingleImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , const int coeffsIndex , const int spatialIndex ) const {...} // (6) std :: array < CoeffDerivMatrix , gridDim > evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , const AlongType & along , const std :: array < size_t , gridDim >& coeffsIndex ) const {...} // (7) CoeffDerivMatrix evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialSingleImpl ( const AnsatzFunctionType & N , const AnsatzFunctionJacobian & dN , const AlongType & along , const std :: array < size_t , gridDim >& coeffsIndex , c const int spatialIndex ) const {...} // (8) This is called by localFunction.evaluateFunction(...) . This is called by localFunction.evaluateDerivative(..., wrt(spatialall)) . This is called by localFunction.evaluateDerivative(..., wrt(spatial(i))) . This is called by localFunction.evaluateDerivative(..., wrt(coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(coeff,coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatialall,coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatial(i),coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatialall,coeff,coeff)) . This is called by localFunction.evaluateDerivative(..., wrt(spatial(i),coeff,coeff)) . Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9 Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal , 57(1):404\u2013428, 2019. doi:10.1137/18M1176798 . \u21a9","title":"How to implement your own local functions"},{"location":"01_theory/Manifolds/","text":"Manifold elements \u00b6 Introduction \u00b6 Usually optimization problems are defined in terms of some cost function. $$ \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) $$ where \\( f: \\mathcal{M} \\rightarrow \\mathbb{R} \\) . Usually \\( \\mathcal{M} \\) is an Euclidean vector space \\( \\mathbb{R}^n \\) . In a finite element context, if we solve e.g. 2d elasticity problems we have a two-dimensional displacement for each node. Thus if we have \\(n \\) nodes we optimize in \\( {\\mathbb{R}^2}^n \\) . For this case the nodal degrees of freedom should be wrapped in Ikarus :: RealTuple < double , 2 > . Another case of optimization is on non-linear manifolds. These arise typically for Cosserat materials \\( \\mathcal{S}\\mathcal{O}(3) \\) , Reissner-Mindlin shells and micromagnetics \\( \\mathcal{S}^{2} \\) or incompressible materials. Interface \u00b6 The general interface of the manifold elements is represented by the following concept. namespace Ikarus :: Concepts { template < typename ManifoldType > concept Manifold = requires ( ManifoldType var , typename ManifoldType :: CorrectionType correction , std :: ostream & s , typename ManifoldType :: CoordinateType value ) { typename ManifoldType :: ctype ; // (1) ManifoldType :: valueSize ; // (2) ManifoldType :: correctionSize ; // (3) typename ManifoldType :: CoordinateType ; // (4) typename ManifoldType :: CorrectionType ; // (5) { var . getValue () } -> std :: convertible_to < typename ManifoldType :: CoordinateType > ; // (6) { var . setValue ( value ) } -> std :: same_as < void > ; // (7) { var += correction }; // (8) { s << var } -> std :: same_as < std :: ostream &> ; }; } The type for the coordinate values usually double . The number of values to store the state of the element. E.g. the three dimensional unit vector needs three entries to store its state. The size of the correction of the element. For the Euclidean space valueSize and correctionSize coincide. But e.g. the three dimensional unit vector needs a two-dimensional correction. (Which lives in the tangent space.) The type to store the element coordinates usually Eigen :: Vector < double , ManifoldType :: valueSize > The type to store the element correction type usually Eigen :: Vector < double , ManifoldType :: correctionSize > Access the underlying coordinates vector of the manifold element. Directly set the value. E.g. set a Ikarus :: UnitVector < double , 3 > a ; a . setValue ( Eigen :: Vector3d :: UnitZ ()); Update the element with a correction vector. E.g. Ikarus :: RealTuple < double , 3 > a ; a += Eigen :: Vector3d :: UnitX (); Ikarus :: UnitVector < double , 3 > b ; b += Eigen :: Vector2d :: UnitX (); Implementations \u00b6 Name Formal definition Notes Header \\(n\\) -th dimensional Euclidean space $$ \\boldsymbol{x} \\in \\mathbb{R}^n $$ realTuple.hh Unit sphere $$ \\boldsymbol{x} \\in \\mathcal{S}^{n-1}, \\quad \\mathcal{S}^{n-1} = \\left\\{ \\boldsymbol{x} \\in \\mathbb{R}^n : \\boldsymbol{x}\\cdot \\boldsymbol{x} = 1 \\right\\} $$ unitVector.hh","title":"Manifolds"},{"location":"01_theory/Manifolds/#manifold-elements","text":"","title":"Manifold elements"},{"location":"01_theory/Manifolds/#introduction","text":"Usually optimization problems are defined in terms of some cost function. $$ \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) $$ where \\( f: \\mathcal{M} \\rightarrow \\mathbb{R} \\) . Usually \\( \\mathcal{M} \\) is an Euclidean vector space \\( \\mathbb{R}^n \\) . In a finite element context, if we solve e.g. 2d elasticity problems we have a two-dimensional displacement for each node. Thus if we have \\(n \\) nodes we optimize in \\( {\\mathbb{R}^2}^n \\) . For this case the nodal degrees of freedom should be wrapped in Ikarus :: RealTuple < double , 2 > . Another case of optimization is on non-linear manifolds. These arise typically for Cosserat materials \\( \\mathcal{S}\\mathcal{O}(3) \\) , Reissner-Mindlin shells and micromagnetics \\( \\mathcal{S}^{2} \\) or incompressible materials.","title":"Introduction"},{"location":"01_theory/Manifolds/#interface","text":"The general interface of the manifold elements is represented by the following concept. namespace Ikarus :: Concepts { template < typename ManifoldType > concept Manifold = requires ( ManifoldType var , typename ManifoldType :: CorrectionType correction , std :: ostream & s , typename ManifoldType :: CoordinateType value ) { typename ManifoldType :: ctype ; // (1) ManifoldType :: valueSize ; // (2) ManifoldType :: correctionSize ; // (3) typename ManifoldType :: CoordinateType ; // (4) typename ManifoldType :: CorrectionType ; // (5) { var . getValue () } -> std :: convertible_to < typename ManifoldType :: CoordinateType > ; // (6) { var . setValue ( value ) } -> std :: same_as < void > ; // (7) { var += correction }; // (8) { s << var } -> std :: same_as < std :: ostream &> ; }; } The type for the coordinate values usually double . The number of values to store the state of the element. E.g. the three dimensional unit vector needs three entries to store its state. The size of the correction of the element. For the Euclidean space valueSize and correctionSize coincide. But e.g. the three dimensional unit vector needs a two-dimensional correction. (Which lives in the tangent space.) The type to store the element coordinates usually Eigen :: Vector < double , ManifoldType :: valueSize > The type to store the element correction type usually Eigen :: Vector < double , ManifoldType :: correctionSize > Access the underlying coordinates vector of the manifold element. Directly set the value. E.g. set a Ikarus :: UnitVector < double , 3 > a ; a . setValue ( Eigen :: Vector3d :: UnitZ ()); Update the element with a correction vector. E.g. Ikarus :: RealTuple < double , 3 > a ; a += Eigen :: Vector3d :: UnitX (); Ikarus :: UnitVector < double , 3 > b ; b += Eigen :: Vector2d :: UnitX ();","title":"Interface"},{"location":"01_theory/Manifolds/#implementations","text":"Name Formal definition Notes Header \\(n\\) -th dimensional Euclidean space $$ \\boldsymbol{x} \\in \\mathbb{R}^n $$ realTuple.hh Unit sphere $$ \\boldsymbol{x} \\in \\mathcal{S}^{n-1}, \\quad \\mathcal{S}^{n-1} = \\left\\{ \\boldsymbol{x} \\in \\mathbb{R}^n : \\boldsymbol{x}\\cdot \\boldsymbol{x} = 1 \\right\\} $$ unitVector.hh","title":"Implementations"},{"location":"01_theory/NonlinearOperator/","text":"Non-linear operator \u00b6","title":"NonlinearOperator"},{"location":"01_theory/NonlinearOperator/#non-linear-operator","text":"","title":"Non-linear operator"},{"location":"01_theory/Solvers/","text":"Solvers \u00b6 In Ikarus there are essentially two types of solvers. Linear solver \u00b6 The first are called LinearSolver . These are solver which solve for the vector \\( \\boldsymbol{x} \\) in $$ \\boldsymbol{A} \\boldsymbol{x} = \\boldsymbol{b} $$ where \\(\\boldsymbol{A} \\) is some matrix and \\(\\boldsymbol{b}\\) is some vector. These solvers can be direct or iterative. Furthermore, they depend on the underlying structure of the matrix \\(\\boldsymbol{A} \\) . I.e. if it is stored in dense or in a sparse format. Currently, we only support the linear solvers provided by the Eigen library. Linear solvers can be constructed by calling the constructor ILinearSolver ( const SolverTypeTag & solverTypeTag ) There exits an enum type SolverTypeTag with the following values 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 enum class SolverTypeTag { si_ConjugateGradient , si_LeastSquaresConjugateGradient , si_BiCGSTAB , sd_SimplicialLLT , sd_SimplicialLDLT , sd_SparseLU , sd_SparseQR , sd_CholmodSupernodalLLT , sd_UmfPackLU , sd_SuperLU , d_PartialPivLU , d_FullPivLU , d_HouseholderQR , d_ColPivHouseholderQR , d_FullPivHouseholderQR , d_CompleteOrthogonalDecomposition , d_LLT , d_LDLT , }; The prefixes s_ and d_ indicate wether the linear solver can be used for dense or sparse matrices. Furthermore, there is a second prefix for sparse solvers 1 d and i for direct solvers and for iterative solvers. Thus, using si_ConjugateGradient means that this solver is for sparse matrices and is an iterative solver. The naming of the solvers is the same as in Eigen. For more details on the solvers we refer to Eigen's documentation for dense decompositions and to Eigen's documentation for sparse decompositions . Interface \u00b6 Similar to Eigen's interface the following function are provided void analyzePattern ( const MatrixType & A ); // (1) void factorize ( const MatrixType & A ); // (2) ILinearSolver & compute ( const MatrixType & A ); // (3) void solve ( Eigen :: VectorX < ScalarType >& x , const Eigen :: VectorX < ScalarType >& b ); // (4) 1. If the matrix is sparse Eigen can collect information on the sparsity pattern of the matrix for faster a faster solve step. This pattrern does not change if you change the values of the non-zero entries. 2. This method applies some decomposition for direct solvers e.g. LU decomposition. For iterative solvers the method is a noOp. 3. Compute simply calls 'analyzePattern' and 'factorize'. 4. Solves the problem and stores the result in x . Note If your algorithm in mind does rely on special features of some linear solver then you have to directly use this solver. E.g. if you need the .determinant() method of Eigen::SimplicialLDLT you need to directly use it since ILinearSolver does not support this method. Non-Linear solver \u00b6 Non-linear solvers are usually used to solve some optimization problem, e.g. root-finding or minimization problems \\begin{align} \\boldsymbol{R}(\\boldsymbol{x}) \\stackrel{!}{=} \\boldsymbol{0} \\quad \\text{or} \\quad \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) \\end{align} Interface \u00b6 void setup ( const NewtonRaphsonSettings & p_settings ); // (1) SolverInformation solve ( const SolutionType & dx_predictor = NoPredictor {}); // (2) auto & nonLinearOperator (); // (3) With this function several properties of the nonlinear solver can be set. E.g. residual tolerance or maximum number of iterations. Solves the non-linear problem. One can pass an initial guess to the function. Otherwise the zero vector is assumed. It returns SolverInformation which contains information on the sucess of the solution step and other information as the needed iterations. Simply returns the underlying Note To easy the construction process the Nonlinear solver can provide a method make[...] which allows shorter syntax. since no std::shared_ptr has to be constructed and specifying all template arguments. The construction of the nonlinear solvers can be very differnt therefore we do not impose and interface for the constructors. Implementations \u00b6 Name Purpose Constraints on nonlinear operator Header Properties Newton-Raphson Root finding Value and gradient newtonRaphson.hh Locally quadratic convergence Trust-Region Minimization Value, gradient and Hessian trustRegion.hh Globally convergent and locally quadratic convergence To see the Newton-Raphson we refer to the tests inside nonLinearOperatorTest.cpp and for trust region trustRegionTest.cpp . Dense solver are currently all direct solvers. Therefore, we do not distinguish them. \u21a9","title":"Solvers"},{"location":"01_theory/Solvers/#solvers","text":"In Ikarus there are essentially two types of solvers.","title":"Solvers"},{"location":"01_theory/Solvers/#linear-solver","text":"The first are called LinearSolver . These are solver which solve for the vector \\( \\boldsymbol{x} \\) in $$ \\boldsymbol{A} \\boldsymbol{x} = \\boldsymbol{b} $$ where \\(\\boldsymbol{A} \\) is some matrix and \\(\\boldsymbol{b}\\) is some vector. These solvers can be direct or iterative. Furthermore, they depend on the underlying structure of the matrix \\(\\boldsymbol{A} \\) . I.e. if it is stored in dense or in a sparse format. Currently, we only support the linear solvers provided by the Eigen library. Linear solvers can be constructed by calling the constructor ILinearSolver ( const SolverTypeTag & solverTypeTag ) There exits an enum type SolverTypeTag with the following values 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 enum class SolverTypeTag { si_ConjugateGradient , si_LeastSquaresConjugateGradient , si_BiCGSTAB , sd_SimplicialLLT , sd_SimplicialLDLT , sd_SparseLU , sd_SparseQR , sd_CholmodSupernodalLLT , sd_UmfPackLU , sd_SuperLU , d_PartialPivLU , d_FullPivLU , d_HouseholderQR , d_ColPivHouseholderQR , d_FullPivHouseholderQR , d_CompleteOrthogonalDecomposition , d_LLT , d_LDLT , }; The prefixes s_ and d_ indicate wether the linear solver can be used for dense or sparse matrices. Furthermore, there is a second prefix for sparse solvers 1 d and i for direct solvers and for iterative solvers. Thus, using si_ConjugateGradient means that this solver is for sparse matrices and is an iterative solver. The naming of the solvers is the same as in Eigen. For more details on the solvers we refer to Eigen's documentation for dense decompositions and to Eigen's documentation for sparse decompositions .","title":"Linear solver"},{"location":"01_theory/Solvers/#interface","text":"Similar to Eigen's interface the following function are provided void analyzePattern ( const MatrixType & A ); // (1) void factorize ( const MatrixType & A ); // (2) ILinearSolver & compute ( const MatrixType & A ); // (3) void solve ( Eigen :: VectorX < ScalarType >& x , const Eigen :: VectorX < ScalarType >& b ); // (4) 1. If the matrix is sparse Eigen can collect information on the sparsity pattern of the matrix for faster a faster solve step. This pattrern does not change if you change the values of the non-zero entries. 2. This method applies some decomposition for direct solvers e.g. LU decomposition. For iterative solvers the method is a noOp. 3. Compute simply calls 'analyzePattern' and 'factorize'. 4. Solves the problem and stores the result in x . Note If your algorithm in mind does rely on special features of some linear solver then you have to directly use this solver. E.g. if you need the .determinant() method of Eigen::SimplicialLDLT you need to directly use it since ILinearSolver does not support this method.","title":"Interface"},{"location":"01_theory/Solvers/#non-linear-solver","text":"Non-linear solvers are usually used to solve some optimization problem, e.g. root-finding or minimization problems \\begin{align} \\boldsymbol{R}(\\boldsymbol{x}) \\stackrel{!}{=} \\boldsymbol{0} \\quad \\text{or} \\quad \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) \\end{align}","title":"Non-Linear solver"},{"location":"01_theory/Solvers/#interface_1","text":"void setup ( const NewtonRaphsonSettings & p_settings ); // (1) SolverInformation solve ( const SolutionType & dx_predictor = NoPredictor {}); // (2) auto & nonLinearOperator (); // (3) With this function several properties of the nonlinear solver can be set. E.g. residual tolerance or maximum number of iterations. Solves the non-linear problem. One can pass an initial guess to the function. Otherwise the zero vector is assumed. It returns SolverInformation which contains information on the sucess of the solution step and other information as the needed iterations. Simply returns the underlying Note To easy the construction process the Nonlinear solver can provide a method make[...] which allows shorter syntax. since no std::shared_ptr has to be constructed and specifying all template arguments. The construction of the nonlinear solvers can be very differnt therefore we do not impose and interface for the constructors.","title":"Interface"},{"location":"01_theory/Solvers/#implementations","text":"Name Purpose Constraints on nonlinear operator Header Properties Newton-Raphson Root finding Value and gradient newtonRaphson.hh Locally quadratic convergence Trust-Region Minimization Value, gradient and Hessian trustRegion.hh Globally convergent and locally quadratic convergence To see the Newton-Raphson we refer to the tests inside nonLinearOperatorTest.cpp and for trust region trustRegionTest.cpp . Dense solver are currently all direct solvers. Therefore, we do not distinguish them. \u21a9","title":"Implementations"},{"location":"01_theory/interfaceVSimplementation/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modify the implemented functionality or who want to learn more about the implementation thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Seperation of interface and implementation \u00b6 On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car. Interface of a car \u00b6 Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then: brand() : a function which returns the brand as a string maxvelocity() : a function which returns the maximum velocity as a double This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above. Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double. Implementation of a car \u00b6 Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar . Summary \u00b6 Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface Member functions and free functions \u00b6 In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like brand(car) in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for MyCar then looks like this: std :: string brand ( MyCar carObject ) { return \"MyBrand\" ;} This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).","title":"Interface vs. Implementation"},{"location":"01_theory/interfaceVSimplementation/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modify the implemented functionality or who want to learn more about the implementation thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"01_theory/interfaceVSimplementation/#seperation-of-interface-and-implementation","text":"On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car.","title":"Seperation of interface and implementation"},{"location":"01_theory/interfaceVSimplementation/#interface-of-a-car","text":"Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then: brand() : a function which returns the brand as a string maxvelocity() : a function which returns the maximum velocity as a double This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above. Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double.","title":"Interface of a car"},{"location":"01_theory/interfaceVSimplementation/#implementation-of-a-car","text":"Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar .","title":"Implementation of a car"},{"location":"01_theory/interfaceVSimplementation/#summary","text":"Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface","title":"Summary"},{"location":"01_theory/interfaceVSimplementation/#member-functions-and-free-functions","text":"In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like brand(car) in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for MyCar then looks like this: std :: string brand ( MyCar carObject ) { return \"MyBrand\" ;} This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).","title":"Member functions and free functions"},{"location":"01_theory/overview/","text":"Overview \u00b6","title":"Overview"},{"location":"01_theory/overview/#overview","text":"","title":"Overview"},{"location":"01_theory/theoryGeometry/","text":"Geometry \u00b6 For the notion of geometry of the grid entities we rely on the definitions of dune. For details, see 1 Chapter 5.3. Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9","title":"Geometry"},{"location":"01_theory/theoryGeometry/#geometry","text":"For the notion of geometry of the grid entities we rely on the definitions of dune. For details, see 1 Chapter 5.3. Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9","title":"Geometry"},{"location":"01_theory/theoryGrid/","text":"Description of the grid \u00b6 In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. provide a unique identifier (element number) provide a description of the reference geometry (element shape in physical space, shape functions, etc.) provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . On this page, we will go through it using the following example: Grid \u00b6 The grid is a collection of grid entities. In the example above, the grid consists of three surfaces, ten edges and eight vertices, i.e. it consists of 21 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job. Interface of the grid \u00b6 leafGridView() : returns a grid view , i.e. an object which can iterate over the grid. Available grid implementations \u00b6 All grids that satisfy the dune::grid interface can be used. For an overview of the available dune::grids, we refer to link . Additionally there exists an iga grid dune-iga . Grid entity \u00b6 For the interface of grid entities we refer to 1 Chapter 5.3. Grid factory \u00b6 To construct a grid, a grid factory can be used. To construct a grid, vertices and element definitions are inserted into the factory. The grid is then constructed by the createGrid() function. Interface of the grid factory \u00b6 insertVertex(const Dune::FieldVector<double, dimensionworld>&) : Vertices are inserted as a Dune::FieldVector of doubles. Its size is equal to the dimensions of the world (e.g. 2 if it is a 2d simulation etc.) insertElement(Dune::GeometryType type, std::span<size_t> vertices) : An element is defined by its geometrical type and the vertex numbers. For the ordering of the node numbers, see 1 Fig. 5.13. Grid view \u00b6 The interface of a grid view consists of four free functions. Each of them provides a span of certain grid objects: vertices(GridView) : returns a span of all vertices in this grid edges(GridView) : returns a span of all edges in this grid surfaces(GridView) : returns a span of all surfaces in this grid volumes(GridView) : returns a span of all volumes in this grid Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9 \u21a9","title":"Grid"},{"location":"01_theory/theoryGrid/#description-of-the-grid","text":"In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. provide a unique identifier (element number) provide a description of the reference geometry (element shape in physical space, shape functions, etc.) provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . On this page, we will go through it using the following example:","title":"Description of the grid"},{"location":"01_theory/theoryGrid/#grid","text":"The grid is a collection of grid entities. In the example above, the grid consists of three surfaces, ten edges and eight vertices, i.e. it consists of 21 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job.","title":"Grid"},{"location":"01_theory/theoryGrid/#interface-of-the-grid","text":"leafGridView() : returns a grid view , i.e. an object which can iterate over the grid.","title":"Interface of the grid"},{"location":"01_theory/theoryGrid/#available-grid-implementations","text":"All grids that satisfy the dune::grid interface can be used. For an overview of the available dune::grids, we refer to link . Additionally there exists an iga grid dune-iga .","title":"Available grid implementations"},{"location":"01_theory/theoryGrid/#grid-entity","text":"For the interface of grid entities we refer to 1 Chapter 5.3.","title":"Grid entity"},{"location":"01_theory/theoryGrid/#grid-factory","text":"To construct a grid, a grid factory can be used. To construct a grid, vertices and element definitions are inserted into the factory. The grid is then constructed by the createGrid() function.","title":"Grid factory"},{"location":"01_theory/theoryGrid/#interface-of-the-grid-factory","text":"insertVertex(const Dune::FieldVector<double, dimensionworld>&) : Vertices are inserted as a Dune::FieldVector of doubles. Its size is equal to the dimensions of the world (e.g. 2 if it is a 2d simulation etc.) insertElement(Dune::GeometryType type, std::span<size_t> vertices) : An element is defined by its geometrical type and the vertex numbers. For the ordering of the node numbers, see 1 Fig. 5.13.","title":"Interface of the grid factory"},{"location":"01_theory/theoryGrid/#grid-view","text":"The interface of a grid view consists of four free functions. Each of them provides a span of certain grid objects: vertices(GridView) : returns a span of all vertices in this grid edges(GridView) : returns a span of all edges in this grid surfaces(GridView) : returns a span of all surfaces in this grid volumes(GridView) : returns a span of all volumes in this grid Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9 \u21a9","title":"Grid view"},{"location":"02_gallery/gallery/","text":"Gallery \u00b6 Micromagnetostatic simulation with magnetization \\( \\boldsymbol{m} \\in \\mathcal{S}^{2} \\) and the magnetic vector potential \\( \\boldsymbol{A} \\in \\mathbb{R}^3 \\). Inside the sphere the free field is discretized and in the center a thin cylindrical magnetic material is place. The B-Field magnitude is indicated by the color. Furthermore, the magnetization vectors inside the magnetic material are shown which indicate the curling mode of the magnet.","title":"Gallery"},{"location":"02_gallery/gallery/#gallery","text":"Micromagnetostatic simulation with magnetization \\( \\boldsymbol{m} \\in \\mathcal{S}^{2} \\) and the magnetic vector potential \\( \\boldsymbol{A} \\in \\mathbb{R}^3 \\). Inside the sphere the free field is discretized and in the center a thin cylindrical magnetic material is place. The B-Field magnitude is indicated by the color. Furthermore, the magnetization vectors inside the magnetic material are shown which indicate the curling mode of the magnet.","title":"Gallery"},{"location":"99_Literature/99_Literature/","text":"Literature \u00b6 Robert C Martin. Clean Code . Pearson Education, 2008. \u21a9 Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software . Pearson Deutschland GmbH, 1995. \u21a9 Martin Reddy. API Design for C++ . Elsevier, 2011. \u21a9 Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs . Pearson Education, 2005. \u21a9 Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version . Pearson Education, 1995. \u21a9 Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering , pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7 . \u21a9 J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering , 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013 . \u21a9 Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9 Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal , 57(1):404\u2013428, 2019. doi:10.1137/18M1176798 . \u21a9","title":"Literature"},{"location":"99_Literature/99_Literature/#literature","text":"Robert C Martin. Clean Code . Pearson Education, 2008. \u21a9 Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software . Pearson Deutschland GmbH, 1995. \u21a9 Martin Reddy. API Design for C++ . Elsevier, 2011. \u21a9 Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs . Pearson Education, 2005. \u21a9 Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version . Pearson Education, 1995. \u21a9 Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering , pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7 . \u21a9 J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering , 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013 . \u21a9 Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment . Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3 . \u21a9 Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal , 57(1):404\u2013428, 2019. doi:10.1137/18M1176798 . \u21a9","title":"Literature"},{"location":"documentation/BuildTheDocumentationLocally/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the download page . Preview the documentation locally \u00b6 Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser You can edit the documentation in CLion. STRG + s saves the documentation and updates it in your browser window. Cancel the build process to stop the live preview","title":"Build the documentation locally"},{"location":"documentation/BuildTheDocumentationLocally/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"documentation/BuildTheDocumentationLocally/#prerequisites","text":"Ikarus cloned on your computer, see the download page .","title":"Prerequisites"},{"location":"documentation/BuildTheDocumentationLocally/#preview-the-documentation-locally","text":"Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser You can edit the documentation in CLion. STRG + s saves the documentation and updates it in your browser window. Cancel the build process to stop the live preview","title":"Preview the documentation locally"},{"location":"documentation/howToEdit/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the download page . Edit a page \u00b6 Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated Add a new page \u00b6 Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated Insert a latex formula \u00b6 $$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$ is compiled to \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\] Insert C++ code \u00b6 The C++ code: double complicatedCalculation ( double number , double anotherNumber ) { return number * anotherNumber ; }; How it needs to be written in markdown: ```cpp double complicatedCalculation(double number, double anotherNumber) { return number*anotherNumber; }; ``` Insert a table \u00b6 Look at the markdown file of this page to see how a table can be inserted. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl ) Insert a warning Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly. References For available features in the documentation see Mkdocs-Material and Mkdocs .","title":"How to edit the documentation"},{"location":"documentation/howToEdit/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"documentation/howToEdit/#prerequisites","text":"Ikarus cloned on your computer, see the download page .","title":"Prerequisites"},{"location":"documentation/howToEdit/#edit-a-page","text":"Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Edit a page"},{"location":"documentation/howToEdit/#add-a-new-page","text":"Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Add a new page"},{"location":"documentation/howToEdit/#insert-a-latex-formula","text":"$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$ is compiled to \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]","title":"Insert a latex formula"},{"location":"documentation/howToEdit/#insert-c-code","text":"The C++ code: double complicatedCalculation ( double number , double anotherNumber ) { return number * anotherNumber ; }; How it needs to be written in markdown: ```cpp double complicatedCalculation(double number, double anotherNumber) { return number*anotherNumber; }; ```","title":"Insert C++ code"},{"location":"documentation/howToEdit/#insert-a-table","text":"Look at the markdown file of this page to see how a table can be inserted. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl ) Insert a warning Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly. References For available features in the documentation see Mkdocs-Material and Mkdocs .","title":"Insert a table"},{"location":"examples/integrate_pi/","text":"This examples comes from /examples/src/tut_compute-pi0.cpp #include <numbers> #include <dune/alugrid/grid.hh> #include <dune/geometry/quadraturerules.hh> #include <dune/grid/io/file/vtk/vtkwriter.hh> #include <Eigen/Core> #include <Eigen/Dense> #include <ikarus/utils/drawing/griddrawer.hh> int main () { constexpr int gridDim = 2 ; // (1) using Grid = Dune :: ALUGrid < gridDim , 2 , Dune :: simplex , Dune :: conforming > ; auto grid = Dune :: GmshReader < Grid >:: read ( \"../../examples/src/testFiles/circleCoarse.msh\" , false ); auto gridView = grid -> leafGridView (); // (2) draw ( gridView ); /// Calculate area from volume function of elements double area1 = 0.0 ; for ( auto & element : elements ( gridView )) area1 += element . geometry (). volume (); /// Integrate function using integration rule on grid auto f = []( auto && global ) { return sqrt ( global [ 0 ] * global [ 0 ] + global [ 1 ] * global [ 1 ]); }; double area2 = 0.0 ; for ( auto & element : elements ( gridView )) { const auto & rule = Dune :: QuadratureRules < double , 2 >:: rule ( element . type (), 1 , Dune :: QuadratureType :: GaussLegendre ); for ( auto & gp : rule ) // area2 += element.geometry().integrationElement(gp.position()) * gp.weight(); area2 += f ( element . geometry (). global ( gp . position ())) * element . geometry (). integrationElement ( gp . position ()) * gp . weight (); // integrationElement --> JacobiDeterminant } std :: cout << area1 << \" \" << area2 << std :: endl ; /// Naive refinement of grid and compare calculated area to pi for ( int i = 0 ; i < 3 ; ++ i ) { area1 = 0.0 ; grid -> globalRefine ( 1 ); auto gridViewRefined = grid -> leafGridView (); std :: cout << \"This gridview contains: \" ; std :: cout << gridViewRefined . size ( 0 ) << \" elements\" << std :: endl ; draw ( gridViewRefined ); for ( auto & element : elements ( gridViewRefined )) { area1 += element . geometry (). volume (); } std :: cout << area1 << \" \" << std :: numbers :: pi << std :: endl ; } /// write element areas to vtk std :: vector < double > areas ; areas . resize ( gridView . size ( 0 )); auto & indexSet = gridView . indexSet (); for ( auto & ele : elements ( gridView )) areas [ indexSet . index ( ele )] = ele . geometry (). volume (); Dune :: VTKWriter vtkWriter ( gridView ); vtkWriter . addCellData ( areas , \"area\" , 1 ); vtkWriter . write ( \"TestGridEntitites\" ); /// Calculate circumference and compare to pi double circumference = 0.0 ; for ( auto & element : elements ( gridView )) if ( element . hasBoundaryIntersections ()) for ( auto & intersection : intersections ( gridView , element )) if ( intersection . boundary ()) circumference += intersection . geometry (). volume (); std :: cout << circumference << \" \" << std :: numbers :: pi << std :: endl ; } Create ALUGrid from gmsh file. Create leaf grid view of grid","title":"Integrate pi"},{"location":"tutorials/tutorialsOverview/","text":"Tutorials \u00b6 This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the impl theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the impl thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section . Topics \u00b6 To be added","title":"Overview"},{"location":"tutorials/tutorialsOverview/#tutorials","text":"This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the impl theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the impl thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section .","title":"Tutorials"},{"location":"tutorials/tutorialsOverview/#topics","text":"To be added","title":"Topics"}]}
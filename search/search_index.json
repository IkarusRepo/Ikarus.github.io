{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6","title":"Home"},{"location":"#welcome-to-mkdocs","text":"","title":"Welcome to MkDocs"},{"location":"geometry/","text":"","title":"Geometry"},{"location":"grid/","text":"Grid tutorials \u00b6 This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project . SimpleGrid \u00b6 There, exists a simple grid implementation called SimpleGrid<dim,wdim> . It can be used for up to three world space dimension and it provides an unstructured grid with arbitrary element types of the same dimension. It uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions. SimpleGrid example \u00b6 We go step by step through the following code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <dune/geometry/type.hh> #include <ikarus/Grids/GridHelper/griddrawer.h> #include <ikarus/Grids/SimpleGrid/SimpleGrid.h> int main () { using namespace Ikarus :: Grid ; using Grid = SimpleGrid < 3 , 3 > ; SimpleGridFactory < Grid > gridFactory ; using vertexType = Eigen :: Vector3d ; std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , -3.0 }); // 0 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , -3.0 }); // 1 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , -3.0 }); // 2 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , -3.0 }); // 3 verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , 3.0 }); // 4 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , 3.0 }); // 5 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , 3.0 }); // 6 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , 3.0 }); // 7 verticesVec . emplace_back ( vertexType { 4.0 , 0.0 , 3.0 }); // 8 for ( auto && vert : verticesVec ) gridFactory . insertVertex ( vert ); std :: vector < size_t > elementIndices ; elementIndices . resize ( 8 ); elementIndices = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }; gridFactory . insertElement ( Dune :: GeometryTypes :: hexahedron , elementIndices ); elementIndices . resize ( 4 ); elementIndices = { 1 , 8 , 3 , 5 }; gridFactory . insertElement ( Dune :: GeometryTypes :: tetrahedron , elementIndices ); Grid grid = gridFactory . createGrid (); auto gridView = grid . leafGridView (); // for(auto&& vertex : vertices(gridView)) // vertex. draw ( gridView ); } First we choose, which grid type we want to create and fill with entities using the type alias Grid . using namespace Ikarus :: Grid ; using Grid = SimpleGrid < 3 , 3 > ; After this we create a factory for this type. SimpleGridFactory < Grid > gridFactory ; After that we fill a vector with nine vertex positions. The type of the vector of coordinates is the three dimensional double vector Eigen::Vector3d of the Eigen library . using vertexType = Eigen :: Vector3d ; std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , -3.0 }); // 0 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , -3.0 }); // 1 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , -3.0 }); // 2 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , -3.0 }); // 3 verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , 3.0 }); // 4 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , 3.0 }); // 5 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , 3.0 }); // 6 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , 3.0 }); // 7 verticesVec . emplace_back ( vertexType { 4.0 , 0.0 , 3.0 }); // 8 In the following we use the first functionality of the gridfactory which is the insertVertex() function which allows to insert vertices into grid for ( auto && vert : verticesVec ) gridFactory . insertVertex ( vert ); Grid containing a hexahedron and a tetrahedron. In red the vertices are shown. The grid shows a non-conforming mesh. Interfaces \u00b6 Grid factory \u00b6 Grid \u00b6 The grid itself does not have a particular interface, except that it has to provide function to return a grid view. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl ) Grid entities \u00b6 To stay compatible with Dune::GridEntities we provide a subset of the interface for the grid entities. Furthermore, we demand that they need to provide a unique identitfier. // Return a unique id of this entity size_t getID (); // The refinement level to which the entity belongs int level (); // Geometric realization of this entity, see GeometryType geometry (); // The type of the entity, e.g. line, vertex, quadrilateral,... Dune :: GeometryType type (); // Number of subentities, e.g. a line has two vertices unsigned int subEntities (); For the interface of GeometryType see Geometry . Warning It is tempting to attach any physical meaning to the grid entities. Nevertheless, the only purpose of the grid and grid entities is to provide the connectivity between different grid entities and an unique identifier to construct later on degrees of freedom indices from it. Formula test \u00b6 \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\]","title":"Grid"},{"location":"grid/#grid-tutorials","text":"This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project .","title":"Grid tutorials"},{"location":"grid/#simplegrid","text":"There, exists a simple grid implementation called SimpleGrid<dim,wdim> . It can be used for up to three world space dimension and it provides an unstructured grid with arbitrary element types of the same dimension. It uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions.","title":"SimpleGrid"},{"location":"grid/#simplegrid-example","text":"We go step by step through the following code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <dune/geometry/type.hh> #include <ikarus/Grids/GridHelper/griddrawer.h> #include <ikarus/Grids/SimpleGrid/SimpleGrid.h> int main () { using namespace Ikarus :: Grid ; using Grid = SimpleGrid < 3 , 3 > ; SimpleGridFactory < Grid > gridFactory ; using vertexType = Eigen :: Vector3d ; std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , -3.0 }); // 0 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , -3.0 }); // 1 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , -3.0 }); // 2 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , -3.0 }); // 3 verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , 3.0 }); // 4 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , 3.0 }); // 5 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , 3.0 }); // 6 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , 3.0 }); // 7 verticesVec . emplace_back ( vertexType { 4.0 , 0.0 , 3.0 }); // 8 for ( auto && vert : verticesVec ) gridFactory . insertVertex ( vert ); std :: vector < size_t > elementIndices ; elementIndices . resize ( 8 ); elementIndices = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }; gridFactory . insertElement ( Dune :: GeometryTypes :: hexahedron , elementIndices ); elementIndices . resize ( 4 ); elementIndices = { 1 , 8 , 3 , 5 }; gridFactory . insertElement ( Dune :: GeometryTypes :: tetrahedron , elementIndices ); Grid grid = gridFactory . createGrid (); auto gridView = grid . leafGridView (); // for(auto&& vertex : vertices(gridView)) // vertex. draw ( gridView ); } First we choose, which grid type we want to create and fill with entities using the type alias Grid . using namespace Ikarus :: Grid ; using Grid = SimpleGrid < 3 , 3 > ; After this we create a factory for this type. SimpleGridFactory < Grid > gridFactory ; After that we fill a vector with nine vertex positions. The type of the vector of coordinates is the three dimensional double vector Eigen::Vector3d of the Eigen library . using vertexType = Eigen :: Vector3d ; std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , -3.0 }); // 0 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , -3.0 }); // 1 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , -3.0 }); // 2 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , -3.0 }); // 3 verticesVec . emplace_back ( vertexType { 0.0 , 0.0 , 3.0 }); // 4 verticesVec . emplace_back ( vertexType { 2.0 , 0.0 , 3.0 }); // 5 verticesVec . emplace_back ( vertexType { 0.0 , 2.0 , 3.0 }); // 6 verticesVec . emplace_back ( vertexType { 2.0 , 2.0 , 3.0 }); // 7 verticesVec . emplace_back ( vertexType { 4.0 , 0.0 , 3.0 }); // 8 In the following we use the first functionality of the gridfactory which is the insertVertex() function which allows to insert vertices into grid for ( auto && vert : verticesVec ) gridFactory . insertVertex ( vert ); Grid containing a hexahedron and a tetrahedron. In red the vertices are shown. The grid shows a non-conforming mesh.","title":"SimpleGrid example"},{"location":"grid/#interfaces","text":"","title":"Interfaces"},{"location":"grid/#grid-factory","text":"","title":"Grid factory"},{"location":"grid/#grid","text":"The grid itself does not have a particular interface, except that it has to provide function to return a grid view. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl )","title":"Grid"},{"location":"grid/#grid-entities","text":"To stay compatible with Dune::GridEntities we provide a subset of the interface for the grid entities. Furthermore, we demand that they need to provide a unique identitfier. // Return a unique id of this entity size_t getID (); // The refinement level to which the entity belongs int level (); // Geometric realization of this entity, see GeometryType geometry (); // The type of the entity, e.g. line, vertex, quadrilateral,... Dune :: GeometryType type (); // Number of subentities, e.g. a line has two vertices unsigned int subEntities (); For the interface of GeometryType see Geometry . Warning It is tempting to attach any physical meaning to the grid entities. Nevertheless, the only purpose of the grid and grid entities is to provide the connectivity between different grid entities and an unique identifier to construct later on degrees of freedom indices from it.","title":"Grid entities"},{"location":"grid/#formula-test","text":"\\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\]","title":"Formula test"},{"location":"installation/","text":"Installation of Ikarus \u00b6 This installation guide is tested on Windows. Get a working C++ environment \u00b6 CLion needs to be installed on your computer. Download MinGW with GCC 11 (C++ compiler) from Winlibs . Choose GCC 11.1.0 + LLVM/Clang/LLD/LLDB 12.0.0 + MinGW-w64 9.0.0 - release 2 Win64. 7-zip or zip makes no difference Unpack it in any location of your choice Tell CLion to use the recently downloaded GCC. In CLion Go to File --> Settings --> Build, Execution, Deployment --> Toolchains In the field Environment , copy the path where you unpacked the download e.g. C:\\myFolder\\mySubFolder\\mingw64 CLion should now detect CMake, the compilers and the debugger Clone Ikarus \u00b6 Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below Further reading: \u00b6 As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Installation"},{"location":"installation/#installation-of-ikarus","text":"This installation guide is tested on Windows.","title":"Installation of Ikarus"},{"location":"installation/#get-a-working-c-environment","text":"CLion needs to be installed on your computer. Download MinGW with GCC 11 (C++ compiler) from Winlibs . Choose GCC 11.1.0 + LLVM/Clang/LLD/LLDB 12.0.0 + MinGW-w64 9.0.0 - release 2 Win64. 7-zip or zip makes no difference Unpack it in any location of your choice Tell CLion to use the recently downloaded GCC. In CLion Go to File --> Settings --> Build, Execution, Deployment --> Toolchains In the field Environment , copy the path where you unpacked the download e.g. C:\\myFolder\\mySubFolder\\mingw64 CLion should now detect CMake, the compilers and the debugger","title":"Get a working C++ environment"},{"location":"installation/#clone-ikarus","text":"Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below","title":"Clone Ikarus"},{"location":"installation/#further-reading","text":"As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Further reading:"},{"location":"tutorials/","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"tutorials/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"tutorials/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"tutorials/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"}]}
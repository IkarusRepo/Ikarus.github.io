{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6","title":"Home"},{"location":"#welcome-to-mkdocs","text":"","title":"Welcome to MkDocs"},{"location":"download/","text":"Installation of Ikarus \u00b6 Install in WSL on Windows \u00b6 In the windows powershell as admin Install VM-platform feature ind Windows-Features wsl --install wsl --set-default-version 2 #(Is not needed for Windows 11) Reboot Install debian \u00b6 Install from WindowsAppStore Execute the debian app Give yourself a username and password Execute sudo sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list Execute sudo apt update && \\ sudo apt full-upgrade -y && \\ sudo apt -y install lsb-release && \\ sudo apt -y install build-essential \\ libssl-dev \\ git \\ wget \\ apt-utils \\ software-properties-common \\ gfortran \\ gcc-11 \\ g++-11 \\ gcovr \\ clang \\ libmetis-dev \\ clang-tidy \\ libclang-13-dev \\ clang-format-13 \\ libc++-13-dev \\ libc++abi-13-dev \\ llvm-13-dev \\ liblapack-dev \\ libopenblas-dev \\ libsuitesparse-dev \\ libdune-common-dev \\ libdune-geometry-dev \\ libdune-grid-dev \\ libdune-functions-dev \\ libdune-typetree-dev \\ libdune-localfunctions-dev \\ libdune-uggrid-dev \\ libdune-grid-glue-dev \\ libdune-istl-dev \\ libspdlog-dev \\ libbenchmark-dev \\ libgtest-dev \\ gnuplot \\ python3 \\ pip \\ clang-format-12 \\ gnuplot-x11 \\ curl \\ cppcheck && \\ sudo apt-get install libayatana-appindicator3-1 -y && \\ sudo apt-get -y -f install && \\ sudo apt install libasound2 xvfb -y && \\ wget https://github.com/jgraph/drawio-desktop/releases/download/v16.5.1/drawio-amd64-16.5.1.deb && \\ sudo dpkg -i drawio-amd64-16.5.1.deb && \\ pip install cmakelang == 0 .6.13 pyyaml && \\ pip install mkdocs && \\ pip install mkdocs-material && \\ pip install mkdocs-macros-plugin && \\ pip install mkdocs-drawio-exporter && \\ && \\ sudo cp /usr/bin/clang-format-12 /usr/bin/clang-format && \\ cd /usr/local/bin && \\ sudo ln -s $HOME /.local/bin/cmake-format cmake-format && \\ sudo ln -s $HOME /.local/bin/mkdocs mkdocs && \\ cd ~ && \\ mkdir -p iwyu && \\ cd iwyu && \\ git clone https://github.com/include-what-you-use/include-what-you-use.git && \\ cd include-what-you-use && \\ git checkout clang_13 && \\ cd .. && \\ mkdir -p build && cd build && \\ cmake -G \"Unix Makefiles\" -DIWYU_LLVM_ROOT_PATH = /usr/lib/llvm-13 ../include-what-you-use && \\ make && \\ sudo make install && \\ cd /usr/src/googletest && \\ cmake . && \\ sudo cmake --build . --target install && \\ cd ~ && \\ git clone https://gitlab.com/libeigen/eigen.git && \\ cd eigen && \\ git checkout 3 .4 && \\ mkdir build && \\ cd build && \\ cmake ../ && \\ sudo make install && \\ cd ~ && \\ rm -rf eigen && \\ git clone https://github.com/alandefreitas/matplotplusplus.git && \\ cd matplotplusplus && \\ mkdir -p build && \\ cd build && \\ cmake .. -DCMAKE_BUILD_TYPE = Release -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF && \\ cmake --build . --parallel 4 --config Release && \\ sudo cmake --install . && \\ cd ~ && \\ rm -rf matplotplusplus && \\ git clone https://github.com/autodiff/autodiff && \\ cd autodiff/ && \\ mkdir .build && \\ cd .build/ && \\ cmake .. -DAUTODIFF_BUILD_PYTHON = 0 -DAUTODIFF_BUILD_EXAMPLES = 0 -DAUTODIFF_BUILD_DOCS = 0 -DAUTODIFF_BUILD_TESTS = 0 && \\ sudo cmake --build . --target install && \\ cd ../.. && \\ mkdir -p dune && \\ cd dune && \\ git clone https://gitlab.dune-project.org/extensions/dune-alugrid.git && \\ git clone https://gitlab.dune-project.org/extensions/dune-foamgrid.git && \\ dunecontrol git checkout releases/2.8 && \\ git clone https://github.com/rath3t/dune-iga.git && \\ dunecontrol cmake \"-DCMAKE_BUILD_TYPE=Release\" && \\ dunecontrol make && \\ sudo dunecontrol make install && \\ cd .. && \\ rm -rf dune && \\ sudo apt-get auto-remove -y && \\ sudo apt-get clean wget https://raw.githubusercontent.com/JetBrains/clion-wsl/master/ubuntu_setup_env.sh && bash ubuntu_setup_env.sh In Clion setting: Build, Execution, Deployment \u2192 Toolchains Add with the + -sign a WSL configuration Make sure it is used as default (Move it up with the arrow buttons otherwise) Clone Ikarus \u00b6 Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below Further reading: \u00b6 As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Download"},{"location":"download/#installation-of-ikarus","text":"","title":"Installation of Ikarus"},{"location":"download/#install-in-wsl-on-windows","text":"In the windows powershell as admin Install VM-platform feature ind Windows-Features wsl --install wsl --set-default-version 2 #(Is not needed for Windows 11) Reboot","title":"Install in WSL on Windows"},{"location":"download/#install-debian","text":"Install from WindowsAppStore Execute the debian app Give yourself a username and password Execute sudo sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list Execute sudo apt update && \\ sudo apt full-upgrade -y && \\ sudo apt -y install lsb-release && \\ sudo apt -y install build-essential \\ libssl-dev \\ git \\ wget \\ apt-utils \\ software-properties-common \\ gfortran \\ gcc-11 \\ g++-11 \\ gcovr \\ clang \\ libmetis-dev \\ clang-tidy \\ libclang-13-dev \\ clang-format-13 \\ libc++-13-dev \\ libc++abi-13-dev \\ llvm-13-dev \\ liblapack-dev \\ libopenblas-dev \\ libsuitesparse-dev \\ libdune-common-dev \\ libdune-geometry-dev \\ libdune-grid-dev \\ libdune-functions-dev \\ libdune-typetree-dev \\ libdune-localfunctions-dev \\ libdune-uggrid-dev \\ libdune-grid-glue-dev \\ libdune-istl-dev \\ libspdlog-dev \\ libbenchmark-dev \\ libgtest-dev \\ gnuplot \\ python3 \\ pip \\ clang-format-12 \\ gnuplot-x11 \\ curl \\ cppcheck && \\ sudo apt-get install libayatana-appindicator3-1 -y && \\ sudo apt-get -y -f install && \\ sudo apt install libasound2 xvfb -y && \\ wget https://github.com/jgraph/drawio-desktop/releases/download/v16.5.1/drawio-amd64-16.5.1.deb && \\ sudo dpkg -i drawio-amd64-16.5.1.deb && \\ pip install cmakelang == 0 .6.13 pyyaml && \\ pip install mkdocs && \\ pip install mkdocs-material && \\ pip install mkdocs-macros-plugin && \\ pip install mkdocs-drawio-exporter && \\ && \\ sudo cp /usr/bin/clang-format-12 /usr/bin/clang-format && \\ cd /usr/local/bin && \\ sudo ln -s $HOME /.local/bin/cmake-format cmake-format && \\ sudo ln -s $HOME /.local/bin/mkdocs mkdocs && \\ cd ~ && \\ mkdir -p iwyu && \\ cd iwyu && \\ git clone https://github.com/include-what-you-use/include-what-you-use.git && \\ cd include-what-you-use && \\ git checkout clang_13 && \\ cd .. && \\ mkdir -p build && cd build && \\ cmake -G \"Unix Makefiles\" -DIWYU_LLVM_ROOT_PATH = /usr/lib/llvm-13 ../include-what-you-use && \\ make && \\ sudo make install && \\ cd /usr/src/googletest && \\ cmake . && \\ sudo cmake --build . --target install && \\ cd ~ && \\ git clone https://gitlab.com/libeigen/eigen.git && \\ cd eigen && \\ git checkout 3 .4 && \\ mkdir build && \\ cd build && \\ cmake ../ && \\ sudo make install && \\ cd ~ && \\ rm -rf eigen && \\ git clone https://github.com/alandefreitas/matplotplusplus.git && \\ cd matplotplusplus && \\ mkdir -p build && \\ cd build && \\ cmake .. -DCMAKE_BUILD_TYPE = Release -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF && \\ cmake --build . --parallel 4 --config Release && \\ sudo cmake --install . && \\ cd ~ && \\ rm -rf matplotplusplus && \\ git clone https://github.com/autodiff/autodiff && \\ cd autodiff/ && \\ mkdir .build && \\ cd .build/ && \\ cmake .. -DAUTODIFF_BUILD_PYTHON = 0 -DAUTODIFF_BUILD_EXAMPLES = 0 -DAUTODIFF_BUILD_DOCS = 0 -DAUTODIFF_BUILD_TESTS = 0 && \\ sudo cmake --build . --target install && \\ cd ../.. && \\ mkdir -p dune && \\ cd dune && \\ git clone https://gitlab.dune-project.org/extensions/dune-alugrid.git && \\ git clone https://gitlab.dune-project.org/extensions/dune-foamgrid.git && \\ dunecontrol git checkout releases/2.8 && \\ git clone https://github.com/rath3t/dune-iga.git && \\ dunecontrol cmake \"-DCMAKE_BUILD_TYPE=Release\" && \\ dunecontrol make && \\ sudo dunecontrol make install && \\ cd .. && \\ rm -rf dune && \\ sudo apt-get auto-remove -y && \\ sudo apt-get clean wget https://raw.githubusercontent.com/JetBrains/clion-wsl/master/ubuntu_setup_env.sh && bash ubuntu_setup_env.sh In Clion setting: Build, Execution, Deployment \u2192 Toolchains Add with the + -sign a WSL configuration Make sure it is used as default (Move it up with the arrow buttons otherwise)","title":"Install debian"},{"location":"download/#clone-ikarus","text":"Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below","title":"Clone Ikarus"},{"location":"download/#further-reading","text":"As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Further reading:"},{"location":"documentation/BuildTheDocumentationLocally/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the download page . Preview the documentation locally \u00b6 Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser You can edit the documentation in CLion. STRG + s saves the documentation and updates it in your browser window. Cancel the build process to stop the live preview","title":"Build the documentation locally"},{"location":"documentation/BuildTheDocumentationLocally/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"documentation/BuildTheDocumentationLocally/#prerequisites","text":"Ikarus cloned on your computer, see the download page .","title":"Prerequisites"},{"location":"documentation/BuildTheDocumentationLocally/#preview-the-documentation-locally","text":"Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser You can edit the documentation in CLion. STRG + s saves the documentation and updates it in your browser window. Cancel the build process to stop the live preview","title":"Preview the documentation locally"},{"location":"documentation/howToEdit/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the download page . Edit a page \u00b6 Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated Add a new page \u00b6 Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated Insert a latex formula \u00b6 $$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$ is compiled to \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\] Insert C++ code \u00b6 The C++ code: double complicatedCalculation ( double number , double anotherNumber ) { return number * anotherNumber ; }; How it needs to be written in markdown: ```cpp double complicatedCalculation(double number, double anotherNumber) { return number*anotherNumber; }; ``` Insert a table \u00b6 Look at the markdown file of this page to see how a table can be inserted. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl ) Insert a warning \u00b6 This should only be done in case it is really important: Warning Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.","title":"How to edit the documentation"},{"location":"documentation/howToEdit/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"documentation/howToEdit/#prerequisites","text":"Ikarus cloned on your computer, see the download page .","title":"Prerequisites"},{"location":"documentation/howToEdit/#edit-a-page","text":"Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Edit a page"},{"location":"documentation/howToEdit/#add-a-new-page","text":"Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Add a new page"},{"location":"documentation/howToEdit/#insert-a-latex-formula","text":"$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$ is compiled to \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]","title":"Insert a latex formula"},{"location":"documentation/howToEdit/#insert-c-code","text":"The C++ code: double complicatedCalculation ( double number , double anotherNumber ) { return number * anotherNumber ; }; How it needs to be written in markdown: ```cpp double complicatedCalculation(double number, double anotherNumber) { return number*anotherNumber; }; ```","title":"Insert C++ code"},{"location":"documentation/howToEdit/#insert-a-table","text":"Look at the markdown file of this page to see how a table can be inserted. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl )","title":"Insert a table"},{"location":"documentation/howToEdit/#insert-a-warning","text":"This should only be done in case it is really important: Warning Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.","title":"Insert a warning"},{"location":"examples/integrate_pi/","text":"This examples comes from /examples/src/tut_compute-pi0.cpp #include <numbers> #include <dune/alugrid/grid.hh> #include <dune/geometry/quadraturerules.hh> #include <dune/grid/io/file/vtk/vtkwriter.hh> #include <Eigen/Core> #include <Eigen/Dense> #include <ikarus/Grids/GridHelper/griddrawer.h> int main () { constexpr int gridDim = 2 ; // (1) using Grid = Dune :: ALUGrid < gridDim , 2 , Dune :: simplex , Dune :: conforming > ; auto grid = Dune :: GmshReader < Grid >:: read ( \"../../examples/src/testFiles/circleCoarse.msh\" , false ); auto gridView = grid -> leafGridView (); // (2) draw ( gridView ); /// Calculate area from volume function of elements double area1 = 0.0 ; for ( auto & element : elements ( gridView )) area1 += element . geometry (). volume (); /// Integrate function using integration rule on grid auto f = []( auto && global ) { return sqrt ( global [ 0 ] * global [ 0 ] + global [ 1 ] * global [ 1 ]); }; double area2 = 0.0 ; for ( auto & element : elements ( gridView )) { const auto & rule = Dune :: QuadratureRules < double , 2 >:: rule ( element . type (), 1 , Dune :: QuadratureType :: GaussLegendre ); for ( auto & gp : rule ) // area2 += element.geometry().integrationElement(gp.position()) * gp.weight(); area2 += f ( element . geometry (). global ( gp . position ())) * element . geometry (). integrationElement ( gp . position ()) * gp . weight (); // integrationElement --> JacobiDeterminant } std :: cout << area1 << \" \" << area2 << std :: endl ; /// Naive refinement of grid and compare calculated area to pi for ( int i = 0 ; i < 3 ; ++ i ) { area1 = 0.0 ; grid -> globalRefine ( 1 ); auto gridViewRefined = grid -> leafGridView (); std :: cout << \"This gridview contains: \" ; std :: cout << gridViewRefined . size ( 0 ) << \" elements\" << std :: endl ; draw ( gridViewRefined ); for ( auto & element : elements ( gridViewRefined )) { area1 += element . geometry (). volume (); } std :: cout << area1 << \" \" << std :: numbers :: pi << std :: endl ; } /// write element areas to vtk std :: vector < double > areas ; areas . resize ( gridView . size ( 0 )); auto & indexSet = gridView . indexSet (); for ( auto & ele : elements ( gridView )) areas [ indexSet . index ( ele )] = ele . geometry (). volume (); Dune :: VTKWriter vtkWriter ( gridView ); vtkWriter . addCellData ( areas , \"area\" , 1 ); vtkWriter . write ( \"TestGridEntitites\" ); /// Calculate circumference and compare to pi double circumference = 0.0 ; for ( auto & element : elements ( gridView )) if ( element . hasBoundaryIntersections ()) for ( auto & intersection : intersections ( gridView , element )) if ( intersection . boundary ()) circumference += intersection . geometry (). volume (); std :: cout << circumference << \" \" << std :: numbers :: pi << std :: endl ; } Create ALUGrid from gmsh file. Create leaf grid view of grid","title":"Integrate pi"},{"location":"theory/theoryFiniteElement/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Topics \u00b6 How is the geometry implemented","title":"Finite Elements"},{"location":"theory/theoryFiniteElement/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"theory/theoryFiniteElement/#topics","text":"How is the geometry implemented","title":"Topics"},{"location":"theory/theoryGeometry/","text":"Geometry type and description \u00b6 Geometry type \u00b6 Geometry description \u00b6 As described in the interface of the grid entity on the grid theory page , a grid entity has to be able to provide a geometry description, i.e. it has to return an object which satisfies the geometry interface described below. Geometry interface \u00b6 ToDo: description of the geometry interface Geometry implementation \u00b6 ToDo: description of the available implementations","title":"Geometry"},{"location":"theory/theoryGeometry/#geometry-type-and-description","text":"","title":"Geometry type and description"},{"location":"theory/theoryGeometry/#geometry-type","text":"","title":"Geometry type"},{"location":"theory/theoryGeometry/#geometry-description","text":"As described in the interface of the grid entity on the grid theory page , a grid entity has to be able to provide a geometry description, i.e. it has to return an object which satisfies the geometry interface described below.","title":"Geometry description"},{"location":"theory/theoryGeometry/#geometry-interface","text":"ToDo: description of the geometry interface","title":"Geometry interface"},{"location":"theory/theoryGeometry/#geometry-implementation","text":"ToDo: description of the available implementations","title":"Geometry implementation"},{"location":"theory/theoryGrid/","text":"Description of the grid \u00b6 In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. provide a unique identifier (element number) provide a description of the reference geometry (element shape in physical space, shape functions, etc.) provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . This page explains the relationship and the ideas behind everything that has to do with the grid. The relationship is visualized in the following diagram: On this page, we will go through it using the following example: Grid \u00b6 The grid is a collection of grid entities. In the example above, the grid consists of three surfaces, ten edges and eight vertices, i.e. it consists of 21 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job. Interface of the grid \u00b6 leafGridView() : returns a grid view , i.e. an object which can iterate over the grid. Available grid implementations \u00b6 SimpleGrid : Currently the only available grid implementation. To construct it, use SimpleGridFactory , as a grid view use SimpleGridView . It has the following capabilities : It is a template: SimpleGrid<dim,wdim> where dim is the dimension of the grid entities and wdim is the dimension of the world. Dimension of grid entity in this case means: dim=1: e.g. truss elements, beams (one element-internal coordinate xi exists) dim=2: e.g. plate elements (two element-internal coordinates xi and eta exist) dim=3: 3d elements All meaningful combinations up to three dimensions can be instantiated, e.g. truss elements (dim=1) in 2d (wdim=2) Different types of grid entities are supported in the same grid as long as they have the dimension specified by dim (for details on these types see TODO): dim=1: linearLine dim=2: linearTriangle, linearQuadrilateral dim=3: linearTetrahedron, pyramid, prism, linearHexahedron Some restrictions apply: You can't insert grid entities of different dimensions into the same SimpleGrid Other types than the ones mentioned above are not supported The world dimension is limited to 3. Grid entity \u00b6 A grid entity provides all information related to the element geometry. Interface of grid entity \u00b6 A grid entity has the following properties: geometry() : returns the geometrical realization, i.e. an object that satisfies the geometry interface. Further details about this interface and what the returned object is able to do can be found on the geometry theory page . type() : returns the geometrical type, e.g. it can be a vertex, a linear line defined by two point or a quadrilateral with linear edges. The difference between type() and geometry() is that type() only returns a name whereas geometry() returns an object with functionality. vertices(gridEntity) , edges(gridEntity) , surfaces(gridEntity) and volumes(gridEntity) : Each entity has sub-entities of lower dimension. In the example above, surface S1 has the following sub-entities: four edges (number 1,2,4,6) and four vertices (number 1,2,4,5). vertices(S1) returns a span of vertices. The other functions work similarly. entities(gridEntity, dimension) does the same as the functions above, i.e. entities(gridEntity, 0) does the same as vertices(gridEntity) . entities(gridEntity, 1) does the same as edges(gridEntity) . ... subEntities(codimension) returns the number of subentities. Codimension in this case is the dimension of the grid entity minus the dimension of the requested subentity. Example: The grid entity is a 3d volume. subEntities(1) returns the number of surfaces of this volume because codimension=1 means your query is about the subentities one dimension lower than the object itself. getID() : returns a unique identifier Implementation of grid entity \u00b6 There is currently one implementation of the GridEntity interface available, which is DefaultGridEntity . It is supposed to be used together with the grid implementation SimpleGrid . template < int griddim , int cogriddim , int wdim > class DefaultGridEntity { // ... }; It is based on three template parameters griddim (dimension of the grid), cogriddim (???) and wdim (dimension of the world). Grid factory \u00b6 To construct a grid, a grid factory can be used. To construct a grid, vertices and element definitions are inserted into the factory. The grid is then constructed by the createGrid() function. Interface of the grid factory \u00b6 insertVertex(Eigen::Vector<double, dimensionworld>) : Vertices are inserted as a Eigen::Vector of double. Its size is equal to the dimensions of the world (e.g. 2 if it is a 2d simulation etc.) insertElement(Ikarus::GeometryType type, std::span<size_t> vertices) : An element is defined by its geometrical type and the vertex numbers. For the ordering of the node numbers, see ToDo Implementation of grid factory \u00b6 SimpleGridFactory : Constructs a SimpleGrid . The same restrictions apply as stated above for SimpleGrid . Grid view \u00b6 Interface of grid view \u00b6 The interface of a grid view consists of four free functions. Each of them provides a span of certain grid objects: vertices(GridView) : returns a span of all vertices in this grid edges(GridView) : returns a span of all edges in this grid surfaces(GridView) : returns a span of all surfaces in this grid volumes(GridView) : returns a span of all volumes in this grid Implementation of grid view \u00b6 SimpleGridView : Provides iterators for SimpleGrid .","title":"Grid"},{"location":"theory/theoryGrid/#description-of-the-grid","text":"In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. provide a unique identifier (element number) provide a description of the reference geometry (element shape in physical space, shape functions, etc.) provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . This page explains the relationship and the ideas behind everything that has to do with the grid. The relationship is visualized in the following diagram: On this page, we will go through it using the following example:","title":"Description of the grid"},{"location":"theory/theoryGrid/#grid","text":"The grid is a collection of grid entities. In the example above, the grid consists of three surfaces, ten edges and eight vertices, i.e. it consists of 21 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job.","title":"Grid"},{"location":"theory/theoryGrid/#interface-of-the-grid","text":"leafGridView() : returns a grid view , i.e. an object which can iterate over the grid.","title":"Interface of the grid"},{"location":"theory/theoryGrid/#available-grid-implementations","text":"SimpleGrid : Currently the only available grid implementation. To construct it, use SimpleGridFactory , as a grid view use SimpleGridView . It has the following capabilities : It is a template: SimpleGrid<dim,wdim> where dim is the dimension of the grid entities and wdim is the dimension of the world. Dimension of grid entity in this case means: dim=1: e.g. truss elements, beams (one element-internal coordinate xi exists) dim=2: e.g. plate elements (two element-internal coordinates xi and eta exist) dim=3: 3d elements All meaningful combinations up to three dimensions can be instantiated, e.g. truss elements (dim=1) in 2d (wdim=2) Different types of grid entities are supported in the same grid as long as they have the dimension specified by dim (for details on these types see TODO): dim=1: linearLine dim=2: linearTriangle, linearQuadrilateral dim=3: linearTetrahedron, pyramid, prism, linearHexahedron Some restrictions apply: You can't insert grid entities of different dimensions into the same SimpleGrid Other types than the ones mentioned above are not supported The world dimension is limited to 3.","title":"Available grid implementations"},{"location":"theory/theoryGrid/#grid-entity","text":"A grid entity provides all information related to the element geometry.","title":"Grid entity"},{"location":"theory/theoryGrid/#interface-of-grid-entity","text":"A grid entity has the following properties: geometry() : returns the geometrical realization, i.e. an object that satisfies the geometry interface. Further details about this interface and what the returned object is able to do can be found on the geometry theory page . type() : returns the geometrical type, e.g. it can be a vertex, a linear line defined by two point or a quadrilateral with linear edges. The difference between type() and geometry() is that type() only returns a name whereas geometry() returns an object with functionality. vertices(gridEntity) , edges(gridEntity) , surfaces(gridEntity) and volumes(gridEntity) : Each entity has sub-entities of lower dimension. In the example above, surface S1 has the following sub-entities: four edges (number 1,2,4,6) and four vertices (number 1,2,4,5). vertices(S1) returns a span of vertices. The other functions work similarly. entities(gridEntity, dimension) does the same as the functions above, i.e. entities(gridEntity, 0) does the same as vertices(gridEntity) . entities(gridEntity, 1) does the same as edges(gridEntity) . ... subEntities(codimension) returns the number of subentities. Codimension in this case is the dimension of the grid entity minus the dimension of the requested subentity. Example: The grid entity is a 3d volume. subEntities(1) returns the number of surfaces of this volume because codimension=1 means your query is about the subentities one dimension lower than the object itself. getID() : returns a unique identifier","title":"Interface of grid entity"},{"location":"theory/theoryGrid/#implementation-of-grid-entity","text":"There is currently one implementation of the GridEntity interface available, which is DefaultGridEntity . It is supposed to be used together with the grid implementation SimpleGrid . template < int griddim , int cogriddim , int wdim > class DefaultGridEntity { // ... }; It is based on three template parameters griddim (dimension of the grid), cogriddim (???) and wdim (dimension of the world).","title":"Implementation of grid entity"},{"location":"theory/theoryGrid/#grid-factory","text":"To construct a grid, a grid factory can be used. To construct a grid, vertices and element definitions are inserted into the factory. The grid is then constructed by the createGrid() function.","title":"Grid factory"},{"location":"theory/theoryGrid/#interface-of-the-grid-factory","text":"insertVertex(Eigen::Vector<double, dimensionworld>) : Vertices are inserted as a Eigen::Vector of double. Its size is equal to the dimensions of the world (e.g. 2 if it is a 2d simulation etc.) insertElement(Ikarus::GeometryType type, std::span<size_t> vertices) : An element is defined by its geometrical type and the vertex numbers. For the ordering of the node numbers, see ToDo","title":"Interface of the grid factory"},{"location":"theory/theoryGrid/#implementation-of-grid-factory","text":"SimpleGridFactory : Constructs a SimpleGrid . The same restrictions apply as stated above for SimpleGrid .","title":"Implementation of grid factory"},{"location":"theory/theoryGrid/#grid-view","text":"","title":"Grid view"},{"location":"theory/theoryGrid/#interface-of-grid-view","text":"The interface of a grid view consists of four free functions. Each of them provides a span of certain grid objects: vertices(GridView) : returns a span of all vertices in this grid edges(GridView) : returns a span of all edges in this grid surfaces(GridView) : returns a span of all surfaces in this grid volumes(GridView) : returns a span of all volumes in this grid","title":"Interface of grid view"},{"location":"theory/theoryGrid/#implementation-of-grid-view","text":"SimpleGridView : Provides iterators for SimpleGrid .","title":"Implementation of grid view"},{"location":"theory/theoryOverview/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Seperation of interface and implementation \u00b6 On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car. Interface of a car \u00b6 Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then: brand() : a function which returns the brand as a string maxvelocity() : a function which returns the maximum velocity as a double This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above. Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double. Implementation of a car \u00b6 Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar . Summary \u00b6 Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface Member functions and free functions \u00b6 In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like brand(car) in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for MyCar then looks like this: std :: string brand ( MyCar carObject ) { return \"MyBrand\" ;} This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).","title":"Overview"},{"location":"theory/theoryOverview/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"theory/theoryOverview/#seperation-of-interface-and-implementation","text":"On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car.","title":"Seperation of interface and implementation"},{"location":"theory/theoryOverview/#interface-of-a-car","text":"Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then: brand() : a function which returns the brand as a string maxvelocity() : a function which returns the maximum velocity as a double This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above. Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double.","title":"Interface of a car"},{"location":"theory/theoryOverview/#implementation-of-a-car","text":"Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar .","title":"Implementation of a car"},{"location":"theory/theoryOverview/#summary","text":"Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface","title":"Summary"},{"location":"theory/theoryOverview/#member-functions-and-free-functions","text":"In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like brand(car) in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for MyCar then looks like this: std :: string brand ( MyCar carObject ) { return \"MyBrand\" ;} This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).","title":"Member functions and free functions"},{"location":"tutorials/tutGrid/","text":"Grid tutorials \u00b6 This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project . SimpleGrid \u00b6 This tutorial explains how to use SimpleGrid<dim,wdim> . SimpleGrid<dim,wdim> uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions.","title":"Grid"},{"location":"tutorials/tutGrid/#grid-tutorials","text":"This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project .","title":"Grid tutorials"},{"location":"tutorials/tutGrid/#simplegrid","text":"This tutorial explains how to use SimpleGrid<dim,wdim> . SimpleGrid<dim,wdim> uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions.","title":"SimpleGrid"},{"location":"tutorials/tutorialsOverview/","text":"Tutorials \u00b6 This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the underlying theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section . Topics \u00b6 To be added","title":"Overview"},{"location":"tutorials/tutorialsOverview/#tutorials","text":"This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the underlying theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section .","title":"Tutorials"},{"location":"tutorials/tutorialsOverview/#topics","text":"To be added","title":"Topics"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6","title":"Home"},{"location":"#welcome-to-mkdocs","text":"","title":"Welcome to MkDocs"},{"location":"BuildTheDocumentationLocally/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the installation page . On Windows: Make sure Python , Drawio and Git are installed on your computer. Admin rights are required for the installation, contact your admin if it's not installed. On Ubuntu: execute (one-by-one): sudo apt-get install git -y sudo apt-get install python3 -y wget https://github.com/jgraph/drawio-desktop/releases/download/v14.6.13/drawio-amd64-14.6.13.deb sudo apt-get install libappindicator3-1 sudo dpkg -i drawio-amd64-14.6.13.deb sudo apt-get -y -f install sudo apt install libasound2 xvfb Preview the documentation locally \u00b6 Execute (double-click) Ikarus/docs/BuildLocally/InstalldepsForDocBuild.sh Another window should open now which installs python packages. Wait until it closes itself. Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser Cancel the build process to stop the live preview","title":"Build the documentation locally"},{"location":"BuildTheDocumentationLocally/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"BuildTheDocumentationLocally/#prerequisites","text":"Ikarus cloned on your computer, see the installation page . On Windows: Make sure Python , Drawio and Git are installed on your computer. Admin rights are required for the installation, contact your admin if it's not installed. On Ubuntu: execute (one-by-one): sudo apt-get install git -y sudo apt-get install python3 -y wget https://github.com/jgraph/drawio-desktop/releases/download/v14.6.13/drawio-amd64-14.6.13.deb sudo apt-get install libappindicator3-1 sudo dpkg -i drawio-amd64-14.6.13.deb sudo apt-get -y -f install sudo apt install libasound2 xvfb","title":"Prerequisites"},{"location":"BuildTheDocumentationLocally/#preview-the-documentation-locally","text":"Execute (double-click) Ikarus/docs/BuildLocally/InstalldepsForDocBuild.sh Another window should open now which installs python packages. Wait until it closes itself. Changing cmake option: E.g. In Clion: Open File --> Settings --> Build,Execution,Deployment --> Cmake Add -DBUILD_DOCS=TRUE to your cmake options Choose target localSite and build it (click on the hammer) Click on this link Now you should see a live preview of the documentation in your browser Cancel the build process to stop the live preview","title":"Preview the documentation locally"},{"location":"howToEdit/","text":"How to edit this documentation \u00b6 Prerequisites \u00b6 Ikarus cloned on your computer, see the installation page . Edit a page \u00b6 Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated Add a new page \u00b6 Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated","title":"How to edit the documentation"},{"location":"howToEdit/#how-to-edit-this-documentation","text":"","title":"How to edit this documentation"},{"location":"howToEdit/#prerequisites","text":"Ikarus cloned on your computer, see the installation page .","title":"Prerequisites"},{"location":"howToEdit/#edit-a-page","text":"Open Ikarus in Clion go the folder docs\\website find the markdown file which corresponds to the page you want to edit Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text) Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Edit a page"},{"location":"howToEdit/#add-a-new-page","text":"Open Ikarus in Clion go the folder docs\\website and create a new markdown-File, e.g. MyAdditionalPage.md Open the file docs\\mkdocs.yml Find the navigation section which starts with # Navigation The navigation section describes the navigation on the left side of the website. Add MyAdditionalPage.md where you want it to appear Create a pull request Once the pull request is accepted, the website is automatically updated","title":"Add a new page"},{"location":"installation/","text":"Installation of Ikarus \u00b6 This installation guide is tested on Windows. Get a working C++ environment \u00b6 CLion needs to be installed on your computer. Download MinGW with GCC 11 (C++ compiler) from Winlibs . Choose GCC 11.1.0 + LLVM/Clang/LLD/LLDB 12.0.0 + MinGW-w64 9.0.0 - release 2 Win64. 7-zip or zip makes no difference Unpack it in any location of your choice Tell CLion to use the recently downloaded GCC. In CLion Go to File --> Settings --> Build, Execution, Deployment --> Toolchains In the field Environment , copy the path where you unpacked the download e.g. C:\\myFolder\\mySubFolder\\mingw64 CLion should now detect CMake, the compilers and the debugger Clone Ikarus \u00b6 Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below Further reading: \u00b6 As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Installation"},{"location":"installation/#installation-of-ikarus","text":"This installation guide is tested on Windows.","title":"Installation of Ikarus"},{"location":"installation/#get-a-working-c-environment","text":"CLion needs to be installed on your computer. Download MinGW with GCC 11 (C++ compiler) from Winlibs . Choose GCC 11.1.0 + LLVM/Clang/LLD/LLDB 12.0.0 + MinGW-w64 9.0.0 - release 2 Win64. 7-zip or zip makes no difference Unpack it in any location of your choice Tell CLion to use the recently downloaded GCC. In CLion Go to File --> Settings --> Build, Execution, Deployment --> Toolchains In the field Environment , copy the path where you unpacked the download e.g. C:\\myFolder\\mySubFolder\\mingw64 CLion should now detect CMake, the compilers and the debugger","title":"Get a working C++ environment"},{"location":"installation/#clone-ikarus","text":"Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken) ToDo: Describe here how to access it from Github.com Open the CMake tab CMake in the CLion footer: Click on Reload CMake project (refresh symbol) CMake now detects all required sources automatically. The output should look similar to the screenshot below","title":"Clone Ikarus"},{"location":"installation/#further-reading","text":"As the next step: We recommend to read the following pages: - ToDo - ToDo - ...","title":"Further reading:"},{"location":"theory/theoryFiniteElement/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Topics \u00b6 How is the geometry implemented","title":"Finite Elements"},{"location":"theory/theoryFiniteElement/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"theory/theoryFiniteElement/#topics","text":"How is the geometry implemented","title":"Topics"},{"location":"theory/theoryGeometry/","text":"Macro Rendering Error \u00b6 FileNotFoundError : [Errno 2] No such file or directory: '../src/include/ikarus/Geometries/GeometryType.cpp' Traceback (most recent call last): File \"/home/runner/.local/lib/python3.8/site-packages/mkdocs_macros/plugin.py\", line 434, in render return md_template.render(**page_variables) File \"/usr/lib/python3/dist-packages/jinja2/asyncsupport.py\", line 76, in render return original_render(self, *args, **kwargs) File \"/usr/lib/python3/dist-packages/jinja2/environment.py\", line 1008, in render return self.environment.handle_exception(exc_info, True) File \"/usr/lib/python3/dist-packages/jinja2/environment.py\", line 780, in handle_exception reraise(exc_type, exc_value, tb) File \"/usr/lib/python3/dist-packages/jinja2/_compat.py\", line 37, in reraise raise value.with_traceback(tb) File \"<template>\", line 4, in <module> File \"/home/runner/work/Ikarus/Ikarus/docs/mkdocs-macros.py\", line 29, in inputcpp return inputcode(filename, 'cpp', linenumbers, startline, endline) File \"/home/runner/work/Ikarus/Ikarus/docs/mkdocs-macros.py\", line 14, in inputcode f = open(filename, 'r') FileNotFoundError: [Errno 2] No such file or directory: '../src/include/ikarus/Geometries/GeometryType.cpp'","title":"Geometry"},{"location":"theory/theoryGeometry/#macro-rendering-error","text":"FileNotFoundError : [Errno 2] No such file or directory: '../src/include/ikarus/Geometries/GeometryType.cpp' Traceback (most recent call last): File \"/home/runner/.local/lib/python3.8/site-packages/mkdocs_macros/plugin.py\", line 434, in render return md_template.render(**page_variables) File \"/usr/lib/python3/dist-packages/jinja2/asyncsupport.py\", line 76, in render return original_render(self, *args, **kwargs) File \"/usr/lib/python3/dist-packages/jinja2/environment.py\", line 1008, in render return self.environment.handle_exception(exc_info, True) File \"/usr/lib/python3/dist-packages/jinja2/environment.py\", line 780, in handle_exception reraise(exc_type, exc_value, tb) File \"/usr/lib/python3/dist-packages/jinja2/_compat.py\", line 37, in reraise raise value.with_traceback(tb) File \"<template>\", line 4, in <module> File \"/home/runner/work/Ikarus/Ikarus/docs/mkdocs-macros.py\", line 29, in inputcpp return inputcode(filename, 'cpp', linenumbers, startline, endline) File \"/home/runner/work/Ikarus/Ikarus/docs/mkdocs-macros.py\", line 14, in inputcode f = open(filename, 'r') FileNotFoundError: [Errno 2] No such file or directory: '../src/include/ikarus/Geometries/GeometryType.cpp'","title":"Macro Rendering Error"},{"location":"theory/theoryGrid/","text":"Description of the grid \u00b6 In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. - provide a unique identifier (element number) - provide a description of the reference geometry (element shape in physical space, shape functions, etc.) - provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) - ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . The grid description will be explained using the following example Grid \u00b6 The grid is a collection of grid entities. In the example above, the grid consists of four surfaces, ten edges and eight vertices, i.e. it consists of 22 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job. Grid interface \u00b6 The grid only has to implement one function: leafGridView() which returns a grid view , i.e. an object which can iterate over the grid. Grid implementation \u00b6 There is currently one implementation which is SimpleGrid . ToDo: describe implementation details Grid entity \u00b6 A grid entity provides all information related to the element geometry. Interface of grid entity \u00b6 A grid entity has the following properties: - It has a certain geometrical type (see below) , e.g. it can be a vertex, a linear line defined by two point or a quadrilateral with linear edges. The type can be obtained by calling type() - It has sub-entities of lower dimension. In the example above, surface S1 has the following sub-entities: - four edges (1,2,4,6) - four vertices (1,2,4,5) The number of each of these sub-entities can be obtained from subEntities(codim) where codim means ??? - The subEntities itself can be accessed by ??? - It can provide a geometry description. By calling the geometry() function, an object is return which the geometry interface. Further details about this interface and what the returned object is able to do can be found on the geometry theory page . - It has an unique identifier, which can be obtained by calling the member funciton getID() - It knows its dimension (e.g. a line is 1D, a quadrilateral is 2D) which can be obtained from mydimension - It knows the dimension of the world it lives in, which can be obtained from dimensionworld . If it is a 1d truss element, it can tell whether it lives in a 1d, 2d or 3d space. - It knows its codimension , which is ??? - ToDo after refactoring this interface, complete the documentation. ToDo unify with UML diagram. concept GridEntity = requires ( GridEntityType gEntity , unsigned int codim ) { { gEntity . level () } -> std :: same_as < int > ; gEntity . geometry (); { gEntity . type () } -> std :: same_as < Ikarus :: GeometryType > ; { gEntity . subEntities ( codim ) } -> std :: same_as < unsigned int > ; GridEntityType :: codimension ; GridEntityType :: dimensionworld ; GridEntityType :: mydimension ; typename GridEntityType :: Geometry ; }; Implementation of grid entity \u00b6 There is currently one implementation of the GridEntity interface available, which is DefaultGridEntity . It is supposed to be used together with the grid implementation SimpleGrid . template < int griddim , int cogriddim , int wdim > class DefaultGridEntity { // ... }; It is based on three template parameters griddim (dimension of the grid), cogriddim (???) and wdim (dimension of the world). ToDo: How are the private quantities (e.g. entitiesFathers) constructed? Grid factory \u00b6 To construct a grid, a grid factory can be used. Interface of the grid factory \u00b6 ToDo: Discussion: grid factory is very specific for the grid which is constructed. Is an interface required? Implementation of grid factory \u00b6 There is currently one implementation of a grid factory which is SimpleGridFactory . It constructs a SimpleGrid . Grid view \u00b6 TODO Interface of grid view \u00b6 TODO Implementation of grid view \u00b6 TODO","title":"Grid"},{"location":"theory/theoryGrid/#description-of-the-grid","text":"In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g. - provide a unique identifier (element number) - provide a description of the reference geometry (element shape in physical space, shape functions, etc.) - provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.) - ... In the code, there is not one single class which performs all these tasks. Different tasks are performed by different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the description of the element geometry . Details on the implementation of physical quantities can be found here . The grid description will be explained using the following example","title":"Description of the grid"},{"location":"theory/theoryGrid/#grid","text":"The grid is a collection of grid entities. In the example above, the grid consists of four surfaces, ten edges and eight vertices, i.e. it consists of 22 grid entities. Since it is some work to construct all these quantities and their relations, there is the grid factory which does this job.","title":"Grid"},{"location":"theory/theoryGrid/#grid-interface","text":"The grid only has to implement one function: leafGridView() which returns a grid view , i.e. an object which can iterate over the grid.","title":"Grid interface"},{"location":"theory/theoryGrid/#grid-implementation","text":"There is currently one implementation which is SimpleGrid . ToDo: describe implementation details","title":"Grid implementation"},{"location":"theory/theoryGrid/#grid-entity","text":"A grid entity provides all information related to the element geometry.","title":"Grid entity"},{"location":"theory/theoryGrid/#interface-of-grid-entity","text":"A grid entity has the following properties: - It has a certain geometrical type (see below) , e.g. it can be a vertex, a linear line defined by two point or a quadrilateral with linear edges. The type can be obtained by calling type() - It has sub-entities of lower dimension. In the example above, surface S1 has the following sub-entities: - four edges (1,2,4,6) - four vertices (1,2,4,5) The number of each of these sub-entities can be obtained from subEntities(codim) where codim means ??? - The subEntities itself can be accessed by ??? - It can provide a geometry description. By calling the geometry() function, an object is return which the geometry interface. Further details about this interface and what the returned object is able to do can be found on the geometry theory page . - It has an unique identifier, which can be obtained by calling the member funciton getID() - It knows its dimension (e.g. a line is 1D, a quadrilateral is 2D) which can be obtained from mydimension - It knows the dimension of the world it lives in, which can be obtained from dimensionworld . If it is a 1d truss element, it can tell whether it lives in a 1d, 2d or 3d space. - It knows its codimension , which is ??? - ToDo after refactoring this interface, complete the documentation. ToDo unify with UML diagram. concept GridEntity = requires ( GridEntityType gEntity , unsigned int codim ) { { gEntity . level () } -> std :: same_as < int > ; gEntity . geometry (); { gEntity . type () } -> std :: same_as < Ikarus :: GeometryType > ; { gEntity . subEntities ( codim ) } -> std :: same_as < unsigned int > ; GridEntityType :: codimension ; GridEntityType :: dimensionworld ; GridEntityType :: mydimension ; typename GridEntityType :: Geometry ; };","title":"Interface of grid entity"},{"location":"theory/theoryGrid/#implementation-of-grid-entity","text":"There is currently one implementation of the GridEntity interface available, which is DefaultGridEntity . It is supposed to be used together with the grid implementation SimpleGrid . template < int griddim , int cogriddim , int wdim > class DefaultGridEntity { // ... }; It is based on three template parameters griddim (dimension of the grid), cogriddim (???) and wdim (dimension of the world). ToDo: How are the private quantities (e.g. entitiesFathers) constructed?","title":"Implementation of grid entity"},{"location":"theory/theoryGrid/#grid-factory","text":"To construct a grid, a grid factory can be used.","title":"Grid factory"},{"location":"theory/theoryGrid/#interface-of-the-grid-factory","text":"ToDo: Discussion: grid factory is very specific for the grid which is constructed. Is an interface required?","title":"Interface of the grid factory"},{"location":"theory/theoryGrid/#implementation-of-grid-factory","text":"There is currently one implementation of a grid factory which is SimpleGridFactory . It constructs a SimpleGrid .","title":"Implementation of grid factory"},{"location":"theory/theoryGrid/#grid-view","text":"TODO","title":"Grid view"},{"location":"theory/theoryGrid/#interface-of-grid-view","text":"TODO","title":"Interface of grid view"},{"location":"theory/theoryGrid/#implementation-of-grid-view","text":"TODO","title":"Implementation of grid view"},{"location":"theory/theoryOverview/","text":"Theoretical Background and Implementation Details \u00b6 This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section . Seperation of interface and implementation \u00b6 On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car. Interface of a car \u00b6 Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then (written as a C++20 concept): template < typename CarType > concept Car = requires ( CarType c ) { { c . brand () } -> std :: same_as < std :: string > ; { c . maxVelocity () } -> std :: same_as < double > ; }; Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double. Implementation of a car \u00b6 Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar . Summary \u00b6 Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface","title":"Overview"},{"location":"theory/theoryOverview/#theoretical-background-and-implementation-details","text":"This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the practical use of several aspects, visit the tutorial section .","title":"Theoretical Background and Implementation Details"},{"location":"theory/theoryOverview/#seperation-of-interface-and-implementation","text":"On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car.","title":"Seperation of interface and implementation"},{"location":"theory/theoryOverview/#interface-of-a-car","text":"Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then (written as a C++20 concept): template < typename CarType > concept Car = requires ( CarType c ) { { c . brand () } -> std :: same_as < std :: string > ; { c . maxVelocity () } -> std :: same_as < double > ; }; Everything that wants to be a car has to have a member function brand() which returns a string and a member function maxVeloctiy() which returns a double.","title":"Interface of a car"},{"location":"theory/theoryOverview/#implementation-of-a-car","text":"Let's now implement a car. class MyCar { public : std :: string brand () { return \"MyBrand\" ;} double maxVelocity () { double velocity ; // calculate maximum velocity with some complicated calculations return velocity ; } }; The class MyCar fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement class AnotherCar .","title":"Implementation of a car"},{"location":"theory/theoryOverview/#summary","text":"Interface: Defines a set of requirements Implementation: A specific class which fulfills the interface","title":"Summary"},{"location":"tutorials/tutGrid/","text":"Grid tutorials \u00b6 This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project . SimpleGrid \u00b6 There, exists a simple grid implementation called SimpleGrid<dim,wdim> . It can be used for up to three world space dimension and it provides an unstructured grid with arbitrary element types of the same dimension. It uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions. SimpleGrid example \u00b6 We go step by step through the following code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <dune/geometry/type.hh> #include <ikarus/Grids/GridHelper/griddrawer.h> #include <ikarus/Grids/SimpleGrid/SimpleGrid.h> int main () { using namespace Ikarus :: Grid ; SimpleGridFactory < 3 , 3 > gridFactory ; using vertexType = Eigen :: Vector3d ; std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( 0.0 , 0.0 , -3.0 ); // 0 verticesVec . emplace_back ( 2.0 , 0.0 , -3.0 ); // 1 verticesVec . emplace_back ( 0.0 , 2.0 , -3.0 ); // 2 verticesVec . emplace_back ( 2.0 , 2.0 , -3.0 ); // 3 verticesVec . emplace_back ( 0.0 , 0.0 , + 3.0 ); // 4 verticesVec . emplace_back ( 2.0 , 0.0 , + 3.0 ); // 5 verticesVec . emplace_back ( 0.0 , 2.0 , + 3.0 ); // 6 verticesVec . emplace_back ( 2.0 , 2.0 , + 3.0 ); // 7 verticesVec . emplace_back ( 4.0 , 0.0 , + 3.0 ); // 8 for ( auto && vert : verticesVec ) gridFactory . insertVertex ( vert ); std :: vector < size_t > elementIndices ; elementIndices . resize ( 8 ); elementIndices = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }; gridFactory . insertElement ( Ikarus :: GeometryType :: linearHexahedron , elementIndices ); elementIndices . resize ( 4 ); elementIndices = { 1 , 8 , 3 , 5 }; gridFactory . insertElement ( Ikarus :: GeometryType :: linearTetrahedron , elementIndices ); auto grid = gridFactory . createGrid (); auto gridView = grid . leafGridView (); draw ( gridView ); } First we choose, which grid type we want to create and fill with entities using the type alias Grid . using namespace Ikarus :: Grid ; SimpleGridFactory < 3 , 3 > gridFactory ; After this we create a factory for this type. using vertexType = Eigen :: Vector3d ; After that we fill a vector with nine vertex positions. The type of the vector of coordinates is the three dimensional double vector Eigen::Vector3d of the Eigen library . std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( 0.0 , 0.0 , -3.0 ); // 0 verticesVec . emplace_back ( 2.0 , 0.0 , -3.0 ); // 1 verticesVec . emplace_back ( 0.0 , 2.0 , -3.0 ); // 2 verticesVec . emplace_back ( 2.0 , 2.0 , -3.0 ); // 3 verticesVec . emplace_back ( 0.0 , 0.0 , + 3.0 ); // 4 verticesVec . emplace_back ( 2.0 , 0.0 , + 3.0 ); // 5 verticesVec . emplace_back ( 0.0 , 2.0 , + 3.0 ); // 6 verticesVec . emplace_back ( 2.0 , 2.0 , + 3.0 ); // 7 verticesVec . emplace_back ( 4.0 , 0.0 , + 3.0 ); // 8 for ( auto && vert : verticesVec ) In the following we use the first functionality of the gridfactory which is the insertVertex() function which allows to insert vertices into grid gridFactory . insertVertex ( vert ); Grid containing a hexahedron and a tetrahedron. In red the vertices are shown. The grid shows a non-conforming mesh. Interfaces \u00b6 Grid factory \u00b6 Grid \u00b6 The grid itself does not have a particular interface, except that it has to provide function to return a grid view. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl ) Grid entities \u00b6 To stay compatible with Dune::GridEntities we provide a subset of the interface for the grid entities. Furthermore, we demand that they need to provide a unique identitfier. // Return a unique id of this entity size_t getID (); // The refinement level to which the entity belongs int level (); // Geometric realization of this entity, see GeometryType geometry (); // The type of the entity, e.g. line, vertex, quadrilateral,... Dune :: GeometryType type (); // Number of subentities, e.g. a line has two vertices unsigned int subEntities (); For the interface of GeometryType see Geometry . Warning It is tempting to attach any physical meaning to the grid entities. Nevertheless, the only purpose of the grid and grid entities is to provide the connectivity between different grid entities and an unique identifier to construct later on degrees of freedom indices from it. Formula test \u00b6 \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\]","title":"Grid"},{"location":"tutorials/tutGrid/#grid-tutorials","text":"This examples explains how to use and construct grids. The syntax and functionality is closely related to grid objects from the DUNE Numerics project .","title":"Grid tutorials"},{"location":"tutorials/tutGrid/#simplegrid","text":"There, exists a simple grid implementation called SimpleGrid<dim,wdim> . It can be used for up to three world space dimension and it provides an unstructured grid with arbitrary element types of the same dimension. It uses two mandatory non-type template integers. The first integer denotes the largest possible dimension of a GridEntity and the second integer denotes the embedding space of the grid. E.g. SimpleGrid<2,3> contains surfaces,edges,vertices living in three dimensions.","title":"SimpleGrid"},{"location":"tutorials/tutGrid/#simplegrid-example","text":"We go step by step through the following code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <dune/geometry/type.hh> #include <ikarus/Grids/GridHelper/griddrawer.h> #include <ikarus/Grids/SimpleGrid/SimpleGrid.h> int main () { using namespace Ikarus :: Grid ; SimpleGridFactory < 3 , 3 > gridFactory ; using vertexType = Eigen :: Vector3d ; std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( 0.0 , 0.0 , -3.0 ); // 0 verticesVec . emplace_back ( 2.0 , 0.0 , -3.0 ); // 1 verticesVec . emplace_back ( 0.0 , 2.0 , -3.0 ); // 2 verticesVec . emplace_back ( 2.0 , 2.0 , -3.0 ); // 3 verticesVec . emplace_back ( 0.0 , 0.0 , + 3.0 ); // 4 verticesVec . emplace_back ( 2.0 , 0.0 , + 3.0 ); // 5 verticesVec . emplace_back ( 0.0 , 2.0 , + 3.0 ); // 6 verticesVec . emplace_back ( 2.0 , 2.0 , + 3.0 ); // 7 verticesVec . emplace_back ( 4.0 , 0.0 , + 3.0 ); // 8 for ( auto && vert : verticesVec ) gridFactory . insertVertex ( vert ); std :: vector < size_t > elementIndices ; elementIndices . resize ( 8 ); elementIndices = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }; gridFactory . insertElement ( Ikarus :: GeometryType :: linearHexahedron , elementIndices ); elementIndices . resize ( 4 ); elementIndices = { 1 , 8 , 3 , 5 }; gridFactory . insertElement ( Ikarus :: GeometryType :: linearTetrahedron , elementIndices ); auto grid = gridFactory . createGrid (); auto gridView = grid . leafGridView (); draw ( gridView ); } First we choose, which grid type we want to create and fill with entities using the type alias Grid . using namespace Ikarus :: Grid ; SimpleGridFactory < 3 , 3 > gridFactory ; After this we create a factory for this type. using vertexType = Eigen :: Vector3d ; After that we fill a vector with nine vertex positions. The type of the vector of coordinates is the three dimensional double vector Eigen::Vector3d of the Eigen library . std :: vector < vertexType > verticesVec ; verticesVec . emplace_back ( 0.0 , 0.0 , -3.0 ); // 0 verticesVec . emplace_back ( 2.0 , 0.0 , -3.0 ); // 1 verticesVec . emplace_back ( 0.0 , 2.0 , -3.0 ); // 2 verticesVec . emplace_back ( 2.0 , 2.0 , -3.0 ); // 3 verticesVec . emplace_back ( 0.0 , 0.0 , + 3.0 ); // 4 verticesVec . emplace_back ( 2.0 , 0.0 , + 3.0 ); // 5 verticesVec . emplace_back ( 0.0 , 2.0 , + 3.0 ); // 6 verticesVec . emplace_back ( 2.0 , 2.0 , + 3.0 ); // 7 verticesVec . emplace_back ( 4.0 , 0.0 , + 3.0 ); // 8 for ( auto && vert : verticesVec ) In the following we use the first functionality of the gridfactory which is the insertVertex() function which allows to insert vertices into grid gridFactory . insertVertex ( vert ); Grid containing a hexahedron and a tetrahedron. In red the vertices are shown. The grid shows a non-conforming mesh.","title":"SimpleGrid example"},{"location":"tutorials/tutGrid/#interfaces","text":"","title":"Interfaces"},{"location":"tutorials/tutGrid/#grid-factory","text":"","title":"Grid factory"},{"location":"tutorials/tutGrid/#grid","text":"The grid itself does not have a particular interface, except that it has to provide function to return a grid view. Grid Entity Interface GridViewType leafGridView () GridViewType levelGridView ( int levl )","title":"Grid"},{"location":"tutorials/tutGrid/#grid-entities","text":"To stay compatible with Dune::GridEntities we provide a subset of the interface for the grid entities. Furthermore, we demand that they need to provide a unique identitfier. // Return a unique id of this entity size_t getID (); // The refinement level to which the entity belongs int level (); // Geometric realization of this entity, see GeometryType geometry (); // The type of the entity, e.g. line, vertex, quadrilateral,... Dune :: GeometryType type (); // Number of subentities, e.g. a line has two vertices unsigned int subEntities (); For the interface of GeometryType see Geometry . Warning It is tempting to attach any physical meaning to the grid entities. Nevertheless, the only purpose of the grid and grid entities is to provide the connectivity between different grid entities and an unique identifier to construct later on degrees of freedom indices from it.","title":"Grid entities"},{"location":"tutorials/tutGrid/#formula-test","text":"\\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\]","title":"Formula test"},{"location":"tutorials/tutorialsOverview/","text":"Tutorials \u00b6 This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the underlying theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section . Topics \u00b6 To be added","title":"Overview"},{"location":"tutorials/tutorialsOverview/#tutorials","text":"This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the underlying theory. of various parts of the code. It is dedicated to users who want to extend or modifiy the implemented functionality or who want to learn more about the underlying thoughts and theoretical aspects. If you are rather interested in the theoretical background and implementation details, visit the theory section .","title":"Tutorials"},{"location":"tutorials/tutorialsOverview/#topics","text":"To be added","title":"Topics"}]}
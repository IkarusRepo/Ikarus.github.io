{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"Home","text":"","location":""},{"title":"Welcome to the documentation of Ikarus","text":"<p>Ikarus is a finite element software originated at the Institute for Structural Mechanics at the university of Stuttgart.</p> <p>This project tries to provide an easy to read and an easy to use finite element framework. It is heavily inspired by the finite element software DUNE, the book DUNE \u2014 The Distributed and Unified Numerics Environment, deal.II and Kratos. Furthermore it directly used several modules from DUNE.</p> <p>We favor value semantics and readability.</p> <p>Concerning the design of CI and the documentation we were inspired by Autodiff  and Kratos.</p> <p>The documentation is build using Material for MkDocs.</p>","location":"#welcome-to-the-documentation-of-ikarus"},{"title":"Advanced Topics","text":"","location":"AdvancedTopics/"},{"title":"Advanced topics","text":"<p>The following topics are probably not relevant for your daily work, but you might need this knowledge at some point.</p>","location":"AdvancedTopics/#advanced-topics"},{"title":"Add additional dependencies or update existing dependencies to a newer version","text":"<p>All the dependencies of Ikarus are shipped in a docker container. The corresponding docker image is available at  https://github.com/ikarus-project/ikarus-docker-container. In order to modify the dependencies, you need to create a modified version of this dockerfile, create a new docker container and execute your code in this docker container (i.e. change the docker image to be used in the CLion settings).</p>","location":"AdvancedTopics/#add-additional-dependencies-or-update-existing-dependencies-to-a-newer-version"},{"title":"Code style","text":"","location":"codeStyle/"},{"title":"Code style","text":"<p>This section explains the theoretical background and implementation details of various parts of the code. It is dedicated to users who want to extend or modify the implemented functionality or who want to learn more about the implementation thoughts and theoretical aspects.</p> <ul> <li>The directories and filenames use <code>camelCase</code></li> <li>The source files have a <code>cpp</code> extension and the header files <code>hh</code>.</li> <li>We also use a <code>clang-format</code> file which needs to be executed in each file before a PR can be merged</li> <li>For comments in the code we follow:</li> </ul>  <p>Quote of Robert Martin in VideoLink<p>\"The proper use of comments is:    To compensate for our failure to express ourselves in code.\"</p> </p> <p>Thus, lots of comments should not be interpreted as good programming style but they should be sign as a failure to express ourselves. </p>","location":"codeStyle/#code-style"},{"title":"Programming style","text":"","location":"codeStyle/#programming-style"},{"title":"Separation of interface and implementation","text":"<p>On many of the theory pages you will find a description of an interface and a discussion of the implementation. What interface and implementation means is explained here with the example of a car.</p>","location":"codeStyle/#separation-of-interface-and-implementation"},{"title":"Interface of a car","text":"<p>Let's first define the interface of a car. A car is from a certain brand and it has a maximum velocity. The interface of a car is then:</p> <ul> <li><code>brand()</code>: a function which returns the brand as a string</li> <li><code>maxvelocity()</code>: a function which returns the maximum velocity as a double</li> </ul> <p>This can be written in a more formalized way, e.g. as a C++20 concept, but we currently write it in this documentation as shown above.</p> <p>Everything that wants to be a car has to have a member function <code>brand()</code> which returns a string and a member function <code>maxVeloctiy()</code> which returns a double.</p>","location":"codeStyle/#interface-of-a-car"},{"title":"Implementation of a car","text":"<p>Let's now implement a car. <pre><code>class MyCar\n{\n  public:\n  std::string brand() {return \"MyBrand\";}\n  double maxVelocity() \n  {\n    double velocity;\n    // calculate maximum velocity with some complicated calculations\n    return velocity;\n  }\n};\n</code></pre> The class <code>MyCar</code> fulfills the car interface and is a therefore considered a car. There can be many classes that fulfill the car interface, e.g. someone else could arrive and implement <code>class AnotherCar</code>.</p>","location":"codeStyle/#implementation-of-a-car"},{"title":"Summary","text":"<ul> <li>Interface: Defines a set of requirements</li> <li>Implementation: A specific class which fulfills the interface</li> </ul>","location":"codeStyle/#summary"},{"title":"Member functions and free functions","text":"<p>In this documentation, we also list free functions as a part of the interface. This is indicated by the arguments in the list of interface functions. An example: If there is something like</p> <ul> <li><code>brand(car)</code></li> </ul> <p>in the interface list, this means that there has to be a function which gets a car object as argument and returns the name of the brand. An implementation for <code>MyCar</code> then looks like this: <pre><code>std::string brand(MyCar carObject) {return \"MyBrand\";}\n</code></pre> This function is called a free function because it isn't part of the class MyCar but it is free (and could be defined in another file then the class MyCar).</p>","location":"codeStyle/#member-functions-and-free-functions"},{"title":"C++ recommendations","text":"","location":"cppRef/"},{"title":"C++ recommendations","text":"<p>As you may know by now Ikarus is written in C++. On this page we summerize recommendation to dig deeper into C++ coding.</p>","location":"cppRef/#c-recommendations"},{"title":"Should i write a member function or a free- function?","text":"<p>Scott Meyers recommends the following algorithm: Link</p>","location":"cppRef/#should-i-write-a-member-function-or-a-free-function"},{"title":"When to use const?","text":"<ol> <li>Arthur O'Dwyer blog</li> </ol>","location":"cppRef/#when-to-use-const"},{"title":"How should i pass my parameters to a function and return from a function?","text":"<ol> <li>Herb Sutter Cppcon Talk 2014</li> </ol>","location":"cppRef/#how-should-i-pass-my-parameters-to-a-function-and-return-from-a-function"},{"title":"Best practices","text":"<ol> <li>C++ Core Guidelines (A lot to learn there and you can just search some topic.)</li> <li>Jason Turner's collection of best practices</li> <li>More C++ idioms</li> </ol>","location":"cppRef/#best-practices"},{"title":"Further references","text":"<ol> <li>Cppcon Videos These videos are released after every conference. For beginners the Back to basics track can be recommended.</li> <li>Godblot Online compiler with assembler output. Nice to test fast if something would be fast or slow.  Also Eigen can be added. Also any other header found on the internet can be include with the link.</li> </ol>","location":"cppRef/#further-references"},{"title":"Videos","text":"<p>Here we collect useful videos on coding or coding c++:</p> <ul> <li>Clean Code - Uncle Bob / Lesson 1 How to write code cleanly, see also 1</li> <li>CppCon 2014: Herb Sutter \"Back to the Basics! Essentials of Modern C++ Style\"</li> <li>CppCon 2018: Jonathan Boccara \u201c105 STL Algorithms in Less Than an Hour\u201d \"Almost\" all algorithms in the STL</li> <li>Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019 How to do modern \"Object-Oriented Programming\" (If you really have to)</li> <li>[CppCon 2021 - Back To Basics] (https://www.youtube.com/watch?v=Bt3zcJZIalk&amp;list=PLHTh1InhhwT4TJaHBVWzvBOYhp27UO7mI)</li> <li>CppCon 2019 Back to Basics</li> </ul>","location":"cppRef/#videos"},{"title":"Books","text":"<p>2 3 4 5</p>   <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> </ol>","location":"cppRef/#books"},{"title":"Download","text":"","location":"download/"},{"title":"Installation of Ikarus","text":"<p>Change links on this website when final accounts for repository and docker container are fixed and remove this warning.</p>  <p>Graphical output is currently not supported on Windows 10 (but will probably be available in the future). Therefore, working on Windows 11 is recommended.</p> <p>The installations on Windows relies on WSL 2, i.e. although working with Windows, the code is compiled and executed in Linux.</p>","location":"download/#installation-of-ikarus"},{"title":"Installation on Windows using Docker Container","text":"<ol> <li>Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. <pre><code>wsl --install\nwsl --set-default-version 2 #(Is not needed for Windows 11)\n</code></pre></li> <li>Download and install Docker for Windows.   During the installation, select the option \"Install required Windows components for WSL 2\"</li> <li>Install debian from WindowsAppStore<ol> <li>Open the debian app</li> <li>Give yourself a username and password</li> <li>Close the debian app</li> </ol> </li> <li>Open the PowerShell and execute: <pre><code>wsl --list --all\n</code></pre> <code>Debian</code> should appear as one of the available Linux distributions.</li> <li>In the PowerShell execute: <pre><code>wsl --setdefault Debian\n</code></pre></li> <li>Try to start Docker. If it works, continue with the next step. If a message occurs that you are not allowed to use docker because     you are not in the docker user group, follow these instructions.     In short:<ol> <li>Open computer management as admin</li> <li>Go to Local users and groups and find docker-users</li> <li>Add your Account (or a group of which you are a member) to the group.</li> <li>Restart your computer</li> </ol> </li> <li>In Docker, go to Settings \u2192 General and select autostart for docker     (otherwise you have to start it manually each time you want to work with Ikarus).</li> <li> <p>In the Docker settings, select that Docker uses your WSL2 distribution Debian as shown in the picture.     </p> <p>In cases docker says that you don't have a WSL 2 distribution, go to the PowerShell and execute <pre><code>wsl --set-default-version 2 #(just to be sure that you didn't forgot this at the beginning)\nwsl --set-version Debian 2 #(Converts debian to version 2)\n</code></pre> You should now be able to change the docker settings according to the picture above.</p> </li> <li> <p>Open the PowerShell and execute: <pre><code>docker pull rath3t/ikarus-dev:latest #if you want to develop in Ikarus\ndocker pull rath3t/ikarus:latest #if you want to use Ikarus to run your own main file as in https://github.com/ikarus-project/ikarus-examples\n</code></pre></p> </li> <li>Download and install CLion. You need a version &gt;=2022.1.</li> <li>In CLion, go to File and Settings and apply the following settings for the toolchain:          Edit the Container settings and paste the following command into <code>Run options</code>: <pre><code>-e DISPLAY=:0 -v \\\\wsl$\\debian\\mnt\\wslg\\.X11-unix:/tmp/.X11-unix -v \\\\wsl$\\debian\\mnt\\wslg:/mnt/wslg --cap-add=SYS_PTRACE\n</code></pre></li> <li>Clone Ikarus</li> </ol>","location":"download/#installation-on-windows-using-docker-container"},{"title":"Clone Ikarus","text":"<ul> <li>Clone the Ikarus repository as you do it with any other repository (e.g. using GitKraken)</li> <li>ToDo: Describe here how to access it from Github.com</li> <li>Open the CMake tab <code>CMake</code> in the CLion footer:   </li> <li>Click on <code>Reload CMake project</code> (refresh symbol) </li> <li>CMake now detects all required sources automatically. The output should look similar to   the screenshot below   </li> </ul>","location":"download/#clone-ikarus"},{"title":"Installation on Windows using WSL","text":"<p>This installation procedure is not recommended</p> <p>The installation using Docker described above has several advantages and should be the standard. This section will be removed in the future</p>  <ol> <li>Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested.   <pre><code>wsl --install\nwsl --set-default-version 2 #(Is not needed for Windows 11)\n</code></pre></li> <li>Install debian from <code>.tar</code> file OR alternatively (3)   <pre><code>wsl --import debian &lt;install location&gt; debian_bookworm.tar\n</code></pre></li> <li>Install debian manually<ol> <li>Install from WindowsAppStore</li> <li>Open the debian app</li> <li>Give yourself a username and password</li> <li>Execute in debian <code>sudo sed -i 's/bullseye/bookworm/g' /etc/apt/sources.list</code></li> <li>Execute the following list of commands in debian   <pre><code>sudo apt update &amp;&amp; \\\nsudo apt full-upgrade -y &amp;&amp; \\\nsudo apt -y install lsb-release &amp;&amp; \\\nsudo apt -y install build-essential \\\nlibssl-dev \\\ngit \\\nwget \\\napt-utils \\\nsoftware-properties-common \\\ngfortran \\\ngcc-11 \\\ng++-11 \\\ngcovr \\\nclang \\\nlibmetis-dev \\\nclang-tidy \\\nlibclang-13-dev \\\nclang-format-13 \\\nlibc++-13-dev \\\nlibc++abi-13-dev \\\nllvm-13-dev \\\nliblapack-dev \\\nlibopenblas-dev \\\nlibsuitesparse-dev \\\nlibdune-common-dev \\\nlibdune-geometry-dev \\\nlibdune-grid-dev \\\nlibdune-functions-dev \\\nlibdune-typetree-dev \\\nlibdune-localfunctions-dev \\\nlibdune-uggrid-dev \\\nlibdune-grid-glue-dev \\\nlibdune-istl-dev \\\nlibspdlog-dev \\\nlibbenchmark-dev \\\nlibgtest-dev \\\ngnuplot \\\npython3 \\\npip \\\nclang-format-12 \\\ngnuplot-x11 \\\ncurl \\\ncppcheck &amp;&amp; \\\nsudo apt-get install libayatana-appindicator3-1 -y &amp;&amp; \\\nsudo apt-get -y -f install &amp;&amp; \\\nsudo apt install libasound2 xvfb -y &amp;&amp; \\\nwget https://github.com/jgraph/drawio-desktop/releases/download/v16.5.1/drawio-amd64-16.5.1.deb &amp;&amp; \\\nsudo dpkg -i drawio-amd64-16.5.1.deb &amp;&amp; \\\npip install cmakelang==0.6.13 pyyaml &amp;&amp; \\\npip install mkdocs &amp;&amp; \\\npip install mkdocs-material &amp;&amp; \\\npip install mkdocs-macros-plugin &amp;&amp; \\\npip install mkdocs-drawio-exporter &amp;&amp; \\ &amp;&amp; \\\nsudo cp /usr/bin/clang-format-12 /usr/bin/clang-format &amp;&amp; \\\ncd /usr/local/bin &amp;&amp; \\\nsudo ln -s $HOME/.local/bin/cmake-format cmake-format &amp;&amp; \\\nsudo ln -s $HOME/.local/bin/mkdocs mkdocs &amp;&amp; \\\ncd ~ &amp;&amp; \\\nmkdir -p iwyu &amp;&amp; \\\ncd iwyu &amp;&amp; \\\ngit clone https://github.com/include-what-you-use/include-what-you-use.git &amp;&amp; \\\ncd include-what-you-use &amp;&amp; \\\ngit checkout clang_13 &amp;&amp; \\\ncd .. &amp;&amp; \\\nmkdir -p build &amp;&amp; cd build &amp;&amp; \\\ncmake -G \"Unix Makefiles\" -DIWYU_LLVM_ROOT_PATH=/usr/lib/llvm-13 ../include-what-you-use &amp;&amp; \\\nmake &amp;&amp; \\\nsudo make install &amp;&amp; \\\ncd /usr/src/googletest &amp;&amp; \\\ncmake . &amp;&amp; \\\nsudo cmake --build . --target install &amp;&amp; \\\ncd ~ &amp;&amp; \\\ngit clone https://gitlab.com/libeigen/eigen.git &amp;&amp; \\\ncd eigen &amp;&amp; \\\ngit checkout 3.4 &amp;&amp; \\\nmkdir build &amp;&amp; \\\ncd build &amp;&amp; \\\ncmake ../ &amp;&amp; \\\nsudo make install &amp;&amp; \\\ncd ~ &amp;&amp; \\\nrm -rf eigen &amp;&amp; \\\ngit clone https://github.com/alandefreitas/matplotplusplus.git &amp;&amp; \\\ncd matplotplusplus &amp;&amp; \\\nmkdir -p build &amp;&amp; \\\ncd build &amp;&amp; \\\ncmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF &amp;&amp; \\\ncmake --build . --parallel 4 --config Release &amp;&amp; \\\nsudo cmake --install . &amp;&amp; \\\ncd ~ &amp;&amp; \\\nrm -rf matplotplusplus &amp;&amp; \\\ngit clone https://github.com/autodiff/autodiff &amp;&amp; \\\ncd autodiff/ &amp;&amp; \\\nmkdir .build &amp;&amp; \\\ncd .build/ &amp;&amp; \\\ncmake .. -DAUTODIFF_BUILD_PYTHON=0 -DAUTODIFF_BUILD_EXAMPLES=0 -DAUTODIFF_BUILD_DOCS=0 -DAUTODIFF_BUILD_TESTS=0 &amp;&amp; \\\nsudo cmake --build . --target install &amp;&amp; \\\ncd ../.. &amp;&amp; \\\nmkdir -p dune &amp;&amp; \\\ncd dune &amp;&amp; \\\ngit clone https://gitlab.dune-project.org/extensions/dune-alugrid.git &amp;&amp; \\\ngit clone https://gitlab.dune-project.org/extensions/dune-foamgrid.git &amp;&amp; \\\ndunecontrol git checkout releases/2.8 &amp;&amp; \\\ngit clone https://github.com/rath3t/dune-iga.git &amp;&amp; \\\ndunecontrol cmake \"-DCMAKE_BUILD_TYPE=Release\" &amp;&amp; \\\ndunecontrol make &amp;&amp; \\\nsudo dunecontrol make install &amp;&amp; \\\ncd .. &amp;&amp; \\\nrm -rf dune &amp;&amp; \\\nsudo apt-get auto-remove -y &amp;&amp; \\\nsudo apt-get clean\n</code></pre> <pre><code>wget https://raw.githubusercontent.com/JetBrains/clion-wsl/master/ubuntu_setup_env.sh &amp;&amp; bash ubuntu_setup_env.sh\n</code></pre></li> </ol> </li> <li>In Clion, go to File and Settings and apply the following settings for the toolchain:</li> <li>Build, Execution, Deployment \u2192 Toolchains: Add with the <code>+</code>-sign a WSL configuration</li> <li>Make sure it is used as defaultm i.e. it has to be the first item in the list. Move it up with the arrow buttons otherwise.</li> </ol>","location":"download/#installation-on-windows-using-wsl"},{"title":"Examples","text":"","location":"examples/"},{"title":"Examples","text":"<p>In order to understand several features of Ikarus, a set of examples are provided within the finite element framework. These can be found in IkarusExamples. The installation and execution  methodologies are briefly commented in the README file  of the repository. Each example is given a unique identification in the beginning of the file name of the form <code>iksXXX</code>. This unique identification is also used in the following instead of the complete <code>*.cpp</code> file name. The auxiliary files  to the examples like <code>*.msh</code>, <code>*.geo</code> or <code>*.parset</code> are available in <code>../../src/testFiles/</code>.  In order to add a new example, create a pull request with your executable file in the repository IkarusExamples and in  parallel update the documentation here, see How to contribute and  How to edit for more information. The available examples are described in the following.</p>","location":"examples/#examples"},{"title":"Cantilever beam with point load","text":"<p>The example <code>iks001_cantileverBeam_oneDGrid.cpp</code> shows a simple implementation of a one dimensional Timoshenko beam which is clamped on the left  hand side. A point load is applied on the right hand side of the beam. It uses <code>Dune::OneDGrid</code> to generate the required  grid. A simple implementation is shown here where the stiffness matrices are assembled explicitly. Advanced  implementations of matrix assembly and other features of Ikarus is showcased in the other examples.</p>","location":"examples/#cantilever-beam-with-point-load"},{"title":"Compute the value of \\(\\pi\\)","text":"<p>The examples <code>iks002_compute-pi.cpp</code> and <code>iks003_compute-pi.cpp</code>shows the calculation of \\(\\pi\\) by computing the area  and circumference of a unit circle. These examples help to understand the <code>Grid</code> module from Dune and the refinement techniques it  brings. The example <code>iks002</code> shows that a global refinement doesn't refine the number of grid entities on the boundary  of the circle, which leads to a poor approximation of \\(\\pi\\) while comparing with the circumference of the circle.  On the other hand, <code>iks003</code> shows how elements on the boundaries can be marked and refined, thereby resulting in an  accurate approximation of \\(\\pi\\).</p>","location":"examples/#compute-the-value-of-pi"},{"title":"Compression of an incompressible rubber block","text":"<p><code>iks004_incompressible_LinearElasticity.cpp</code> uses a finite element technology with displacement and pressure as  independent degrees of freedom to simulate the compression of an incompressible rubber block. The potential energy for such a system is defined in the  <code>calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code> function in <code>struct</code>  named <code>Solid</code>. This function uses the principles of automatic differentiation to provide the stiffness matrices and  other necessary quantities to provide a static structural analysis.   </p>","location":"examples/#compression-of-an-incompressible-rubber-block"},{"title":"Plate subjected to a surface load","text":"<p>Kirchhoff type plate element is implemented in <code>iks005_kirchhoff-plate.cpp</code> using the automatic differentiation  technique as commented before. The basis used for discretization is a NURBS basis from the <code>dune-iga</code> module. The problem is solved and convergence plots are created by comparing the solutions to available analytical solutions for  simply supported and clamped boundaries.</p>","location":"examples/#plate-subjected-to-a-surface-load"},{"title":"Newton-Raphson method","text":"<p><code>iks006_newtonRaphson.cpp</code> shows a basic example of the Newton-Raphson method to solve a non-linear set of equations.  A function which shows the algorithm explicitly is provided and another function which is implemented in Ikarus is  demonstrated. The function which depicts the Ikarus implementation uses a  non-linear operator to  perform the Newton-Raphson iterations. A logger can also be subscribed to in order to observe the residual norms,  for instance.</p>","location":"examples/#newton-raphson-method"},{"title":"Non-linear for 2D solids","text":"<p>Again, automatic differentiation based implementation is used to perform a non-linear analysis for a 2D block in  <code>iks007_nonlinear2Dsolid.cpp</code>. Various methods to obtain a 2D grid via Dune is also shown in the commented section in  the beginning. Python is used to provide a Neumann boundary condition providing a demonstration for the usage of a  Python-based code within the Ikarus framework. Load control method is chosen as the desired control routine and  Newton-Raphson (or Trust region methods) are used to solve the non-linear problem itself.</p>","location":"examples/#non-linear-for-2d-solids"},{"title":"Von-Mises stress calculation for truss systems","text":"<p><code>iks008_vonmises_truss.cpp</code> shows a way to use the tools and features mentioned in the previous examples to calculate  and post-process the Von-Mises stresses in truss systems.</p>","location":"examples/#von-mises-stress-calculation-for-truss-systems"},{"title":"Cook's membrane","text":"<p>The Cook's membrane problem adapted from the paper1 is implemented in examples <code>iks009_cook_membrane.cpp</code> and <code>iks010_cook_membrane_convergence.cpp</code>. This problem can be solved not only with structured meshes provided, but also with unstructured and triangular meshes. The input parameters like material and grid  parameters are read from the file <code>cook.parset</code>. The problem can be solved also with the standard planar solid element,  or with enhanced assumed strain elements. For more details on the element technologies, refer the  documentation. <code>iks009</code> solves the problem for a chosen  finite element type whereas <code>iks010</code> solves the problem with a set of existing finite elements and compares the  convergence rates. </p>   <ol> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> </ol>","location":"examples/#cooks-membrane"},{"title":"Open Tasks","text":"","location":"openTask/"},{"title":"Open tasks","text":"<p>Thanks for your interest in contributing to this code base. If your are interested the following task are vacant.</p>","location":"openTask/#open-tasks"},{"title":"Local functions","text":"<ul> <li> <p>Implementing a unit normal field function1 and its derivatives w.r.t. its coefficients \\( \\boldsymbol{x}_i \\)</p> \\[  \\boldsymbol{n} = \\frac{\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2}{||\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2||}, \\quad \\text{with } \\boldsymbol{a}_{\\alpha} = \\sum_{i=1}^n N^i_{,\\alpha}(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\] <p>To implement these see link.</p> </li> <li> <p>Support second derivatives</p> </li> <li>Add \\( \\operatorname{div} \\) and \\( \\operatorname{curl} \\) wrapper</li> </ul>","location":"openTask/#local-functions"},{"title":"Controlroutines","text":"<ul> <li>Dynamics (Explicit/ implicit time stepping)</li> </ul>","location":"openTask/#controlroutines"},{"title":"Controlroutines addons","text":"<ul> <li>Extended systems</li> <li>Inhomogeneous dirichlet boundary conditions wrapper class</li> </ul>","location":"openTask/#controlroutines-addons"},{"title":"Finite element helper","text":"<ul> <li>Implement default implemented mass matrix</li> </ul>","location":"openTask/#finite-element-helper"},{"title":"Finite elements","text":"<ul> <li>Nonlinear Reissner-Mindlin shell 2</li> <li>Kirchhoff-Love shell</li> <li>3D-Beam</li> <li>Implement forces and stiffness matrix of <code>NonLinearElasticityFE</code></li> </ul>","location":"openTask/#finite-elements"},{"title":"Local Basis","text":"<ul> <li>Support second derivatives</li> </ul>","location":"openTask/#local-basis"},{"title":"Addons","text":"<ul> <li>Add Python binding pybind11</li> <li>Add Muesli</li> </ul>  <p>Code style</p>  <p>For details on our code style we refer to Link.</p>   <ol> <li> <p>This is usually needed for a Kirchhoff-Love shell implementation, see 3.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> </ol>","location":"openTask/#addons"},{"title":"Assembler","text":"","location":"01_theory/assembler/"},{"title":"Assembler","text":"<p>The purpose of an assembler is to assemble global quantities (global stiffness matrix, global force vector, global energy, ...)  by looping over finite elements and composing the corresponding local structures to a global structure. This page describes the available assemblers and how they can be used.</p> <p>Each of the assemblers is constructed as follows: <pre><code>AssemblerName(const Basis&amp; basis, const FEContainer&amp; fes, const std::vector&lt;bool&gt;&amp; dirichFlags)\n</code></pre></p> <ul> <li><code>basis</code> is the basis that was used to construct the finite elements. ToDo add comment about FLAT.</li> <li><code>fes</code> is a container that contains all the finite elements that should be assembled</li> <li><code>dirichFlags</code> is of type <code>std::vector&lt;bool&gt;</code>. <code>dirichFlags[i] = true</code> means that degree of freedom i is fixed.      The corresponding row / column / entry will be eliminated when you ask for reduced matrix / vector. </li> </ul>","location":"01_theory/assembler/#assembler"},{"title":"FlatAssemblerBase","text":"<p>The FlatAssemblerBase is the basis for all assemblers currently available. All other Assemblers inherit from this assembler,  i.e. they have the functions listed below as well: <pre><code>size_t size() // (1)\nsize_t reducedSize() // (2)\nauto &amp;finiteElements() const // (3)\nEigen::VectorXd createFullVector(const Eigen::VectorXd &amp;reducedVector) // (4)\nsize_t constraintsBelow(size_t i) // (5)\nbool isConstrained(size_t i) // (6)\nsize_t estimateOfConnectivity() // (7)\n</code></pre></p> <ol> <li>Returns the number of degrees of freedom.</li> <li>Returns the number of degrees of freeedom, which are not constrained by a dirichlet boundary condition.</li> <li>Returns a reference to the finite element container that you gave to the assembler when constructing it.</li> <li>Gets a reduced vector and returns a full vector. Entries corresponding to fixed dofs are set to 0. Values of the other entries are     obtained from the reduced vector.</li> <li>Tells you how many of the degrees of freedom {0,1,...i-1} are fixed.</li> <li>Tells you if degree of freedom i is fixed</li> <li>Returns 8x the number of grid elements, which is an estimate for the connectivity. It can be used to allocate vectors.</li> </ol>","location":"01_theory/assembler/#flatassemblerbase"},{"title":"ScalarAssembler","text":"<p>It has the capabilities of FlatAssemblerBase plus one additional function: <pre><code>double&amp; getScalar(const RequirementType&amp; fErequirements)\n</code></pre> This assembler can be used when you are only interested in a scalar quantity and assembling of matrices or vectors is not relevant for you. The available requirements are explained on the FE requirements page. <code>dirichletFlags</code> is not used in this assembler.</p> <p>It assembles the requested scalar quantity. A call to this function could look as follows: <pre><code>ScalarAssembler myAssembler(...) // (1)\n// other code\nconst auto&amp; K = myAssembler.getScalar(energy) // (2)\n</code></pre></p> <ol> <li>This line represents the construction of the SparseFlatAssembler as explained above.</li> <li>To learn what alternatives for <code>energy</code> are available and how this works, read the FE requirements page.</li> </ol>","location":"01_theory/assembler/#scalarassembler"},{"title":"VectorFlatAssembler","text":"<p>It offers the functions of ScalarAssembler plus additionally <pre><code>Eigen::VectorXd&amp; getVector(const RequirementType&amp; fErequirements)\nEigen::VectorXd&amp; getReducedVector(const RequirementType&amp; fErequirements)\n</code></pre> As the name suggests, you can either get the full vector or the reduced vector where boundary conditions are considered. They work the same way as the scalar assembling functions of ScalarAssembler. The available requirements are explained on the FE requirements page.</p>","location":"01_theory/assembler/#vectorflatassembler"},{"title":"SparseFlatAssembler","text":"<p>It offers the functions of VectorFlatAssembler plus additionally <pre><code>Eigen::SparseMatrix&lt;double&gt; &amp;getMatrix(const RequirementType &amp;fErequirements)\nEigen::SparseMatrix&lt;double&gt; &amp;getReducedMatrix(const RequirementType &amp;fErequirements)\n</code></pre> A sparse matrix is returned. They work the same way as the vector assembling functions of VectorFlatAssembler. The available requirements are explained on the FE requirements page.</p>","location":"01_theory/assembler/#sparseflatassembler"},{"title":"DenseFlatAssembler","text":"<p>The only difference between the SparseFlatAssembler and the DenseFlatAssembler is that the DenseFlatAssembler returns a dense matrix. <pre><code>Eigen::MatrixXd &amp;getMatrix(const RequirementType &amp;fErequirements)\nEigen::MatrixXd &amp;getReducedMatrix(const RequirementType &amp;fErequirements)\n</code></pre></p>","location":"01_theory/assembler/#denseflatassembler"},{"title":"Control routines","text":"","location":"01_theory/controlRoutines/"},{"title":"Control routines","text":"","location":"01_theory/controlRoutines/#control-routines"},{"title":"Load control","text":"<p>A load control object is constructed as follows: <pre><code>auto lc = Ikarus::LoadControl(nonlinearSolver, numLoadSteps, {loadFactorStartValue, loadFactorEndValue});\n</code></pre> <code>nonlinearSolver</code> is a nonlinear Solver, e.g. Newton-Raphson. <code>numLoadSteps</code> is the number of load steps,  <code>loadFactorStartValue</code> is the value of the load factor at the beginning of the simulation (usually 0) and  <code>loadFactorEndValue</code> is the load factor at the end of the simulation.</p> <p>The load control is started with the <code>run()</code> method, i.e. in the example above: <pre><code>lc.run();\n</code></pre></p>","location":"01_theory/controlRoutines/#load-control"},{"title":"Obtaining infos from control routines","text":"<p>The load control is an observable object, i.e. you can subscribe to the messages of the load control. Read this page to learn more about the implementation of observer pattern in Ikarus. The following messages are available: <pre><code>enum class ControlMessages { \n  BEGIN,\n  CONTROL_STARTED,\n  CONTROL_ENDED,\n  STEP_STARTED,\n  STEP_ENDED,\n  SOLUTION_CHANGED,\n  END };\n</code></pre></p>","location":"01_theory/controlRoutines/#obtaining-infos-from-control-routines"},{"title":"Path following techniques","text":"<p>A general routine based on the standard Arc-length method is included which uses a scalar subsidiary function to impose  a constraint on the non-linear system of equations. The previously mentioned LoadControl method can also be recreated  using this technique. For more details on the standard arc-length method, refer the works  of Wempner1, Crisfield2, Ramm3 and  Riks4 among others. A path following object is constructed as follows: <pre><code>auto alc = Ikarus::PathFollowing(nr, load_steps, stepSize, pft);\n</code></pre> where <code>nr</code> is a Newton-Raphson solver which considers a scalar subsidiary function and is defined by <pre><code>auto nr = Ikarus::makeNewtonRaphsonWithSubsidiaryFunction(nonLinOp, std::move(linSolver));\n</code></pre> and <code>pft</code> is the desired path following technique. Three different path following techniques are included, namely</p> <ul> <li>Standard arc-length method</li> <li>Load control method (as a subsidiary function under this generalized implementation)</li> <li>Displacement control method (uses a vector of indices which are all controlled by a same <code>stepSize</code>).</li> </ul> <p>These can be invoked by defining  <pre><code>auto pft = Ikarus::StandardArcLength{};\nauto pft = Ikarus::LoadControlWithSubsidiaryFunction{};\nauto pft = Ikarus::DisplacementControl{controlledIndices};\n</code></pre> The default path following type is the <code>Ikarus::StandardArcLength{}</code>.</p> <p>It is to note that in the current implementation, it is assumed that the external forces are given by  \\(F_{ext} = F_{ext}^0\\lambda\\) such that  $$ -\\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = F_{ext}^0 $$ An implementation for a general non-linear \\(F_{ext} = F_{ext}^0\\left(\\mathbf{D},\\lambda\\right)\\) is an open task.</p> <p>In order to create an own implementation for the scalar subsidiary function, the user has to create a <code>struct</code>  with the following three member functions: <pre><code>void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args);\nvoid initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\nvoid intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\n</code></pre> The function <code>evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args)</code> is used to evaluate the subsidiary function and  its derivatives with respect to the displacement \\(\\mathbf{D}\\) and the load factor \\(\\lambda\\) for every Newton-Raphson iteration. The other two functions  are used to specify a prediction for \\(\\mathbf{D}\\) and \\(\\lambda\\) initially for the very first step and for  all the other intermediate subsequent <code>load_steps</code>.   </p> <p><code>SubsidiaryArgs</code> is a <code>struct</code> which is defined as <pre><code>struct SubsidiaryArgs {\n  double stepSize; // (1)\n  Eigen::VectorX&lt;double&gt; DD; // (2)\n  double Dlambda{}; // (3)\n  double f{}; // (4)\n  Eigen::VectorX&lt;double&gt; dfdDD; // (5)\n  double dfdDlambda{}; // (6)\n};\n</code></pre></p> <ol> <li>User-desired step size</li> <li>Vector of displacement increments</li> <li>Increment in the load factor</li> <li>Scalar value evaluated from the subsidiary function</li> <li>Derivative of the subsidiary function with respect to the displacement increment</li> <li>Derivative of the subsidiary function with respect to the load factor increment</li> </ol> <p>An example for the standard arc-length method is shown below: <pre><code>struct StandardArcLength {\n    void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const {\n      if (psi) {\n        const auto root = sqrt(args.DD.squaredNorm() + psi.value() * psi.value() * args.Dlambda * args.Dlambda);\n        args.f          = root - args.stepSize;\n        args.dfdDD      = args.DD / root;\n        args.dfdDlambda = (psi.value() * psi.value() * args.Dlambda) / root;\n      } else\n        DUNE_THROW(Dune::InvalidStateException,\n                   \"You have to call initialPrediction first. Otherwise psi is not defined\");\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      auto linearSolver\n          = Ikarus::ILinearSolver&lt;double&gt;(Ikarus::SolverTypeTag::d_LDLT);  // for the linear predictor step\n\n      nonLinearOperator.lastParameter() = 1.0;  // lambda =1.0\n\n      nonLinearOperator.template update&lt;0&gt;();\n      const auto&amp; R = nonLinearOperator.value();\n      const auto&amp; K = nonLinearOperator.derivative();\n\n      linearSolver.factorize(K);\n      linearSolver.solve(args.DD, -R);\n\n      const auto DD2 = args.DD.squaredNorm();\n\n      psi    = sqrt(DD2);\n      auto s = sqrt(psi.value() * psi.value() + DD2);\n\n      args.DD      = args.DD * args.stepSize / s;\n      args.Dlambda = args.stepSize / s;\n\n      nonLinearOperator.firstParameter() = args.DD;\n      nonLinearOperator.lastParameter()  = args.Dlambda;\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      nonLinearOperator.firstParameter() += args.DD;\n      nonLinearOperator.lastParameter() += args.Dlambda;\n    }\n\n    std::string name = \"Arc length\";\n\n  private:\n    std::optional&lt;double&gt; psi;\n  };\n</code></pre></p>   <ol> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/controlRoutines/#path-following-techniques"},{"title":"Dirichlet values","text":"","location":"01_theory/dirichletValues/"},{"title":"Dirichlet values","text":"","location":"01_theory/dirichletValues/#dirichlet-values"},{"title":"Introduction","text":"<p>In finite element problems it is essential to incorporate Dirichlet boundary condition, i.e. fixing part of the solution to some precribed value. Let's assume we have a problem as</p> <p>$$  \\boldsymbol{u} = \\boldsymbol{g} \\quad \\text{on } \\Gamma_\\mathrm{D}. $$ Here \\(  \\boldsymbol{u} \\) is our solution field and \\(\\boldsymbol{g}\\) is the prescription of it on the Dirichlet boundary \\(\\Gamma_\\mathrm{D}\\).</p> <p>For the discrete algebraic problem this translates to fixing the values of \\(u_i\\) to some value where \\(  \\boldsymbol{u}^h = \\sum_i N^i u_i \\), where \\(  N^i \\) is the \\(i\\)-th ansatz function and \\(u_i\\) is the solution value at node \\(i\\).</p> <p>The insertion of several functions \\(\\boldsymbol{g}\\) is done in the class <code>Ikarus::DirichletValues</code>.</p>","location":"01_theory/dirichletValues/#introduction"},{"title":"Interface","text":"<p>The interface of the <code>Ikarus::DirichletValues</code> is represented by the following code snippet. <pre><code>Ikarus::DirichletValues dirichletValues2(basis); // (1)\nvoid fixBoundaryDOFs(f); // (2)\nvoid fixDOFs(f); // (3)\nconst auto&amp; basis() const; // (4)\nbool isConstrained(std::size_t i) const; // (5)\nauto fixedDOFsize() const; // (6)\nauto size() const ; // (7) \n</code></pre></p> <ol> <li>Create class by inserting a global basis</li> <li>Accepts functor to fix boundary degrees of freedom. \"f\" is  a functor that will be called with the boolean vector of fixed boundary  degrees of freedom and the usual arguments of <code>Dune::Functions::forEachBoundaryDOF</code>, see Dune book page 388</li> <li>The more general version of <code>fixBoundaryDOFs</code>. Here the user should provide a functor that accepts a basis and the correspondign dirichlet degrees of freedom boolean vector</li> <li>Returns the underlying basis</li> <li>Indicates, if a passed degree of freedom is fixed</li> <li>Returns the number of fixed scalar values</li> <li>Returns the number of all dirichlet degrees of freedom</li> </ol>","location":"01_theory/dirichletValues/#interface"},{"title":"FE requirements","text":"","location":"01_theory/feRequirements/"},{"title":"FE requirements","text":"<p>Finite element requirements are a simple way to communicate your needs and expectations from a finite element.</p> <p>FE requirements are used to pass information from assemblers to finite elements. </p>","location":"01_theory/feRequirements/#fe-requirements"},{"title":"Construction","text":"<p>Usually the construction is as follows. <pre><code>FErequirements req = FErequirementsBuilder()\n                           .insertGlobalSolution(FESolutions::displacement, d)\n                           .insertParameter(FEParameter::loadfactor, lambda)\n                           .addAffordance(MatrixAffordances::stiffness)\n                           .build();\nMatrixType A = sparseFlatAssembler.getReducedMatrix(req);\n</code></pre></p> <p>As you can see to construct requirements we used the builder pattern1.</p> <p>Thus to construct <code>FErequirements</code> you create a <code>FErequirementsBuilder</code>. You can then chain your requirements together.</p> <p>You can insert solution from your finite element solution algorithm as in line 2. There, the type of the soultion is passed with the enum type  <code>FESolutions::displacement</code> with the vector <code>d</code>. This stores a reference to the vector.</p> <p>Additionally, if you have some parameters you want to pass you can call the method <code>insertParameter</code> as in line 3, where similar as for the  global solutions a enum <code>FEParameter::loadfactor</code> is passed to indicate the meaning of the parameter and after this the value is passed.</p> <p>Finally there is the method <code>addAffordance</code> which is used to indicate your request what you want from the finite element. Thus, there are scalar, vector and matrix affordances.</p> <p>The method <code>build()</code> constructs at the end the concrete object.</p> <p>Currently, the following feSolutions, fe Parameter and affordances are defined:</p> <pre><code>    noAffordance,\n    stiffness,\n    materialstiffness,\n    geometricstiffness,\n    stiffnessdiffBucklingVector,\n    microMagneticHessian,\n    mass\n  };\n\n  enum class FEParameter {\n    noParameter,\n    loadfactor,\n    time\n  };\n\n  enum class FESolutions {\n    noSolution,\n    displacement,\n    velocity,\n    director,\n    magnetizationAndVectorPotential\n  };\n\n\n  enum class ResultType {\n    noType,\n    magnetization,\n    gradientNormOfMagnetization,\n    vectorPotential,\n    divergenceOfVectorPotential,\n    BField,\n    HField,\n    cauchyStress,\n    director\n  };\n  // clang-format on\n  std::string getResultType(const ResultType &amp;res);\n\n  struct AffordanceCollectionImpl {\n    ScalarAffordances scalarAffordances{ScalarAffordances::noAffordance};\n</code></pre>","location":"01_theory/feRequirements/#construction"},{"title":"Usage","text":"<p>Inside the finite element the information can than be conveniently extracted: <pre><code>const auto&amp; d      = req.getGlobalSolution(FESolutions::displacement);\nconst auto&amp; lambda = req.getParameter(FEParameter::loadfactor);\nif(req.hasAffordance(stiffness))\n  ...\n</code></pre>  and with this you can develop your local finite element.</p>  <p>Affordance<p>It is good style to indicate that you cannot fulfill an affordance by throwing an appropriate exception!</p> </p>","location":"01_theory/feRequirements/#usage"},{"title":"FE result requirements","text":"<p>Additionally, to the upper finite element requirements there are result requirements.  They have the same methods as finite element requirements but add additional ones. They are used for the <code>calculateAt</code> method of finite elements. They are a way to communicate the requested results to the finite elements.</p>","location":"01_theory/feRequirements/#fe-result-requirements"},{"title":"Construction","text":"<p>Similar to above the construction is as follows: <pre><code>ResultRequirements resultRequirements = Ikarus::ResultRequirementsBuilder()\n        .insertGlobalSolution(FESolutions::displacement, d)\n        .insertParameter(FEParameter::loadfactor, lambda)\n        .addResultRequest(ResultType::cauchyStress,,ResultType::director).build();\n</code></pre></p> <p>The current supported results are</p> <pre><code>  };\n\n\n  enum class ResultType {\n    noType,\n    magnetization,\n    gradientNormOfMagnetization,\n    vectorPotential,\n    divergenceOfVectorPotential,\n    BField,\n</code></pre>","location":"01_theory/feRequirements/#construction_1"},{"title":"Usage","text":"<p>To extract the needed information result requirements have the same interface as finite element requirements. But they allow to query information which hresults should be calculated.</p> <pre><code>if( req.isResultRequested( ResultType::cauchyStress)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::BField)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::director)) {\n  ...\n}\n</code></pre>   <ol> <li> <p>Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/feRequirements/#usage_1"},{"title":"Finite Elements","text":"","location":"01_theory/finiteElements/"},{"title":"Finite elements","text":"<p>Several disciplines associate to finite elements different meanings. In Ikarus finite elements have two different tasks. The first one is to provide the evaluation of scalars, vectors and matrices.  These are associated to an algebraic representation of discrete energies, weak forms or bilinear forms These algebraic objects are usually constructed using some combination of local function and  parameters steeming from the underlying physical problem, e.g. load factor, Young's modulus or viscocity.</p> <p>The second task of finite elements is to evaluate derived results in the element parameter space. E.g. stresses or geometric quantities. This boils down to the following interface.</p>","location":"01_theory/finiteElements/#finite-elements"},{"title":"Interface","text":"<p>Local functions provide the following interface <pre><code>ScalarType evaluateScalar(const FErequirements&amp; req);\nvoid evaluateVector(const FErequirements&amp; req, VectorType&amp; b);\nvoid evaluateMatrix(const FErequirements&amp; req, MatrixType&amp; A);\nvoid calculateLocalSystem(const FErequirements&amp; req, MatrixType&amp; A, VectorType&amp; b);\nvoid calculateAt(const Resultrequirements&amp; req, const Eigen::Vector&lt;double, Traits::mydim&gt;&amp; local,\n                     ResultTypeMap&lt;ScalarType&gt;&amp; result);\nvoid globalIndices(std::vector&lt;GlobalIndex&gt;&amp; globalIndices);\n</code></pre></p> <p>To discuss these methods first finite element requirements and result requirements should be learned, see fe requirements. The first four methods receive an object of type <code>FErequirements</code>. This object is responsible for passing different information needed for the local evaluation of the local linear algebra objects. The first method <code>evaluateScalar</code> simply returns by values since usually this is cheap to return a <code>double</code>. The other methods <code>evaluateVector</code>, <code>evaluateMatrix</code> and <code>calculateLocalSystem</code> receive one or two  output argument where the result should be written. This interface is needed to circumvent the dynamic memory allocation, if these methods would return by value.</p> <p>The method <code>calculateAt</code> is responable to evaluate several results and it receives a <code>ResultRequirements</code> object which contains information which results should be evaluated. These results are stored inside the output argument <code>result</code> which is of type <code>ResultTypeMap</code>. Additionally there is the argument 'local' which stores the coordinates where inside the element coordinates the result should be evaluated.</p> <p>Inside a typical <code>calculateAt</code> method the usage is </p> <pre><code>typename ResultTypeMap&lt;double&gt;::ResultArray res;\nif(req.isResultRequested( ResultType::gradientNormOfMagnetization)) {\n  res.resize(1,1);\n  res(0,0)=...;\n  result.insertOrAssignResult(ResultType::gradientNormOfMagnetization,res);\n}\nif(req.isResultRequested( ResultType::BField)) {\n  res.setZero(3,1);\n  res=...;\n  result.insertOrAssignResult(ResultType::BField,res);\n}\nif(req.isResultRequested( ResultType::cauchyStress)) {\n  res.setZero(3,3);\n  res = ...;\n  result.insertOrAssignResult(ResultType::cauchyStress,res);\n}\n</code></pre>  <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code></p> <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code> is an object of type <code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,0,3,3&gt;</code>. Thus, the maximum result size is limited to a 3x3 matrix. This is used to circumvent dynamic memory allocations.</p>  <p>The last method is <code>globalIndices</code>. It is used to message the global indices of this finite element steming in the output parameter <code>globalIndices</code>. This information should stem from a basis object. See existing implementations for details.</p>","location":"01_theory/finiteElements/#interface"},{"title":"Linear and Non-linear Elasticity","text":"<ul> <li>To be added</li> </ul>","location":"01_theory/finiteElements/#linear-and-non-linear-elasticity"},{"title":"Enhanced Assumed Strain Elements","text":"<p>The Enhanced Assumed Strain (EAS) elements are a class of finite elements which helps to avoid the locking phenomena. They are obtained by re-parametrizing the Hu-Washizu principle and enforcing an orthogonality condition.  This results in an extension of the standard pure displacement formulation with an enhanced strain field (\\(\\tilde\\epsilon\\))  as an additional independent variable. With an appropriate choice of ansatz space for \\(\\tilde\\epsilon\\), the locking  characteristics of the pure displacement formulations can be eliminated. For further theoretical aspects, the readers are referred to 1  and 2. The EAS formulation is currently implemented for the linear elastic case, but  it could be extended to the non-linear regime. The currently implemented EAS elements are the following:</p> <ul> <li>Q1E4</li> <li>Q1E5</li> <li>Q1E7</li> <li>H1E9</li> <li>H1E21</li> </ul> <p>The notation used here is described as follows. The first alphabet stands for a Quadrilateral (Q) or a Hexahedral (H) element. The second index denotes the order of the element. E stands for the EAS element and the number following that denotes the  number of EAS parameters used to enhance the strain field. The only difference amongst various EAS formulations arises  from the matrix \\(\\mathbf{M}\\) which is used to approximate the enhanced strain field. An example for the calculation of the  matrix \\(\\mathbf{M}\\) for a Q1E4 element is shown below: <pre><code>template &lt;typename Geometry&gt;\nstruct EASQ1E4 {\n  static constexpr int strainSize         = 3;\n  static constexpr int enhancedStrainSize = 4;\n\n  EASQ1E4() = default;\n  explicit EASQ1E4(const Geometry&amp; geometry)\n      : geometry{std::make_unique&lt;Geometry&gt;(geometry)}, T0InverseTransformed{calcTransformationMatrix2D(geometry)} {}\n\n  auto calcM(const Dune::FieldVector&lt;double, 2&gt;&amp; quadPos) const {\n    Eigen::Matrix&lt;double, strainSize, enhancedStrainSize&gt; M;\n    M.setZero(strainSize, enhancedStrainSize);\n    const double xi   = quadPos[0];\n    const double eta  = quadPos[1];\n    M(0, 0)           = 2 * xi - 1.0;\n    M(1, 1)           = 2 * eta - 1.0;\n    M(2, 2)           = 2 * xi - 1.0;\n    M(2, 3)           = 2 * eta - 1.0;\n    const double detJ = geometry-&gt;integrationElement(quadPos);\n    M                 = T0InverseTransformed / detJ * M;\n    return M;\n  }\n\n  std::unique_ptr&lt;Geometry&gt; geometry;\n  Eigen::Matrix3d T0InverseTransformed;\n};\n</code></pre> It is to note that the ansatz spaces for the matrix \\(\\mathbf{M}\\) are to be modified such that it fulfills the orthogonality  condition in the \\(\\left[0,1\\right]\\) element domain used in DUNE, in contrast to the \\(\\left[-1,1\\right]\\) usually found in  literature.</p> <p>In order to add a new EAS element, the following additions are to be done: </p> <ol> <li>Create a <code>struct</code> to calculate the matrix \\(\\mathbf{M}\\) as shown above exemplarily for the Q1E4 element.</li> <li>Add the new variant in the corresponding list of 2D and 3D variants as shown below: <pre><code>template &lt;typename Geometry&gt;\nusing EAS2DVariant = std::variant&lt;EASQ1E4&lt;Geometry&gt;, EASQ1E5&lt;Geometry&gt;, EASQ1E7&lt;Geometry&gt;&gt;;\ntemplate &lt;typename Geometry&gt;\nusing EAS3DVariant = std::variant&lt;EASH1E9&lt;Geometry&gt;, EASH1E21&lt;Geometry&gt;&gt;;\n</code></pre></li> <li>Finally, add the new EAS variant with an appropriate switch statement (as shown below) to automatically call the  desired functions <pre><code>void setEASType(int numberOfEASParameters) {\n    if constexpr (Traits::mydim == 2) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 4:\n          easVariant = EASQ1E4(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 5:\n          easVariant = EASQ1E5(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 7:\n          easVariant = EASQ1E7(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 2D case.\");\n          break;\n      }\n    } else if constexpr (Traits::mydim == 3) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 9:\n          easVariant = EASH1E9(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 21:\n          easVariant = EASH1E21(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 3D case.\");\n          break;\n      }\n    }\n  }\n</code></pre></li> </ol> <p>If the number of EAS parameters is set to zero, the pure displacement formulation is then utilised for analysis.</p>   <ol> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/finiteElements/#enhanced-assumed-strain-elements"},{"title":"Geometry","text":"","location":"01_theory/geometry/"},{"title":"Geometry","text":"<p>For the notion of geometry of the grid entities we rely on the definitions of dune. For details, see 1 Chapter 5.3.</p>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/geometry/#geometry"},{"title":"Global basis","text":"","location":"01_theory/globalBasis/"},{"title":"Global basis","text":"<p>In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g.  </p> <p>These elements always connected and disconnected in different ways.  These connections depend on the underlying basis that is assumed for the solution fields. The basis functions have usually a local support. E.g. simple 1-D linear Lagrange basis span over two elements. The connection relation can be encoded in the common vertex node. If we assume higher order 2-D Lagrangian basis function this connection can be associated to a common edge. There are also ansatz function that only have support within one element. These function are sometimes called bubble-functions. In the context of discontinuous Galerkin methods the elements are not connected at all. As last example, if we consider B-Spline basis functions the association of the connection between elements to geometric entities such as edges, vertices fails.</p> <p>Nevertheless, all this connection information is needed to assemble the global systems matrices.  However, the global basis needs to provide indices that encode this connectivity depending on the give finite element This is quite different for different basis. There exists not only one global base.</p> <p>We are relying here one the basis defined by dune. Thus they use the same interface. For details see 1 Chapter 10.</p>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/globalBasis/#global-basis"},{"title":"Grid","text":"","location":"01_theory/grid/"},{"title":"Description of the grid","text":"<p>In finite element simulations, we often talk about elements and meshes. What we commonly refer to as \"element\" consists of various aspects with different tasks, e.g.  </p> <ul> <li>provide a unique identifier (element number)</li> <li>provide a description of the reference geometry (element shape in physical space, shape functions, etc.)</li> <li>provide quantities with physical meaning (mass matrix, stiffness matrix, internal force vector, etc.)</li> <li>...</li> </ul> <p>In the code, there is not one single class which performs all these tasks. Different tasks are performed by  different classes, which are described in the following. Especially, the description of the geometry is decoupled from the task to provide physical meaning. The following content is only about the  description of the element geometry. Details on  the implementation of physical quantities can be found here.</p> <p>For the notion of grids, grid entities and grid factories we rely on the definitions of dune. For details, see 1 Chapter 5.</p>","location":"01_theory/grid/#description-of-the-grid"},{"title":"Available grid implementations","text":"<p>All grids that satisfy the dune::grid interface can be used. For an overview of the available dune::grids, we refer to link. Additionally, there exists an iga grid dune-iga.</p>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/grid/#available-grid-implementations"},{"title":"Local basis","text":"","location":"01_theory/localBasis/"},{"title":"Local Basis","text":"<p>Each finite element does have some kind of local basis in terms of ansatz functions. These ansatz function need to be evaluated at the parameter domain of the finite element.</p>","location":"01_theory/localBasis/#local-basis"},{"title":"Interface","text":"<p>Local basis provide the following interface <pre><code>LocalBasis(const DuneLocalBasis&amp; p_basis)  // Constructor (1)\nvoid evaluateFunction(const DomainType&amp; local, Eigen::VectorX&lt;RangeFieldType&gt;&amp; N);\nvoid evaluateJacobian(const DomainType&amp; local,Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\nvoid evaluateFunctionAndJacobian(const DomainType&amp; local,Eigen::VectorX&lt;RangeFieldType&gt;&amp; N,\n                                 Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\n\nconst Eigen::VectorX&lt;RangeFieldType&gt;&amp; evaluateFunction(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; evaluateJacobian(const unsigned int&amp; integrationPointIndex);\nauto viewOverIntegrationPoints(); // (2)\n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt;\nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints);\n</code></pre></p> <ol> <li>Using the concept <code>Concepts::DuneLocalBasis</code>  the constructor only accepts local basis that satisfies this concept. This also allows a local basis which behaves like a local basis of dune in the spirit of duck-typing.</li> <li>This return a vector of structs of the integration point and its index. Therefore, the syntax is usually <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> </ol> <p>The first two function calls of <code>evaluateFunction</code>  and <code>evaluateJacobian</code> can be used to calculate the function values  \\( N(\\boldsymbol{\\xi}) \\) and the spatial derivatives \\( N_{,\\boldsymbol{\\xi}}(\\boldsymbol{\\xi}) \\). The objects where this is stored you have to allocate yourself and have to pass as mutable reference.</p> <p>In contrast to this there exists two other methods that receive an integration point index.  These methods return a const reference to the evaluated ansatz function values and derivatives.</p> <p>This functionality depends on an earlier call to <code>bind(...)</code>. This binds the local basis to one quadrature rule and caches the passed <code>bindDerivatives(..)</code>. If one calls <code>evaluateFunction(const unsigned int&amp; integrationPointIndex)</code> before bind an error is thrown. Finally, to bind to an integration rule and cache the value and the ansatz function jacobian one would call:</p> Usage with integration point indexusing integration point coordinates   <pre><code>const auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView_.element().type(), order);\nlocalBasis.bind(rule, bindDerivatives(0, 1));\n\nfor (const auto&amp; [gpIndex, gp] : localBasis.viewOverIntegrationPoints()) {\n  const auto&amp; N = localBasis.evaluateFunction(gpIndex);\n  const auto&amp; dN = localBasis.evaluateJacobian(gpIndex);\n}\n</code></pre>   <pre><code>const auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView_.element().type(), order);\nEigen::VectorXd N;\nEigen::Matrix&lt;double, Eigen::Dynamic, gridDim&gt; dN;\n\nfor(auto&amp; gp : rule){\n  localFunction.evaluateFunction(gp.position(), N); \n  localFunction.evaluateJacobian(gp.position(), dN);\n  localFunction.evaluateFunctionAndJacobian(gp.position(), N, dN); // (1) \n}\n</code></pre> <ol> <li>Alternative to the two lines above (Line 6 and 7)</li> </ol>","location":"01_theory/localBasis/#interface"},{"title":"Local functions","text":"","location":"01_theory/localFunctions/"},{"title":"Local functions","text":"<p>This section explains the concept of local functions.</p> <p>Local functions are functions which are bound to single grid elements. Therefore they are constructed from some local basis and a coefficient vector.</p> <p>Usually local functions need to be evaluated in the local coordinate system \\( \\mathbb{\\xi} \\in T_{\\text{ref}} \\subset\\mathbb{R}^n \\) :</p> \\[ f: \\boldsymbol{\\xi}^n \\rightarrow \\mathbb{R}^m \\] <p>where \\(T_{\\text{ref}}\\) is the reference element, e.g. for a cube \\(T_{\\text{ref}}= [0,1]^d\\).</p>","location":"01_theory/localFunctions/#local-functions"},{"title":"Interface","text":"<p>Local functions provide the following interface <pre><code>FunctionReturnType evaluateFunction(const DomainType&amp; local); \nFunctionReturnType evaluateFunction(const unsigned int&amp; integrationPointIndex); \nauto evaluateDerivative(const DomainType&amp; local,...); \nauto evaluateDerivative(const unsigned int&amp; integrationPointIndex,...); \nauto viewOverIntegrationPoints(); // (1) \ntemplate&lt;std::size_t ID=0&gt; \nconstexpr int order(Dune::index_constant&lt;ID&gt; ); // (2) \ntemplate&lt;std::size_t ID=0&gt; \nauto basis(Dune::index_constant&lt;ID&gt; ); // (3) \ntemplate&lt;std::size_t ID=0&gt; \nauto coefficientsRef(Dune::index_constant&lt;ID&gt;); // (4) \n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt; \nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints); // (5) \n\nauto clone (); // (6) \ntemplate&lt;typename ScalarType, std::size_t ID=0&gt; \nauto rebindClone (ScalarType, Dune::index_constant&lt;ID&gt;); // (7) \n</code></pre></p> <ol> <li>This returns a vector of structs of the integration point and its index. Therefore the syntax is usually <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Return the order of the local function wrt. the coefficients. An id tag can be passed which returns the order wrt a tagged function. For details see Tagging leaf local functions.</li> <li>Return the basis of the local function. An id tag can be passed which returns the basis of a specific tagged function. For details see Tagging leaf local functions.</li> <li>Returns a reference to the coefficient of the underlying leaf local finite elements. An id tag can be passed which returns the basis of a specific tagged function. It can return const and non-const reference. The non-const version is deactivated, if there are more than one leaf node with the passed id tag.  For details see Tagging leaf local functions.</li> <li>This function is passed through to the given <code>localBasis</code>. See Link</li> <li>Clones the local function and stores a copy of all leave nodes.</li> <li>Clones the local function and rebinds the scalar type of the coefficients with id tag ID. This becomes hand, if you want to replace doubles with an autodiff type.</li> </ol> <p>The \"...\" in the <code>evaluateDerivative</code> function call are several variadic templates. In action this looks like</p> Usage with integration point indexusing integration point coordinates   <pre><code>using namespace Ikarus::DerivativeDirections; \nlocalFunction.bind(rule, bindDerivatives(0,1));     \nfor(auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()){ \n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll)); // (1) \n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll), transformWith(Jinv)); // (2) \n} \n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction </li> <li>Compute the spatial Jacobian of localFunction and transform it to physical coordinates </li> </ol>   <pre><code>using namespace Ikarus::DerivativeDirections; \nfor(auto&amp; gp : rule){ \n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll)); // (1) \n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll), transformWith(Jinv)); // (2) \n} \n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction </li> <li>Compute the spatial Jacobian of localFunction and transform it to physical coordinates </li> </ol>    <p>where the first call implements</p> \\[ \\operatorname{grad}_\\boldsymbol{\\xi} f : \\boldsymbol{\\xi} \\rightarrow \\mathbb{R}^{m \\times d}. \\] <p>The second one respect the fact that the local function in reality is defined in some physical space \\(X\\) with the coordinate \\(\\boldsymbol{x}\\). Therefore, it transforms the Jacobian from the reference element \\(\\operatorname{grad}_{\\boldsymbol{\\xi}}\\) to the Jacobian in physical space \\(\\operatorname{grad}_\\boldsymbol{x}\\) . E.g. it usually implements</p> \\[ \\operatorname{grad}_\\boldsymbol{x} = \\operatorname{grad}_{\\boldsymbol{\\xi}} \\boldsymbol{J}^{-1}   \\] <p>where \\(J\\) is the Jacobian of the mapping from the reference element \\(T_{\\text{ref}}\\) to the element living in physical space \\(T\\). For details see 2 page 22.</p> <p>Instead of passing <code>spatialAll</code> to <code>wrt(..)</code>, there are other helper such as</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(spatial(0))); // (1)  \nlocalFunction.evaluateDerivative(gpIndex, wrt(spatial(1))); // (2) \n</code></pre> <ol> <li>Compute the first column of the spatial Jacobian of localFunction</li> <li>Compute the second column of the spatial Jacobian of localFunction</li> </ol> <p>which can also be combined with <code>transformWith(Jinv)</code>.</p>","location":"01_theory/localFunctions/#interface"},{"title":"Derivatives w.r.t. coefficients","text":"<p><pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j))); \n</code></pre> which implements for a in vector space valued function (steeming from interpolation),e.g. \\(f(\\boldsymbol{\\xi}) = \\sum_{I=1}^n N^I(\\boldsymbol{\\xi}) \\boldsymbol{x}_I\\) the following</p> \\[ [\\boldsymbol{A}]_{ij}  = A_{ij} =  \\frac{\\partial f_i(\\boldsymbol{\\xi})}{\\partial \\boldsymbol{x}_j} \\] <p>and the second derivative</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k)), along(q)); \n</code></pre> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = q_i A_{ijk} =  \\frac{\\partial^2 (q_i  f_i(\\boldsymbol{\\xi}))}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k} \\] <p>where \\(\\boldsymbol{q}\\) is an arbitrary vector of the same size as \\(f\\), i.e. it is the direction of the derivative in this case. $ \\boldsymbol{A} $ and $ \\boldsymbol{B} $ is simply the returned matrix and they do not have a special meaning. If we would not pass the vector the result would be a third order tensor for a vector valued function \\(f\\). Therefore the simply return a matrix. This helps for readablilty and for speed. See the example for details.</p>","location":"01_theory/localFunctions/#derivatives-wrt-coefficients"},{"title":"Derivatives w.r.t. coefficients and spatial derivatives","text":"<p>Spatial derivatives and derivatives w.r.t. the coefficients can be combined. Therefore, it is legal to call</p> <pre><code>auto B = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q)); \nauto b1 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(0)), along(q)); \nauto b2 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(1)), along(q)); \n</code></pre>  <p>Warning</p>  <p>The order of spatial and coeff derivatives does not matter. The returned value is always re-arranged that the first derivative is the spatial one.</p> <p>The first line is then equivalent to</p> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = Q_{il} A_{iljk} =  \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{\\xi} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] <p>For the second and third line we have</p> \\[\\begin{align} \\boldsymbol{b}_{0,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^0} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}, \\\\ \\boldsymbol{b}_{1,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^1} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\end{align}\\] <p>These objects are also returned when the second and third line above are used.</p> <p>Again all of these function calls can be combined with <code>transformWith()</code> as</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q),transformWith(Jinv)); \n</code></pre> <p>which computes</p> \\[ \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{x} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\]  <p>Warning</p>  <p>Currently only first order spatial derivatives and second order derivatives w.r.t. the coefficients are supported.</p>","location":"01_theory/localFunctions/#derivatives-wrt-coefficients-and-spatial-derivatives"},{"title":"Example Dirichlet energy","text":"<p>This examples shows how the energy, gradient and Hessian of a dirichlet energy can be calculated. $$ E(\\boldsymbol{u}) = \\frac{1}{2} \\int_\\Omega ||\\operatorname{grad}_\\boldsymbol{x} \\boldsymbol{u}(\\boldsymbol{x})|| ^2 \\textrm{d} \\boldsymbol{x} $$</p> <p>If we want to mimize this energy w.r.t. the coefficients of the nodes, we need to calculate the energy, gradient and the Hessia w.r.t. the coefficients. Of course this depends on the optimization algorithms, but for now lets keep it simple.</p> <pre><code>auto dirichletEnergy() { \n  double energy = 0; \n  //... bind localBasis to some integration rule \n  // and create uNodalCoeffs \n  Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), transformWith(Jinv)); \n    energy+= 0.5*(gradu.transpose()*gradu).trace()* (\"weight from integration point and geo.integrationElement\"); \n  } \n} \n</code></pre> <pre><code>auto gradientDirichletEnergy(Eigen::VectorXd&amp; g) { \n  //... bind localBasis to some integration rule \n  // and create uNodalCoeffs \n  constexpr int size =  // spatial size of u \n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), transformWith(Jinv)); \n    for (auto i : fe.size()) { //loop over coeffs, i.e.nodes of the finite element \n      const auto graduDCoeffs \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), transformWith(Jinv)); \n      Eigen::Vector&lt;double, size&gt; tmp; \n      tmp.setZero(); \n      for (int k = 0; k &lt; gridDimension; ++k) \n        tmp += graduDCoeffs[k] * gradu.col(k);  // (1) \n      g.segment&lt;size&gt;(i * size) += tmp * (\"weight from integration point and geo.integrationElement\"); \n    } \n  } \n} \n</code></pre> <ol> <li><code>graduDCoeffs</code> contains in <code>graduDCoeffs[0]</code> the derivatives w.r.t.the coefficient of the first column and at <code>[1]</code> w.r.t.the second column of <code>gradu</code></li> </ol> <pre><code>auto hessianDirichletEnergy(Matrix&amp; h) { \n  //... bind localBasis to some integration rule \n  // and create uNodalCoeffs \n  constexpr int size =  // spatial size of u \n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    for (auto i : loop over coeffs, i.e.nodes of the finite element) { \n      const auto graduDCoeffsI \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), transformWith(Jinv)); \n      for (auto j : fe.size()) { //loop over coeffs, i.e.nodes of the finite element \n        const auto graduDCoeffsJ \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeffs), transformWith(Jinv), coeffIndices(j)); \n        Eigen::Matrix&lt;double, size, size&gt; tmp; \n        tmp.setZero(); \n        for (int k = 0; k &lt; gridDimension; ++k) \n          tmp += graduDCoeffsI[k] * graduDCoeffsJ[k]; \n        h.block&lt;size, size&gt;(i * size, j * size) += tmp * (\"weight from integration point and geo.integrationElement\"); \n      } \n    } \n  } \n} \n</code></pre>","location":"01_theory/localFunctions/#example-dirichlet-energy"},{"title":"Implementations","text":"<p>In the following we summarize the local functions that are currently available. In the following table \\(N^i(\\boldsymbol{\\xi})\\) are the ansatz functions.</p>    Name Interpolation formula Note Header     Standard $$ \\boldsymbol{x} = \\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i  $$  <code>standardLocalFunction.hh</code>   Projection-Based3 $$ \\boldsymbol{x} = P\\left(\\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\right) $$ This is one version of geometric finite elements. These are finite elements suited for interpolation on manifolds. Here \\(P: \\mathbb{R}^m \\rightarrow \\mathcal{M}\\) is an operator that projects  the usual linear interpolation onto some manifold <code>projectionBasedLocalFunction.hh</code>","location":"01_theory/localFunctions/#implementations"},{"title":"How to implement your own local functions","text":"<p>If you are interested in implementing your own local function we have prepared the file <code>ikarus/localFunctions/impl/localFunctionTemplate.hh</code>.</p> <p>You can copy the file rename the class to your preferred name and then implement the following functions. If you don't need a function you need to delete the corresponding function. Then if someone calls the corresponding derivative returns a zero matrix.</p> <pre><code>FunctionReturnType evaluateEmbeddingFunctionImpl(const Eigen::VectorXd&amp; N) const { return FunctionReturnType{}; } // (0) \n\nJacobian evaluateDerivativeWRTSpaceAllImpl(const AnsatzFunctionType&amp; N,  \n                                           const AnsatzFunctionJacobian&amp; dN) const {...} // (1) \n\nJacobianColType evaluateDerivativeWRTSpaceSingleImpl(const AnsatzFunctionType&amp; N,  \n                                                     const AnsatzFunctionJacobian&amp; dN, \n                                                     int spaceIndex) const {...} // (2) \n\n\nCoeffDerivMatrix evaluateDerivativeWRTCoeffsImpl(const AnsatzFunctionType&amp; N, \n                                                 const AnsatzFunctionJacobian&amp; dN, \n                                                 int coeffsIndex) const {...} // (3) \n\nCoeffDerivMatrix evaluateSecondDerivativeWRTCoeffs(const AnsatzFunctionType&amp; N, \n                                                   const AnsatzFunctionJacobian&amp;, \n                                                   const AlongType&amp; along, \n                                                   const std::array&lt;size_t, gridDim&gt;&amp; coeffsIndex) const {...} // (4) \n\nstd::array&lt;CoeffDerivMatrix, gridDim&gt;  \n        evaluateDerivativeWRTCoeffsANDSpatialImpl(const AnsatzFunctionType&amp; N,  \n                                                  const AnsatzFunctionJacobian&amp; dN,  \n                                                  int coeffsIndex) const {...} // (5) \n\n\nCoeffDerivMatrix evaluateDerivativeWRTCoeffsANDSpatialSingleImpl(const AnsatzFunctionType&amp; N, \n                                                                 const AnsatzFunctionJacobian&amp; dN, \n                                                                 const int coeffsIndex,  \n                                                                 const int spatialIndex) const {...} // (6) \n\n\nCoeffDerivMatrix  \n        evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialImpl(const AnsatzFunctionType&amp; N,  \n                                                               const AnsatzFunctionJacobian&amp; dN,  \n                                                               const AlongType&amp; along, \n                                                               const std::array&lt;size_t, gridDim&gt;&amp; coeffsIndex \n                                                               ) const {...} // (7) \n\nCoeffDerivMatrix  \n        evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialSingleImpl(const AnsatzFunctionType&amp; N,  \n                                                                     const AnsatzFunctionJacobian&amp; dN,  \n                                                                     const AlongType&amp; along, \n                                                                     const std::array&lt;size_t, gridDim&gt;&amp; coeffsIndex, c \n                                                                     const int spatialIndex) const {...} // (8) \n</code></pre> <ol> <li>This is called by <code>localFunction.evaluateFunction(...)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j,k)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j,k)), along(A))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j,k)), along(v))</code>.</li> </ol>","location":"01_theory/localFunctions/#how-to-implement-your-own-local-functions"},{"title":"Expressions","text":"<p>We use expression templates1 to combine existing local functions to obtain new nested ones.</p> <p>For example consider the following code <pre><code>... \nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1); \n</code></pre> we create here two local functions that satisfy the interface described above. Now it is possible to combine these functions and get an object that also satisfies the concept above. Thus the following is possible: <pre><code>... \nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1); \nauto k = f+g; \nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d))); \n</code></pre></p> <p>Currently, we support binary and unary expressions. The following expressions are defined:</p>    Name Mathematical formula Code Note     Sum $$ \\boldsymbol{f} + \\boldsymbol{g}  $$ <code>f+g</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) need to be the same size.   DotProduct $$ \\boldsymbol{f} \\cdot \\boldsymbol{g} = f_i g_i $$ <code>dot(f,g)</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) need to be the same size.   normSquared $$ \\boldsymbol{f} \\cdot \\boldsymbol{f} = f_i f_i $$ <code>normSquared(f)</code>    Negate $$ -\\boldsymbol{f}  $$ <code>-f</code>    sqrt $$ \\sqrt{f}  $$ <code>sqrt(f)</code> The function \\(f\\) needs a scalar return type.   log $$ \\log{f}  $$ <code>log(f)</code> The function \\(f\\) needs a scalar return type. Log is the natural logarithm.   pow $$ f^n  $$ <code>pow&lt;n&gt;(f)</code> The function \\(f\\) needs a scalar return type. \\(n\\) is an integer given at compile time.   Scale $$  a f , \\quad a \\in  \\mathbf{R}$$ <code>a*f</code> and <code>f/a</code> <code>a</code> has to satisfy <code>std::is_arithmetic&lt;..&gt;</code>    <p>These expressions can be nested. Thus, it is valid to write something like <pre><code>auto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1); \nauto k = -sqrt(dot(2*f+f,5*g)); \nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d))); \n</code></pre></p> <p>To use these expression there are addition exported static types for all expressions <pre><code>constexpr bool isLeaf; // (1) \nconstexpr bool children; // (2) \n</code></pre></p> <ol> <li>This is true if the underlying expression is one of the above Local functions that really contain the coefficients, see Implementations.</li> <li>Returns the number of children. 2 for binary expressions and 1 for unary expressions.</li> </ol>  <p>Note</p> <p>To use these expression you can simply include the header by <code>#include &lt;ikarus/localFunctions/expressions.hh&gt;</code>.</p>","location":"01_theory/localFunctions/#expressions"},{"title":"Tagging leaf local functions","text":"<p>In the context of mixed finite elements. There are usually several local functions that contribute to the energy. These steems from different local basis. For example consider the Q1P0 element where displacements are interpolated by using the four bilinear ansatz function and the the element-wise constant pressure field.</p> <p>Thus we need to differentiate wrt. different coefficients. This can be done by tagging the local function by construction. <pre><code>using namespace Dune::Indices; \nauto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0,0_); \nauto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1,1_); \nauto k = dot(f,g); \nk.evaluateDerivative(ipIndex, wrt(coeff(0_,i,1_,j))); \n</code></pre> To explain the last line above lets consider that the function f is constructed as \\(f= \\sum_{I=0}^n N^I f_i\\) and similar \\(g= \\sum_{I=0}^m M^I g_i\\), where \\(N\\) and \\(M\\) are some ansatz functions and \\(f_I\\) and \\(g_I\\) are nodal coefficients.</p> <p>Thus the above call translates to</p> \\[\\begin{align} \\boldsymbol{M}_{0,1}[J,K] = \\frac{\\partial^2 (f_{i} g_i )}{\\partial \\boldsymbol{f}_J\\partial \\boldsymbol{g}_K}. \\end{align}\\] <p>If we would calculate the complete hessian of \\(dot(f,g)\\) we can do this by</p> <pre><code>using namespace Dune::Indices; \nauto hessianDirichletEnergy(Matrix&amp; h) { \n  //... bind localBasis to some integration rule \n  using namespace Dune::Indices; \n  auto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0,0_); \n  auto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1,1_); \n  auto k = dot(f,g); \n  constexpr int sizef = f.correctionSize; // spatial size of the correction of the coefficients of f \n  constexpr int sizeg = g.correctionSize; // spatial size of the correction of the coefficients of g \n  constexpr int coeffSizef = coeffVectors0.size(); \n  constexpr int coeffSizeg = coeffVectors1.size(); \n\n  Dune::MultiTypeBlockMatrix&lt;Dune::MultiTypeBlockVector&lt;MatrixBlock00,MatrixBlock01&gt;, \n                                       Dune::MultiTypeBlockVector&lt;MatrixBlock10,MatrixBlock11&gt; &gt; KBlocked; // (1) \n\n\n  for (const auto&amp; [ipIndex, gp] : k.viewOverIntegrationPoints()) { \n    for (size_t I = 0; I &lt; coeffSizef; ++I) \n      for (size_t J = 0; J &lt; coeffSizef; ++J)  \n        KBlocked[0_,0_].block&lt;sizef, sizef&gt;(I * sizef, J * sizef)  \n          += k.evaluateDerivative(ipIndex, wrt(coeff(0_,I,0_,J)))* (\"weight from integration point and geo.integrationElement\"); \n\n    for (size_t I = 0; I &lt; coeffSizef; ++I) \n      for (size_t J = 0; J &lt; coeffSizeg; ++J) \n        KBlocked[0_,1_].block&lt;sizef, sizeg&gt;(I * sizef, J * sizeg)  \n          += k.evaluateDerivative(ipIndex, wrt(coeff(0_,I,1_,J)))* (\"weight from integration point and geo.integrationElement\"); \n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I) \n      for (size_t J = 0; J &lt; coeffSizeg; ++J) \n        KBlocked[1_,1_].block&lt;sizeg, sizeg&gt;(I * sizeg, J * sizeg)  \n          += k.evaluateDerivative(ipIndex, wrt(coeff(1_,I,1_,J)))* (\"weight from integration point and geo.integrationElement\"); \n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I) \n      for (size_t J = 0; J &lt; coeffSizef; ++J) \n        KBlocked[1_,0_].block&lt;sizef, sizeg&gt;(I * sizeg, J * sizef)  \n          += k.evaluateDerivative(ipIndex, wrt(coeff(1_,I,0_,J)))* (\"weight from integration point and geo.integrationElement\"); \n    } \n} \n</code></pre> <ol> <li>This Block structure is not necessary. In this example all types (MatrixBlock00,MatrixBlock01,MatrixBlock10,MatrixBlock11) are considered as <code>Eigen::MatrixXd</code>.</li> </ol>","location":"01_theory/localFunctions/#tagging-leaf-local-functions"},{"title":"Writing your own expression","text":"<p>You can also write your own expressions. For this you can look into existing expressions. Especially the sqrt expression and the normSquared expression are the most general unary and binary expression</p>","location":"01_theory/localFunctions/#writing-your-own-expression"},{"title":"Implementing the return value","text":"<p>If you want to implement your own expression you first have to implement the return value. This is done using the function <pre><code>template &lt;typename LFArgs&gt; \nauto evaluateValueOfExpression(const LFArgs &amp;lfArgs) const; \n</code></pre></p>  <p>Warning</p>  <p>The interface dictates that the return value needs to be an Eigen type. Thus, even if you want to return a scalar <code>double</code> you have to wrap it in <code>Eigen::Vector&lt;double, 1&gt;</code></p> <p>Additionally you also have to implement the derivative evaluation. This is done by implementing <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt; \nauto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const; \n</code></pre></p>","location":"01_theory/localFunctions/#implementing-the-return-value"},{"title":"Evaluate underlying functions","text":"<p>Expression always act on already given expression. Therefore, to return the correct quantity for your expression you have to evaluate the underlying quantities. If you have a unary function you have access to expression using  <code>this-&gt;m()</code> and for binary expressions this is <code>this-&gt;l()</code> and <code>this-&gt;r()</code>.</p> <p>To evaluate these functions you can use the following syntax.</p> <pre><code>const auto mEvaluated = evaluateFunctionImpl(this-&gt;m(), lfArgs); // (1) \n</code></pre> <ol> <li>The syntax is the same for binary expression, e.g.    <pre><code>const auto l_Evaluated = evaluateFunctionImpl(this-&gt;l(), lfArgs); \nconst auto r_Evaluated = evaluateFunctionImpl(this-&gt;r(), lfArgs); \n</code></pre></li> </ol> <p>The expression fulfill the syntax of a local function thus also derivative can be evaluated.</p> <p>In the function <code>evaluateDerivativeOfExpression</code> the derivative order that the user wants is encoded in the template argument <code>DerivativeOrder</code>. Additionally, the derivative types can also accessed using the booleans</p> <pre><code>    static constexpr bool hasTwoCoeff; \n    static constexpr bool hasSingleCoeff; \n    static constexpr bool hasNoCoeff; \n    static constexpr bool hasNoSpatial; \n    static constexpr bool hasOneSpatialAll; \n    static constexpr bool hasOneSpatialSingle; \n    static constexpr bool hasOneSpatial; \n</code></pre> <p>Using the dotproduct as binary example expression we have</p> <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt; \n    auto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const { \n      const auto u = evaluateFunctionImpl(this-&gt;l(), lfArgs); \n      const auto v = evaluateFunctionImpl(this-&gt;r(), lfArgs); \n      if constexpr (DerivativeOrder == 1)  // (1) \n      { \n        const auto u_x = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (2) \n        const auto v_x = evaluateDerivativeImpl(this-&gt;r(), lfArgs); \n        return Ikarus::eval(v.transpose() * u_x + u.transpose() * v_x); // (3) \n      } else if constexpr (DerivativeOrder == 2) {   // (4) \n        const auto &amp;[u_x, u_y] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (5) \n        const auto &amp;[v_x, v_y] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n        if constexpr (LFArgs::hasNoSpatial and LFArgs::hasTwoCoeff) { // (6) \n          const auto alonguArgs = replaceAlong(lfArgs, along(v)); // (7) \n          const auto alongvArgs = replaceAlong(lfArgs, along(u));  \n\n          const auto u_xyAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (8) \n          const auto v_xyAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs); \n\n          return Ikarus::eval(u_xyAlongv + transpose(u_x) * v_y + transpose(v_x) * u_y + v_xyAlongu); \n        } else if constexpr (LFArgs::hasOneSpatial and LFArgs::hasSingleCoeff) { // (9) \n          const auto u_xy = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (10) \n          const auto v_xy = evaluateDerivativeImpl(this-&gt;r(), lfArgs); \n          if constexpr (LFArgs::hasOneSpatialSingle and LFArgs::hasSingleCoeff) { // (11) \n            return Ikarus::eval(transpose(v) * u_xy + transpose(u_x) * v_y + transpose(v_x) * u_y \n                                + transpose(u) * v_xy); \n          } else if constexpr (LFArgs::hasOneSpatialAll and LFArgs::hasSingleCoeff) { // (12) \n            std::array&lt;std::remove_cvref_t&lt;decltype(Ikarus::eval(transpose(v) * u_xy[0]))&gt;, gridDim&gt; res; // (13) \n            for (int i = 0; i &lt; gridDim; ++i) \n              res[i] = Ikarus::eval(transpose(v) * u_xy[i] + transpose(u_x.col(i)) * v_y + transpose(v_x.col(i)) * u_y \n                                    + transpose(u) * v_xy[i]); \n            return res; \n          } \n        } \n      } else if constexpr (DerivativeOrder == 3) { // (14)                                      \n        if constexpr (LFArgs::hasOneSpatialSingle) {  // (15) \n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); // (16) \n\n          const auto &amp;[u_x, u_y, u_z] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (17) \n          const auto &amp;[v_x, v_y, v_z] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n          const auto &amp;[u_xy, u_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (18) \n          const auto &amp;[v_xy, v_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs); \n\n          const auto alonguArgs             = replaceAlong(lfArgs, along(u)); \n          const auto alongvArgs             = replaceAlong(lfArgs, along(v)); \n          const auto argsForDyzalongv_xArgs = replaceAlong(argsForDyz, along(v_x)); // (19) \n          const auto argsForDyzalongu_xArgs = replaceAlong(argsForDyz, along(u_x)); \n\n          const auto u_xyzAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (20) \n          const auto v_xyzAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs); \n          const auto u_yzAlongvx = evaluateDerivativeImpl(this-&gt;l(), argsForDyzalongv_xArgs); // (21) \n          const auto v_yzAlongux = evaluateDerivativeImpl(this-&gt;r(), argsForDyzalongu_xArgs); \n\n          return Ikarus::eval(u_xyzAlongv + transpose(u_xy) * v_z + transpose(u_xz) * v_y + v_yzAlongux + u_yzAlongvx \n                              + transpose(v_xz) * u_y + transpose(v_xy) * u_z + v_xyzAlongu); \n        } else if constexpr (LFArgs::hasOneSpatialAll) { // (22) \n          const auto &amp;alongMatrix = std::get&lt;0&gt;(lfArgs.alongArgs.args); // (23) \n\n          const auto uTimesA = eval(u * alongMatrix); \n          const auto vTimesA = eval(v * alongMatrix); \n\n          const auto &amp;[gradu, u_c0, u_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (24) \n          const auto &amp;[gradv, v_c0, v_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n          const auto &amp;[gradu_c0, gradu_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (25) \n          const auto &amp;[gradv_c0, gradv_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs); \n\n          const auto graduTimesA = (gradu * alongMatrix.transpose()).eval(); \n          const auto gradvTimesA = (gradv * alongMatrix.transpose()).eval(); \n\n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); \n\n          const auto alonguAArgs          = replaceAlong(lfArgs, along(uTimesA)); \n          const auto alongvAArgs          = replaceAlong(lfArgs, along(vTimesA)); \n          const auto alonggraduTimesAArgs = replaceAlong(argsForDyz, along(graduTimesA)); \n          const auto alonggradvTimesAArgs = replaceAlong(argsForDyz, along(gradvTimesA)); \n\n          const auto u_xyzAlongv            = evaluateDerivativeImpl(this-&gt;l(), alongvAArgs); \n          const auto v_xyzAlongu            = evaluateDerivativeImpl(this-&gt;r(), alonguAArgs); \n          const auto v_c0c1AlongGraduTimesA = evaluateDerivativeImpl(this-&gt;r(), alonggraduTimesAArgs); \n          const auto u_c0c1AlongGradvTimesA = evaluateDerivativeImpl(this-&gt;l(), alonggradvTimesAArgs); \n          decltype(eval(u_xyzAlongv)) res; \n\n          res = u_xyzAlongv + v_xyzAlongu + v_c0c1AlongGraduTimesA + u_c0c1AlongGradvTimesA; \n          for (int i = 0; i &lt; gridDim; ++i) \n            res += (transpose(u_c1) * gradv_c0[i] + transpose(v_c1) * gradu_c0[i] + transpose(v_c0) * gradu_c1[i] \n                    + transpose(u_c0) * gradv_c1[i]) \n                   * alongMatrix(0, i); \n\n          return res; \n\n        } \n      }  \n    } \n</code></pre> <ol> <li>Compile time branch for first order derivatives</li> <li>Evaluates the derivative of the <code>this-&gt;l()</code> wrt. the only derivative inside the localfunction arguments <code>lfArgs</code>.</li> <li>Evaluates the return value and derivatives and function values are combined as dictated by the product rule.</li> <li>Compile time branch for second order derivatives</li> <li>Since we are in the second order derivatives branch, there are 4 case for the evaluation of function.    The function value, the function derivative wrt. to the first argument or the second and the function's derivatives wrt. to both arguments.    Here, the function <code>evaluateFirstOrderDerivativesImpl</code> returns the derivatives wrt. to the first argument and the second.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\) this calls returns    \\begin{flalign*}    \\verb+u_x+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{\\xi}} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\xi_0} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_I}\\\\    \\verb+u_y+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_J}    \\end{flalign*}    The first one would be returned if the caller uses    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \n</code></pre>    and the second one    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \n</code></pre>    and the third without any spatial derivative using    <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j))); \n</code></pre>    Therefore, this function separates the two wrt. arguments and returns the corresponding first order derivatives.</li> <li>Compile time branch for the case where no spatial derivatives are requested bot only wrt. coefficients is needed.</li> <li>Creates a new argument variable where the along argument is replaced by <code>v</code>.</li> <li>This function evaluates the derivatives of <code>l</code> wrt to both passed wrt arguments. Furthmore, it takes the give along argument since otherwise the returned object would be a 3 dimensional array.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  and \\(\\boldsymbol{v}\\) of the same size as \\(\\boldsymbol{u}\\) this calls returns    \\begin{flalign*}    \\verb+u_xyAlongv + &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i    \\end{flalign*}    This is the same if the user calls    <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j)),along(v)); \n</code></pre></li> <li>Compile time branch for the case where one spatial derivatives and one derivative wrt. coefficients is needed.</li> <li>This function evaluates the derivatives of <code>l</code> wrt to both passed wrt arguments.     If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  this calls returns     \\begin{flalign*}     \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\quad \\text{or} \\quad \\verb+u_xy+ = \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\xi_0\\partial\\boldsymbol{u}_I}     \\end{flalign*}     The first one would be returned if the caller uses    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \n</code></pre> and the second one    <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \n</code></pre> In the first case the result is stored in an array. Thus in the first index the derivative wrt. to the first spatial coordinate is stored. Therefore we would have in the code    <pre><code>spatialAllCoeffDeriv = u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \nspatialAllCoeffDeriv[0] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \nspatialAllCoeffDeriv[1] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(1),coeff(i))); \n</code></pre></li> <li>Compile time branch for the case where one single spatial derivatives and one derivative wrt. coefficients is needed.</li> <li>Compile time branch for the case where all spatial derivatives and one derivative wrt. coefficients is needed.</li> <li>The return type here is an array of single spatial derivatives and each derived wrt. the coefficient. Thus the type inside the array must be deduced here.</li> <li>Compile time branch for third order derivatives</li> <li>Compile time branch for single spatial derivatives</li> <li>To obtain derivatives wrt to the second and third wrt argument we extract here the arguments. E.g. if we have the following request    <pre><code> u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre> this call would extract the arguments as    <pre><code> newArgs =  \"wrt(coeff(i,j)),along(matrix))\" //THIS IS NO VALID SYNTAX \n</code></pre> This can be used then as    <pre><code>u.evaluateDerivative(gpIndex, newArgs); \n</code></pre></li> <li>As in the second order derivative case the returns all three first order derivatives. If we would have     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre>     The returned values would be     \\begin{flalign*}     \\verb+u_x+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}} \\\\     \\verb+u_y+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_I} \\\\     \\verb+u_z+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_J}     \\end{flalign*}</li> <li>This returns the derivatives wrt to the given spatial direction and wrt to the first and second coefficient.  If we would have     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre>     The returned values would be     \\begin{flalign*}     \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\\\     \\verb+u_xz+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_J} \\\\     \\end{flalign*}</li> <li>Creates a new argument variable where the along argument is replaced by <code>v_x</code>.</li> <li>This return as the call would be     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i,j),along(v)); \n</code></pre>     In mathematical notation this returns     \\begin{flalign*}     \\verb+u_xyzAlongv  + &amp;= \\frac{\\partial^3 u_i }{\\partial \\xi_0\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i     \\end{flalign*}</li> <li>This return as the call would be     <pre><code>v_x = v.evaluateDerivative(gpIndex, wrt(spatial(0)); \nu_yzAlongvx = u.evaluateDerivative(gpIndex, wrt(coeff(i,j),along(v_x)); \n</code></pre>     In mathematical notation this returns     \\begin{flalign*}     \\verb+u_yzAlongvx+ &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} \\left[\\frac{\\partial \\boldsymbol{v}}{\\xi_0}\\right]_i     \\end{flalign*}</li> <li>Compile time branch for all spatial derivatives</li> <li>Obtain the along argument give by the caller as in     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j),along(matrix)); \n</code></pre></li> <li>As above in the single spatial case</li> <li>As above in the single spatial case</li> </ol> <p>If your expression is working you should add it to <code>ikarus/localfunctions/expressions.hh</code></p>   <ol> <li> <p>Expression templates are usually used in linear algebra libraries, e.g. Eigen or Blaze. The syntax is similar to the one provided by UML but only acts on local functions.\u00a0\u21a9</p> </li> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/localFunctions/#evaluate-underlying-functions"},{"title":"Manifolds","text":"","location":"01_theory/manifolds/"},{"title":"Manifold elements","text":"","location":"01_theory/manifolds/#manifold-elements"},{"title":"Introduction","text":"<p>Usually optimization problems are defined in terms of some cost function.</p> <p>$$  \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) $$ where \\( f: \\mathcal{M} \\rightarrow \\mathbb{R} \\).</p> <p>Usually \\( \\mathcal{M} \\) is an Euclidean vector space \\( \\mathbb{R}^n \\).</p> <p>In a finite element context, if we solve e.g. 2d elasticity problems we have a  two-dimensional displacement for each node. Thus if we have \\(n \\) nodes we optimize in \\( {\\mathbb{R}^2}^n  \\).</p> <p>For this case the nodal degrees of freedom should be wrapped in <code>Ikarus::RealTuple&lt;double,2&gt;</code>.</p> <p>Another case of optimization is on non-linear manifolds. These arise typically for Cosserat materials \\( \\mathcal{S}\\mathcal{O}(3) \\),  Reissner-Mindlin shells and micromagnetics \\( \\mathcal{S}^{2} \\) or incompressible materials.</p>","location":"01_theory/manifolds/#introduction"},{"title":"Interface","text":"<p>The general interface of the manifold elements is represented by the following concept. <pre><code>namespace Ikarus::Concepts {\n  template &lt;typename ManifoldType&gt;\n  concept Manifold = requires(ManifoldType var, typename ManifoldType::CorrectionType correction, std::ostream&amp; s,\n                              typename ManifoldType::CoordinateType value) {\n    typename ManifoldType::ctype; // (1)\n    ManifoldType::valueSize; // (2)\n    ManifoldType::correctionSize; // (3)\n    typename ManifoldType::CoordinateType; // (4)\n    typename ManifoldType::CorrectionType; // (5)\n    { var.getValue() } -&gt; std::convertible_to&lt;typename ManifoldType::CoordinateType&gt;; // (6)\n    { var.setValue(value) } -&gt; std::same_as&lt;void&gt;; // (7)\n    { var+=correction };  // (8)\n    { s &lt;&lt; var } -&gt; std::same_as&lt;std::ostream&amp;&gt;;\n  };\n}  \n</code></pre></p> <ol> <li>The type for the coordinate values usually <code>double</code>.</li> <li>The number of values to store the state of the element. E.g. the three dimensional unit vector needs three entries to store its state.</li> <li>The size of the correction of the element. For the Euclidean space <code>valueSize</code> and <code>correctionSize</code> coincide. But e.g. the three dimensional unit vector needs a two-dimensional correction. (Which lives in the tangent space.)</li> <li>The type to store the element coordinates usually <code>Eigen::Vector&lt;double,ManifoldType::valueSize&gt;</code></li> <li>The type to store the element correction type usually <code>Eigen::Vector&lt;double,ManifoldType::correctionSize&gt;</code></li> <li>Access the underlying coordinates vector of the manifold element.</li> <li>Directly set the value. E.g. set a <code>Ikarus::UnitVector&lt;double,3&gt; a; a.setValue(Eigen::Vector3d::UnitZ());</code></li> <li>Update the element with a correction vector. E.g.       <pre><code>   Ikarus::RealTuple&lt;double,3&gt; a; \n   a+= Eigen::Vector3d::UnitX();\n\n   Ikarus::UnitVector&lt;double,3&gt; b; \n   b+= Eigen::Vector2d::UnitX();\n</code></pre></li> </ol>","location":"01_theory/manifolds/#interface"},{"title":"Implementations","text":"Name Formal definition Notes Header     \\(n\\)-th dimensional Euclidean space $$ \\boldsymbol{x} \\in \\mathbb{R}^n  $$  <code>realTuple.hh</code>   Unit sphere $$ \\boldsymbol{x} \\in \\mathcal{S}^{n-1}, \\quad \\mathcal{S}^{n-1} = \\left\\{ \\boldsymbol{x} \\in \\mathbb{R}^n :  \\boldsymbol{x}\\cdot  \\boldsymbol{x}  = 1 \\right\\}  $$  <code>unitVector.hh</code>","location":"01_theory/manifolds/#implementations"},{"title":"NonlinearOperator","text":"","location":"01_theory/nonlinearOperator/"},{"title":"Nonlinear operator","text":"<p>The class <code>NonLinearOperator</code> provides a collection of a function and its derivatives, including the dependence  on parameters. </p> <p>Let's assume you have a function <code>f(x)</code> and its derivative <code>df(x)</code>. Then, a <code>NonLinearOperator</code> can be constructed as follows:</p> <pre><code>double x               = 13;\nauto fvLambda  = [&amp;](auto&amp;&amp; x) { return f(x); };\nauto dfvLambda = [&amp;](auto&amp;&amp; x) { return df(x); };\n\nauto nonLinOp = Ikarus::NonLinearOperator(linearAlgebraFunctions(fvLambda, dfvLambda), parameter(x));\n</code></pre>  <p>It is assumed that the second function is the derivative of the first function, the third function is the derivative of the second function (2nd derivative of the first function), etc.</p>  <p><code>linearAlgebraFunctions(...)</code> and <code>parameter(...)</code> are helper functions. They are necessary to distinguish which argument is a function and which argument is parameter. </p> <p><code>nonLinOp</code> provides the following features: <pre><code>void updateAll() // (1)\nvoid update&lt;n&gt;() // (2)\nauto&amp; value() // (3)\nauto&amp; derivative() // (4)\nauto&amp; secondDerivative() // (5)\nauto&amp; nthDerivative&lt;n&gt;() // (6)\nauto&amp; firstParameter() // (7)\nauto&amp; secondParameter() // (8)\nauto&amp; nthParameter&lt;n&gt;() // (9)\nauto&amp; lastParameter() // (10)\nauto subOperator&lt;n,m,...&gt;() // (11)\n</code></pre></p> <ol> <li>Evaluates all functions</li> <li>Evaluates the n-th function in <code>linearAlgebraFunctions(...)</code> . Counting starts from 0 as always in C++.</li> <li>Returns the result of the function evaluation.</li> <li>Returns the result of the evaluation of the first derivative (if the function for the first derivative of passed to the nonlinear Operator at construction.)</li> <li>Returns the result of the evaluation of the second derivative (if the function for the second derivative of passed to the nonlinear Operator at construction.).</li> <li>Returns the result of the evaluation of the n-th derivative (if the function for the third derivative of passed to the nonlinear Operator at construction.).</li> <li>Returns the value of the first parameter.</li> <li>Returns the value of the second parameter (if available).</li> <li>Returns the value of the n-th parameter (if available).</li> <li>Returns the value of the last parameter.</li> <li>Creates a <code>Ikarus::NonLinearOperator</code> with a subset of the derivatives. Example: You have a nonlinear operator with     (function, first derivative, second derivative). <code>subOperator&lt;0,1&gt;()</code> then returns a nonlinear operator with     (function, first derivative).</li> </ol>","location":"01_theory/nonlinearOperator/#nonlinear-operator"},{"title":"Observer and observables","text":"","location":"01_theory/observer/"},{"title":"Oberserver and Observable","text":"<p>To solve situations like \"I want to write an output when the loadstep is completed\", the observer pattern is implemented in Ikarus. To understand it and use it in your implementation, you need to understand three things: <code>IObservable</code>, <code>IObserver</code> and Messages.</p>","location":"01_theory/observer/#oberserver-and-observable"},{"title":"Messages","text":"<p>A message class is a list of possible events that can happen and might be of interest. The messages which are used for  nonlinear solvers are listed below as an example. <pre><code>enum class NonLinearSolverMessages {\n  BEGIN,\n  INIT,\n  ITERATION_STARTED,\n  ITERATION_ENDED,\n  RESIDUALNORM_UPDATED,\n  CORRECTIONNORM_UPDATED,\n  SOLUTION_CHANGED,\n  FINISHED_SUCESSFULLY,\n  END\n};\n</code></pre></p>","location":"01_theory/observer/#messages"},{"title":"IObservable","text":"<p>A class can be observable. The class then sends notifications when events are happening. To become observable, a class has to inherit from <code>IObservable&lt;MessageType&gt;</code>, e.g. <pre><code>class NewtonRaphson : public IObservable&lt;NonLinearSolverMessages&gt; {...};\n</code></pre> To send a notification, the function <code>this-&gt;notify(MessageType::Message)</code> is called at the corresponding position in the code. This could be for example <pre><code>this-&gt;notify(NonLinearSolverMessages::SOLUTION_CHANGED);\n</code></pre></p>","location":"01_theory/observer/#iobservable"},{"title":"IObserver","text":"<p>A class can be an observer. The class is then notified when events are happening and can perform actions. A very simple example is shown below. To become an observer, the class has to inherit from <code>IObserver&lt;MessageType&gt;</code>, where <code>MessageType</code> is the enum of messages that should be used (see above).  <pre><code>class OurFirstObserver : public IObserver&lt;NonLinearSolverMessages&gt; {\npublic:\n  void updateImpl(NonLinearSolverMessages message) override {\n    if (message == NonLinearSolverMessages::ITERATION_STARTED) std::cout &lt;&lt; \"Yeah, the iteration started. Let's go!\\n\";\n  }\n};\n</code></pre> The observer has to implement hat function <code>void updateImpl(MessageType message)</code>. In this function, all actions can be implemented that should be performed when the corresponding message is received.</p> <p>To connect observer and observable, one has to call <code>observalbe.subscribe(MessageType::Message,observer)</code>. Example: <pre><code>Ikarus::NewtonRaphson nr(...);\nauto ourSimpleObserver = std::make_shared&lt;OurFirstObserver&gt;();\nnr.subscribe(NonLinearSolverMessages::ITERATION_STARTED, ourSimpleObserver);\n};\n</code></pre></p>","location":"01_theory/observer/#iobserver"},{"title":"Subscription options and sending data","text":"<p>There are a couple of options for the subscription: <pre><code>subscribe(MessageType::Message,observer) // (1)\nsubscribeAll(observer) // (2)\nsubscribeAll({observer1,observer2}) // (3)\nunSubscribe(...) // (4)\n</code></pre></p> <ol> <li>Subscribe to one specific message.</li> <li>Subscribe to all messages in the enum.</li> <li>Multiple observers can subscribe at once.</li> <li>Unsubscribe from specific messages or all messages</li> </ol> <p>To send a message together with data, the sender (observable) calls <pre><code>this-&gt;notify(MessageType::Message,data);\n</code></pre> and the receiver (observer) has to implement <pre><code>void updateImpl(MessageType message, data) override {\n</code></pre> To see all available options for <code>data</code>, we refer to the file <code>observer.hh</code>.</p>","location":"01_theory/observer/#subscription-options-and-sending-data"},{"title":"Overview","text":"","location":"01_theory/overview/"},{"title":"Overview","text":"<pre><code>classDiagram \n  GridView &lt;-- Grid\n  GlobalBasis &lt;-- GridView\n  Assembler &lt;-- GlobalBasis\n  NonlinearOperator &lt;-- Assembler\n  Assembler &lt;-- FiniteElement\n  FiniteElement &lt;-- FERequirements\n  FERequirements &lt;-- FErequirementsBuilder\n  ResultRequirements &lt;-- ResultRequirementsBuilder\n  FERequirements &lt;|-- ResultRequirements\n  FiniteElement &lt;-- ResultRequirements\n  FiniteElement &lt;-- Local function\n  Localfunction &lt;-- Localbasis\n  GlobalBasis &lt;--&gt; Localbasis\n  Localfunction &lt;-- Manifold\n  NonlinearSolver &lt;-- NonlinearOperator\n  NonlinearSolver &lt;-- LinearSolver\n  Controlroutine &lt;-- NonlinearSolver\n  VTKWriter &lt;-- Controlroutine\n  DirichletConditions .. Assembler\n  DirichletConditions .. Controlroutine\n  Controlroutine &lt;|-- IObservable\n  NonlinearSolver &lt;|-- IObservable\n  Observer ..&gt; IObservable\n  FErequirementsBuilder &lt;-- Affordances\n  Affordances &lt;-- ScalarAffordances\n  Affordances &lt;-- VectorAffordances\n  Affordances &lt;-- MatrixAffordances\n  ResultRequirementsBuilder &lt;-- ResultType\n\n\n  class ScalarAffordances{\n  &lt;&lt;enumeration&gt;&gt;\n      mechanicalPotentialEnergy\n      microMagneticPotentialEnergy\n      ...\n  }\n\n  class VectorAffordances{\n        &lt;&lt;enumeration&gt;&gt;    \n      forces\n      microMagneticForces\n      ...\n  }\n\n  class MatrixAffordances{\n        &lt;&lt;enumeration&gt;&gt;\n      stiffness\n      materialstiffness\n      geometricstiffness\n      mass\n      stiffnessdiffBucklingVector\n      microMagneticHessian\n      ...\n  }\n\n  class ResultType{\n      &lt;&lt;enumeration&gt;&gt;\n      noType\n      magnetization\n      gradientNormOfMagnetization\n      vectorPotential\n      divergenceOfVectorPotential\n      BField\n      HField\n      cauchyStress\n      director\n      ...\n  }\n\n  class Observer{\n    +update()\n  }\n\n  class DirichletConditions{\n  TBA\n  }\n\n  class IObservable{\n    +subscribe()\n    +subscribeAll()\n    +unSubscribe()\n    +unSubscribeAll()\n    +notify()\n  }\n\n  class FERequirements{\n    +hasAffordance()\n    +getGlobalSolution()\n    +getParameter()\n  } \n\n  class ResultRequirements{\n    +isResultRequested()\n    +getParameter()\n  }\n\n  class ResultRequirementsBuilder{\n    +addAffordance()\n    +insertParameter()\n    +insertGlobalSolution()\n    +addResultRequest()\n  }\n\n  class FErequirementsBuilder{\n    +addAffordance()\n    +insertParameter()\n    +insertGlobalSolution()\n    +build()\n  }\n\n  class Assembler{\n    +getScalar()\n    +getVector()\n    +getMatrix()\n    +getReducedMatrix()\n    +getReducedVector()\n    +createFullVector()\n  }\n  class GridView{\n    +elements(gridView)\n    +vertices(gridView)\n    +edges(gridView)\n    +surfaces(gridView)\n  }\n  class Controlroutine{\n    +run()\n  }\n\n  class NonlinearSolver{\n    +setup()\n    +solve()\n    +nonLinearOperator()\n  }\n\n  class GlobalBasis{\n    +localView()\n  }\n\n    class Grid{\n    +leafGridView()\n  }\n\n  class FiniteElement{\n  +calculateScalar()\n  +calculateVector()\n  +calculateMatrix()\n  +calculateAt()\n  }\n\n  class LinearSolver{\n    +analyzePattern()\n    +factorize()\n    +compute()\n    +solve()\n  }\n  class NonlinearOperator{\n    +value()\n    +derivative()\n    +secondDerivative()\n    +nthDerivative&lt;n&gt;()\n    +subOperator()\n}\n\n  class Localfunction{\n    +calculateFunction()\n    +calculateDerivative()\n    +bind()\n    +viewOverIntegrationPoints()\n  }  \n\n  class Localbasis{\n    +calculateFunction()\n    +evaluateJacobian()\n    +bind()\n    +isBound()\n    +viewOverIntegrationPoints()\n  }  \n\n  class Manifold{\n    +setValue()\n    +operator+=()\n    +getValue()\n    +size()\n    +size()\n  }\n\nclick NonlinearOperator href \"../nonlinearOperator/\" \nclick LinearSolver href \"../solvers/#linear-solver\" \nclick NonlinearSolver href \"../solvers/#non-linear-solver\" \nclick FiniteElement href \"../finiteElements/\" \nclick GridView href \"../grid/\" \nclick Grid href \"../grid/\" \nclick Controlroutine href \"../controlRoutines/\" \nclick Assembler href \"../assembler/\" \nclick Localfunction href \"../localFunctions/\" \nclick Manifold href \"../manifolds/\" \nclick Localbasis href \"../localBasis/\" \nclick FERequirements href \"../feRequirements/\" \nclick FErequirementsBuilder href \"../feRequirements/\" \nclick ResultRequirements href \"../feRequirements/#fe-result-requirements\" \nclick ResultRequirementsBuilder href \"../feRequirements/#fe-result-requirements\" \nclick Affordances href \"../feRequirements/\" \nclick ResultType href \"../feRequirements/\" \nclick IObservable href \"../observer/#iobservable\" \nclick Observer href \"../observer/#iobserver\" \nclick GlobalBasis href \"../globalBasis/\" \n</code></pre>","location":"01_theory/overview/#overview"},{"title":"Solvers","text":"","location":"01_theory/solvers/"},{"title":"Solvers","text":"<p>In Ikarus there are essentially two types of solvers.</p>","location":"01_theory/solvers/#solvers"},{"title":"Linear solver","text":"<p>The first are called <code>LinearSolver</code>. These are solver which solve for the vector \\( \\boldsymbol{x} \\) in</p> <p>$$ \\boldsymbol{A}  \\boldsymbol{x} =  \\boldsymbol{b} $$ where \\(\\boldsymbol{A} \\) is some matrix and \\(\\boldsymbol{b}\\) is some vector. These solvers can be direct or iterative. Furthermore, they depend on the underlying structure of the matrix \\(\\boldsymbol{A} \\). I.e. if it is stored in <code>dense</code> or in a <code>sparse</code> format.</p> <p>Currently, we only support the linear solvers provided by the Eigen library.</p> <p>Linear solvers can be constructed by calling the constructor</p> <pre><code>ILinearSolver(const SolverTypeTag&amp; solverTypeTag)\n</code></pre> <p>There exits an enum type <code>SolverTypeTag</code> with the following values</p> <pre><code>    si_ConjugateGradient,\n    si_LeastSquaresConjugateGradient,\n    si_BiCGSTAB,\n    sd_SimplicialLLT,\n    sd_SimplicialLDLT,\n    sd_SparseLU,\n    sd_SparseQR,\n    sd_CholmodSupernodalLLT,\n    sd_UmfPackLU,\n    sd_SuperLU,\n    d_PartialPivLU,\n    d_FullPivLU,\n    d_HouseholderQR,\n    d_ColPivHouseholderQR,\n    d_FullPivHouseholderQR,\n    d_CompleteOrthogonalDecomposition,\n    d_LLT,\n    d_LDLT,\n  };\n</code></pre> <p>The prefixes <code>s_</code> and  <code>d_</code> indicate whether the linear solver can be used for dense or sparse matrices. Furthermore, there is a second prefix for sparse solvers1 <code>d</code> and <code>i</code> for direct solvers and for iterative solvers. Thus, using <code>si_ConjugateGradient</code> means that this solver is for sparse matrices and is an iterative solver.</p> <p>The naming of the solvers is the same as in Eigen.  For more details on the solvers we refer to Eigen's documentation for dense decompositions and to Eigen's documentation for sparse decompositions.</p>","location":"01_theory/solvers/#linear-solver"},{"title":"Interface","text":"<p>Similar to Eigen's interface the following function are provided <pre><code>void analyzePattern(const MatrixType&amp; A);  // (1)\nvoid factorize(const MatrixType&amp; A); // (2)\nILinearSolver&amp; compute(const MatrixType&amp; A); // (3)\nvoid solve(Eigen::VectorX&lt;ScalarType&gt;&amp;x, const Eigen::VectorX&lt;ScalarType&gt;&amp; b); // (4)\n</code></pre></p> <ol> <li>If the matrix is sparse Eigen can collect information on the sparsity pattern of the matrix for faster a faster <code>solve</code> step. This pattrern does not change if you change the values of the non-zero entries.</li> <li>This method applies some decomposition for direct solvers e.g. LU decomposition. For iterative solvers the method is a noOp.</li> <li>Compute simply calls 'analyzePattern' and 'factorize'.</li> <li>Solves the problem and stores the result in <code>x</code>.</li> </ol>  <p>Tip</p> <p>If your algorithm in mind does rely on special features of some linear solver then you have to directly use this solver. E.g. if you need the <code>.determinant()</code> method of <code>Eigen::SimplicialLDLT</code> you need to directly use it since <code>ILinearSolver</code>does not support this method.</p>","location":"01_theory/solvers/#interface"},{"title":"Nonlinear solver","text":"<p>Non-linear solvers are usually used to solve some optimization problem, e.g. root-finding or minimization problems \\begin{align}   \\boldsymbol{R}(\\boldsymbol{x}) \\stackrel{!}{=} \\boldsymbol{0} \\quad \\text{or} \\quad   \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) \\end{align}</p>","location":"01_theory/solvers/#nonlinear-solver"},{"title":"Interface","text":"<pre><code>void setup(const NewtonRaphsonSettings&amp; p_settings); // (1)\nSolverInformation solve(const SolutionType&amp; dx_predictor = NoPredictor{}); // (2)\nauto&amp; nonLinearOperator(); // (3)\n</code></pre> <ol> <li>With this function several properties of the nonlinear solver can be set. E.g. residual tolerance or maximum number of iterations.</li> <li>Solves the non-linear problem. One can pass an initial guess to the function. Otherwise the zero vector is assumed.     It returns<code>SolverInformation</code> which contains information on the success of the solution step and other information as the needed iterations. </li> <li>Simply returns the underlying <code>nonLinearOperator</code>, see Link</li> </ol>  <p>Note</p> <p>To easy the construction process the Nonlinear solver can provide a method <code>make[...]</code> which allows shorter syntax, since no <code>std::shared_ptr</code> has to be constructed and specifying all template arguments.  The construction of the nonlinear solvers can be very different. Therefore we do not impose an interface for the constructors.</p>","location":"01_theory/solvers/#interface_1"},{"title":"Implementations","text":"Name Purpose Constraints on nonlinear operator Header Properties     Newton-Raphson Root finding Value and gradient <code>newtonRaphson.hh</code> Locally quadratic convergence   Trust-Region Minimization Value, gradient and Hessian <code>trustRegion.hh</code> Globally convergent and locally quadratic convergence    <p>To see the Newton-Raphson we refer to the tests inside <code>nonLinearOperatorTest.cpp</code> and for trust region <code>trustRegionTest.cpp</code>.</p>   <ol> <li> <p>Dense solver are currently all direct solvers. Therefore, we do not distinguish them.\u00a0\u21a9</p> </li> </ol>","location":"01_theory/solvers/#implementations"},{"title":"Gallery","text":"","location":"02_gallery/gallery/"},{"title":"Gallery","text":"<p>In the future here should be several figures from Ikarus simulations</p>","location":"02_gallery/gallery/#gallery"},{"title":"Literature","text":"","location":"99_Literature/99_Literature/"},{"title":"Literature","text":"<ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph Johnson, Ralph E Johnson, John Vlissides, and others. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. URL: https://link.springer.com/book/10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> </ol>","location":"99_Literature/99_Literature/#literature"},{"title":"Blog","text":"","location":"blog/"},{"title":"Hello world!","text":"<p>...</p>","location":"blog/2022/01/31/hello-world/"},{"title":"Build the documentation locally","text":"","location":"documentation/BuildTheDocumentationLocally/"},{"title":"How to edit this documentation","text":"","location":"documentation/BuildTheDocumentationLocally/#how-to-edit-this-documentation"},{"title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,   see the download page.</li> </ul>","location":"documentation/BuildTheDocumentationLocally/#prerequisites"},{"title":"Preview the documentation locally","text":"<ul> <li>Changing cmake option: E.g. In Clion: Open <code>File --&gt; Settings --&gt; Build,Execution,Deployment --&gt; Cmake</code>    Add <code>-DBUILD_DOCS=TRUE</code> to your cmake options    </li> <li>Choose target <code>localSite</code> and build it (click on the hammer)</li> </ul> <p></p> <ul> <li>After a couple of seconds, build messages should appear which look similar to the picture below.   </li> <li>Click on <code>Services</code> in the footer, double click on <code>Docker</code> and unfold <code>Containers</code>. There should be    one container with a blue box while the other containers have a blue box with a white square inside   (see figure below). In this example, the container we are looking for is <code>elegant_bassi</code>.   The name will be different on your computer, the relevant criterion for finding the container   is the blue box.   </li> <li>Click on the container with the blue box and navigate to <code>Port Bindings</code>.</li> <li>Add a new port by clicking on <code>+</code>, activate <code>Host port</code> under <code>Modifiy options</code> and enter    <code>8000</code> in both fields (see image below). Confirm with <code>OK</code>.   </li> <li>Click on <code>Save</code> in the lower right corner. This will restart the container. Messages will appear    saying that the build failed. These messages can be ignored. The build process restarts automatically.</li> <li>After a couple of seconds, Click on this link.</li> <li>Now you should see a live preview of the documentation in your browser</li> <li>You can edit the documentation in CLion. <code>STRG</code> + <code>s</code> saves the documentation and updates it in   your browser window.</li> <li>Cancel the build process to stop the live preview. To restart the live preview, you will have to   modify the container settings again. Therefore, it is recommended to stop the live preview   only after you finished working on the documentation. </li> </ul>","location":"documentation/BuildTheDocumentationLocally/#preview-the-documentation-locally"},{"title":"How to edit the documentation","text":"","location":"documentation/howToEdit/"},{"title":"How to edit this documentation","text":"","location":"documentation/howToEdit/#how-to-edit-this-documentation"},{"title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,    see the download page.</li> </ul>","location":"documentation/howToEdit/#prerequisites"},{"title":"Edit a page","text":"<ul> <li>Open Ikarus in Clion</li> <li>go the folder <code>docs\\website</code></li> <li>find the markdown file which corresponds to the page you want to edit</li> <li>Apply your changes (can be done directly in CLion or in external tools e.g. Sublime Text)</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>","location":"documentation/howToEdit/#edit-a-page"},{"title":"Add a new page","text":"<ul> <li>Open Ikarus in Clion</li> <li>go the folder <code>docs\\website</code> and create a new markdown-File,    e.g. <code>MyAdditionalPage.md</code></li> <li>Open the file <code>docs\\mkdocs.yml</code></li> <li>Find the navigation section which starts with <code># Navigation</code></li> <li>The navigation section describes the navigation on the left side of the website. Add <code>MyAdditionalPage.md</code> where you want it to appear</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>","location":"documentation/howToEdit/#add-a-new-page"},{"title":"Insert a latex formula","text":"<p><code>$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$</code>  is compiled to</p> \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]","location":"documentation/howToEdit/#insert-a-latex-formula"},{"title":"Insert C++ code","text":"<p>The C++ code: <pre><code>double complicatedCalculation(double number, double anotherNumber) \n{\n  return number*anotherNumber;\n};\n</code></pre> How it needs to be written in markdown: <pre><code>    ```cpp\n    double complicatedCalculation(double number, double anotherNumber) \n    {\n      return number*anotherNumber;\n    };\n    ```\n</code></pre></p>","location":"documentation/howToEdit/#insert-c-code"},{"title":"Insert a table","text":"<p>Look at the markdown file of this page to see how a table can be inserted.</p>    Grid Entity Interface      <code>GridViewType leafGridView()</code>    <code>GridViewType levelGridView(int level)</code>      <p>Insert a warning</p> <p>Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.</p>   <p>References</p> <p>For available features in the documentation see Mkdocs-Material and Mkdocs.</p>","location":"documentation/howToEdit/#insert-a-table"},{"title":"Overview","text":"","location":"tutorials/tutorialsOverview/"},{"title":"Tutorials","text":"<p>This section explains the practical use of several parts and provides examples that you can use as a starting point for your work. It does not describe the impl theory.</p> <p>of various parts of the code. It is dedicated to users who want to extend or modify the implemented functionality or who want to learn more about  the impl thoughts and theoretical aspects.</p> <p>If you are rather interested in the theoretical background  and implementation details, visit the theory and class reference section.</p>","location":"tutorials/tutorialsOverview/#tutorials"},{"title":"Topics","text":"<ul> <li>To be added</li> </ul>","location":"tutorials/tutorialsOverview/#topics"}]}
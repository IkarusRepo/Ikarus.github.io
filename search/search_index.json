{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"Home","text":"","location":""},{"title":"Welcome to the documentation of Ikarus","text":"<p>Ikarus is a C++-based library built within the finite element architecture. It originated at the Institute for Structural Mechanics at the University of Stuttgart.</p> <p>This project tries to provide an easy-to-read and an easy-to-use finite element framework. It is heavily inspired by the finite element software DUNE, the book DUNE \u2014 The Distributed and Unified Numerics Environment, deal.II and Kratos. Furthermore, it directly uses several modules from DUNE.</p> <p>The design of CI and the documentation were inspired by Autodiff  and Kratos.</p> <p>The documentation is built using Material for MkDocs.</p> <p>Ikarus provides the tools to create one's own examples and rapidly prototype finite element solution algorithms.  This is done by using template metaprogramming in C++ to write generic code, which is compiled for the example.</p>","location":"#welcome-to-the-documentation-of-ikarus"},{"title":"Download","text":"","location":"download/"},{"title":"Installation of Ikarus","text":"<p>Change links on this website when final accounts for repository and docker container are fixed and remove this warning.</p>  <p>Graphical output is currently not supported on Windows 10 (but will probably be available in the future). Therefore, working on Windows 11 is recommended.</p> <p>The installations on Windows relies on WSL 2, i.e. although working with Windows, the code is compiled and executed in Linux.</p>","location":"download/#installation-of-ikarus"},{"title":"Installation on Windows using Docker Container and Clion","text":"<ol> <li>Install WSL: Open the PowerShell as an admin and execute the following commands. Reboot afterwards, if requested. <pre><code>wsl --install\nwsl --set-default-version 2 #(Is not needed for Windows 11)\n</code></pre></li> <li>Download and install Docker for Windows.   During the installation, select the option \"Install required Windows components for WSL 2\"</li> <li>Install debian from WindowsAppStore<ol> <li>Open the debian app</li> <li>Give yourself a username and password</li> <li>Close the debian app</li> </ol> </li> <li>Open the PowerShell and execute: <pre><code>wsl --list --all\n</code></pre> <code>Debian</code> should appear as one of the available Linux distributions.</li> <li>In the PowerShell execute: <pre><code>wsl --setdefault Debian\n</code></pre></li> <li>Try to start Docker. If it works, continue with the next step. If a message occurs that you are not allowed to use docker because     you are not in the docker user group, follow these instructions.     In short:<ol> <li>Open computer management as admin</li> <li>Go to Local users and groups and find docker-users</li> <li>Add your Account (or a group of which you are a member) to the group.</li> <li>Restart your computer</li> </ol> </li> <li>In Docker, go to Settings \u2192 General and select autostart for docker     (otherwise you have to start it manually each time you want to work with Ikarus).</li> <li> <p>In the Docker settings, select that Docker uses your WSL2 distribution Debian as shown in the picture.     </p> <p>In cases docker says that you don't have a WSL 2 distribution, go to the PowerShell and execute <pre><code>wsl --set-default-version 2 #(just to be sure that you didn't forgot this at the beginning)\nwsl --set-version Debian 2 #(Converts debian to version 2)\n</code></pre> You should now be able to change the docker settings according to the picture above.</p> </li> <li> <p>Open the PowerShell and execute: <pre><code>docker pull rath3t/ikarus-dev:latest #if you want to develop in Ikarus\ndocker pull rath3t/ikarus:latest #if you want to use Ikarus to run your own main file as in https://github.com/ikarus-project/ikarus-examples\n</code></pre></p> </li> <li>Download and install CLion. You need a version &gt;=2022.1.</li> <li>In CLion, go to File and Settings and apply the following settings for the toolchain:          Edit the Container settings and paste the following command into <code>Run options</code>: <pre><code>-e DISPLAY=:0 -v \\\\wsl$\\debian\\mnt\\wslg\\.X11-unix:/tmp/.X11-unix -v \\\\wsl$\\debian\\mnt\\wslg:/mnt/wslg --cap-add=SYS_PTRACE\n</code></pre></li> <li>Clone Ikarus</li> </ol>","location":"download/#installation-on-windows-using-docker-container-and-clion"},{"title":"Clone Ikarus","text":"<ul> <li>Clone the Ikarus repository.</li> <li>Open the <code>CMake</code> tab in the CLion footer:   </li> <li>Click on <code>Reload CMake project</code> (refresh symbol):   </li> <li>CMake now detects all required sources automatically. The output should look similar to   the screenshot below:   </li> </ul>","location":"download/#clone-ikarus"},{"title":"Installation on Linux","text":"<ol> <li>If you have docker available, simply pull the container with Ikarus installed to start developing. <pre><code>docker pull rath3t/ikarus:latest\n</code></pre></li> <li>Log in to the container via <pre><code>docker container run -it --entrypoint /bin/bash  rath3t/ikarus:latest\n</code></pre></li> <li>Instead of point 2, one can now also follow the documentation above if Clion on Linux is preferred.</li> </ol>","location":"download/#installation-on-linux"},{"title":"Gallery","text":"","location":"gallery/"},{"title":"Gallery","text":"<p>In the future, several figures from simulations performed via Ikarus will be found here.</p>","location":"gallery/#gallery"},{"title":"Index","text":"","location":"01_framework/"},{"title":"Framework","text":"<pre><code>classDiagram \n  GridView &lt;-- Grid\n  GlobalBasis &lt;-- GridView\n  Assembler &lt;-- GlobalBasis\n  NonlinearOperator &lt;-- Assembler\n  Assembler &lt;-- FiniteElement\n  FiniteElement &lt;-- FERequirements\n  FERequirements &lt;|-- ResultRequirements\n  FiniteElement &lt;-- ResultRequirements\n  FiniteElement &lt;-- Local function\n  Localfunction &lt;-- Localbasis\n  GlobalBasis &lt;--&gt; Localbasis\n  Localfunction &lt;-- Manifold\n  NonlinearSolver &lt;-- NonlinearOperator\n  NonlinearSolver &lt;-- LinearSolver\n  Controlroutine &lt;-- NonlinearSolver\n  VTKWriter &lt;-- Controlroutine\n  DirichletConditions .. Assembler\n  DirichletConditions .. Controlroutine\n  Controlroutine &lt;|-- IObservable\n  NonlinearSolver &lt;|-- IObservable\n  Observer ..&gt; IObservable\n  FErequirementsBuilder &lt;-- Affordances\n  Affordances &lt;-- ScalarAffordances\n  Affordances &lt;-- VectorAffordances\n  Affordances &lt;-- MatrixAffordances\n  ResultRequirementsBuilder &lt;-- ResultType\n\n\n  class ScalarAffordances{\n  &lt;&lt;enumeration&gt;&gt;\n      mechanicalPotentialEnergy\n      microMagneticPotentialEnergy\n      ...\n  }\n\n  class VectorAffordances{\n        &lt;&lt;enumeration&gt;&gt;    \n      forces\n      microMagneticForces\n      ...\n  }\n\n  class MatrixAffordances{\n        &lt;&lt;enumeration&gt;&gt;\n      stiffness\n      materialstiffness\n      geometricstiffness\n      mass\n      stiffnessdiffBucklingVector\n      microMagneticHessian\n      ...\n  }\n\n  class ResultType{\n      &lt;&lt;enumeration&gt;&gt;\n      noType\n      magnetization\n      gradientNormOfMagnetization\n      vectorPotential\n      divergenceOfVectorPotential\n      BField\n      HField\n      cauchyStress\n      director\n      ...\n  }\n\n  class Observer{\n    +update()\n  }\n\n  class DirichletConditions{\n  TBA\n  }\n\n  class IObservable{\n    +subscribe()\n    +subscribeAll()\n    +unSubscribe()\n    +unSubscribeAll()\n    +notify()\n  }\n\n  class FERequirements{\n    +hasAffordance()\n    +getGlobalSolution()\n    +getParameter()\n  } \n\n  class ResultRequirements{\n    +isResultRequested()\n    +getParameter()\n  }\n\n  class Assembler{\n    +getScalar()\n    +getVector()\n    +getMatrix()\n    +getReducedMatrix()\n    +getReducedVector()\n    +createFullVector()\n  }\n  class GridView{\n    +elements(gridView)\n    +vertices(gridView)\n    +edges(gridView)\n    +surfaces(gridView)\n  }\n  class Controlroutine{\n    +run()\n  }\n\n  class NonlinearSolver{\n    +setup()\n    +solve()\n    +nonLinearOperator()\n  }\n\n  class GlobalBasis{\n    +localView()\n  }\n\n    class Grid{\n    +leafGridView()\n  }\n\n  class FiniteElement{\n  +calculateScalar()\n  +calculateVector()\n  +calculateMatrix()\n  +calculateAt()\n  }\n\n  class LinearSolver{\n    +analyzePattern()\n    +factorize()\n    +compute()\n    +solve()\n  }\n  class NonlinearOperator{\n    +value()\n    +derivative()\n    +secondDerivative()\n    +nthDerivative&lt;n&gt;()\n    +subOperator()\n}\n\n  class Localfunction{\n    +calculateFunction()\n    +calculateDerivative()\n    +bind()\n    +viewOverIntegrationPoints()\n  }  \n\n  class Localbasis{\n    +calculateFunction()\n    +evaluateJacobian()\n    +bind()\n    +isBound()\n    +viewOverIntegrationPoints()\n  }  \n\n  class Manifold{\n    +setValue()\n    +operator+=()\n    +getValue()\n    +size()\n    +size()\n  }\n\nclick NonlinearOperator href \"../nonlinearOperator/\" \nclick LinearSolver href \"../solvers/#linear-solver\" \nclick NonlinearSolver href \"../solvers/#non-linear-solver\" \nclick FiniteElement href \"../finiteElements/\" \nclick GridView href \"../grid/\" \nclick Grid href \"../grid/\" \nclick Controlroutine href \"../controlRoutines/\" \nclick Assembler href \"../assembler/\" \nclick Localfunction href \"../localFunctions/\" \nclick Manifold href \"../manifolds/\" \nclick Localbasis href \"../localBasis/\" \nclick FERequirements href \"../feRequirements/\" \nclick FErequirementsBuilder href \"../feRequirements/\" \nclick ResultRequirements href \"../feRequirements/#fe-result-requirements\" \nclick ResultRequirementsBuilder href \"../feRequirements/#fe-result-requirements\" \nclick Affordances href \"../feRequirements/\" \nclick ResultType href \"../feRequirements/\" \nclick IObservable href \"../observer/#iobservable\" \nclick Observer href \"../observer/#iobserver\" \nclick GlobalBasis href \"../globalBasis/\" \n</code></pre>","location":"01_framework/#framework"},{"title":"Assembler","text":"","location":"01_framework/assembler/"},{"title":"Assembler","text":"<p>The purpose of an assembler is to assemble local quantities (local stiffness matrix, local force vector, local energy, etc.)  by looping over finite elements and thereby arriving at a global structure. This page describes the available assemblers and how they can be used.</p> <p>Each of the assemblers is constructed as follows: <pre><code>AssemblerName(const Basis&amp; basis, const FEContainer&amp; fes, const std::vector&lt;bool&gt;&amp; dirichletFlags)\n</code></pre></p> <ul> <li><code>basis</code> is the basis that was used to construct the finite elements. The implementation of the bases involves four different strategies: <code>BlockedLexicographic</code>, <code>BlockedInterleaved</code>, <code>FlatLexicographic</code> and <code>FlatInterleaved</code>. These strategies are to be considered while creating the assembler. For further information on these strategies, refer to Chapter 10 of DUNE1.  </li> <li><code>fes</code> is a container that contains all the finite elements that should be assembled.</li> <li><code>dirichletFlags</code> is a <code>std::vector&lt;bool&gt;</code> type. The <code>i</code>-th degree of freedom is fixed when <code>dirichletFlags[i] = true</code>.   When a reduced matrix or vector is chosen, the corresponding row and column entries are removed. </li> </ul>","location":"01_framework/assembler/#assembler"},{"title":"FlatAssemblerBase","text":"<p>The FlatAssemblerBase is the base for all assemblers currently available. All other assemblers inherit from this one,  i.e., their interface includes the following functions: <pre><code>size_t size() // (1)\nsize_t reducedSize() // (2)\nauto &amp;finiteElements() const // (3)\nEigen::VectorXd createFullVector(const Eigen::VectorXd &amp;reducedVector) // (4)\nsize_t constraintsBelow(size_t i) // (5)\nbool isConstrained(size_t i) // (6)\nsize_t estimateOfConnectivity() // (7)\n</code></pre></p> <ol> <li>Returns the number of degrees of freedom.</li> <li>Returns the number of degrees of freedom that are not constrained by a Dirichlet boundary condition.</li> <li>Returns a reference to the finite element container, which was passed to the assembler.</li> <li>Gets a reduced vector and returns a full vector. Entries corresponding to fixed dofs are set to 0. The values of the other entries are     obtained from the reduced vector.</li> <li>Indicates how many degrees of freedom {0,1,...i-1} are fixed.</li> <li>Indicates whether the degree of freedom <code>i</code> is fixed.</li> <li>Returns 8x the number of grid elements, which is an estimate for the connectivity. It can be used to allocate vectors.</li> </ol>","location":"01_framework/assembler/#flatassemblerbase"},{"title":"ScalarAssembler","text":"<p>It has the capabilities of FlatAssemblerBase plus one additional function: <pre><code>double&amp; getScalar(const RequirementType&amp; fErequirements)\n</code></pre> This assembler can be used when only a scalar quantity is of interest and the assembly of matrices or vectors is irrelevant. The available requirements are explained on the FE requirements page. <code>dirichletFlags</code> is not used in this assembler.</p> <p>It assembles the requested scalar quantity. A call to this function could look like this: <pre><code>ScalarAssembler myAssembler(...) // (1)\nconst auto&amp; K = myAssembler.getScalar(feRequirements) // (2)\n</code></pre></p> <ol> <li>Represents the construction of the desired assembler.</li> <li>To learn more about the available alternatives to <code>energy</code> and how this works, read the FE requirements page.</li> </ol>","location":"01_framework/assembler/#scalarassembler"},{"title":"VectorFlatAssembler","text":"<p>It has all the features of ScalarAssembler plus more, like: <pre><code>Eigen::VectorXd&amp; getVector(const RequirementType&amp; fErequirements)\nEigen::VectorXd&amp; getReducedVector(const RequirementType&amp; fErequirements)\n</code></pre> As the name suggests, the full vector or a reduced vector considering boundary conditions is returned. They work in the same way as the scalar assembly functions of ScalarAssembler. The available FE requirements are explained on the FE requirements page.</p>","location":"01_framework/assembler/#vectorflatassembler"},{"title":"SparseFlatAssembler","text":"<p>It offers the functions of VectorFlatAssembler plus more, like: <pre><code>Eigen::SparseMatrix&lt;double&gt; &amp;getMatrix(const RequirementType &amp;fErequirements)\nEigen::SparseMatrix&lt;double&gt; &amp;getReducedMatrix(const RequirementType &amp;fErequirements)\n</code></pre> A sparse matrix is returned. They work in the same way as the vector assembly functions of VectorFlatAssembler. The available FE requirements are explained on the FE requirements page.</p>","location":"01_framework/assembler/#sparseflatassembler"},{"title":"DenseFlatAssembler","text":"<p>The only difference between the SparseFlatAssembler and the DenseFlatAssembler is that the DenseFlatAssembler returns a dense matrix. <pre><code>Eigen::MatrixXd &amp;getMatrix(const RequirementType &amp;fErequirements)\nEigen::MatrixXd &amp;getReducedMatrix(const RequirementType &amp;fErequirements)\n</code></pre></p>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/assembler/#denseflatassembler"},{"title":"Control routines","text":"","location":"01_framework/controlRoutines/"},{"title":"Control routines","text":"","location":"01_framework/controlRoutines/#control-routines"},{"title":"Load control","text":"<p>A load control object is constructed as follows: <pre><code>auto lc = Ikarus::LoadControl(nonlinearSolver, numLoadSteps, {loadFactorStartValue, loadFactorEndValue});\n</code></pre></p> <ul> <li><code>nonlinearSolver</code> is a nonlinear solver, e.g., Newton-Raphson method, trust-region method, etc.</li> <li><code>numLoadSteps</code> is the number of load steps.</li> <li><code>loadFactorStartValue</code> is the value of the load factor at the beginning of the simulation.</li> <li><code>loadFactorEndValue</code> is the value of the load factor at the end of the simulation.</li> </ul> <p>The load control is started with the <code>run()</code> method, i.e., for the above-mentioned example: <pre><code>lc.run();\n</code></pre></p>","location":"01_framework/controlRoutines/#load-control"},{"title":"Obtaining information from control routines","text":"<p>The load control is an observable object, i.e. one can subscribe to the messages of the load control method. To read further on the implementation of observer patterns in Ikarus, see here.</p> <p>The following messages are available: <pre><code>enum class ControlMessages { \n  BEGIN,\n  CONTROL_STARTED,\n  CONTROL_ENDED,\n  STEP_STARTED,\n  STEP_ENDED,\n  SOLUTION_CHANGED,\n  END \n};\n</code></pre></p>","location":"01_framework/controlRoutines/#obtaining-information-from-control-routines"},{"title":"Path-following techniques","text":"<p>A general routine based on the standard arc-length method is included, which uses a scalar subsidiary function to impose  a constraint on the non-linear system of equations. The previously mentioned LoadControl method can also be recreated  using this technique. For more details on the standard arc-length method, see, among others, the works  of Wempner1, Crisfield2, Ramm3 and  Riks4 among others. A path-following object is constructed as follows: <pre><code>auto alc = Ikarus::PathFollowing(nr, load_steps, stepSize, pft);\n</code></pre> where <code>nr</code> is a Newton-Raphson solver which considers a scalar subsidiary function and is defined by <pre><code>auto nr = Ikarus::makeNewtonRaphsonWithSubsidiaryFunction(nonLinOp, std::move(linSolver));\n</code></pre> and <code>pft</code> is the desired path-following technique. Three different path-following techniques are included, namely</p> <ul> <li>Standard arc-length method</li> <li>Load control method (as a subsidiary function under this generalized implementation)</li> <li>Displacement control method (uses a vector of indices which are all controlled by a same <code>stepSize</code>).</li> </ul> <p>These can be invoked by defining  <pre><code>auto pft = Ikarus::StandardArcLength{};\nauto pft = Ikarus::LoadControlWithSubsidiaryFunction{};\nauto pft = Ikarus::DisplacementControl{controlledIndices};\n</code></pre></p>  <p>Note</p> <p>The default path-following type is the <code>Ikarus::StandardArcLength{}</code>. In the current implementation, it is assumed that the external forces are given by  \\(F_{ext} = F_{ext}^0\\lambda\\) such that  $$ -\\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = F_{ext}^0 $$ An implementation for a general non-linear \\(F_{ext} = F_{ext}^0\\left(\\mathbf{D},\\lambda\\right)\\) is an open task.</p>  <p>In order to create an own implementation for the scalar subsidiary function, the user has to create a <code>struct</code>  with the following three member functions: <pre><code>void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const;\nvoid initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\nvoid intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args);\n</code></pre> For each Newton-Raphson iteration, the function <code>evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args)</code> is used to evaluate the subsidiary function and  its derivatives with respect to the displacement \\(\\mathbf{D}\\) and the load factor \\(\\lambda\\). The other two functions  are used to specify a prediction for \\(\\mathbf{D}\\) and \\(\\lambda\\) for the initial step and for  all the other intermediate subsequent <code>load_steps</code>, respectively.   </p> <p><code>SubsidiaryArgs</code> is a <code>struct</code> which is defined as <pre><code>struct SubsidiaryArgs {\n  double stepSize; // (1)\n  Eigen::VectorX&lt;double&gt; DD; // (2)\n  double Dlambda{}; // (3)\n  double f{}; // (4)\n  Eigen::VectorX&lt;double&gt; dfdDD; // (5)\n  double dfdDlambda{}; // (6)\n};\n</code></pre></p> <ol> <li>User-desired step size</li> <li>Vector of displacement increments</li> <li>Increment in the load factor</li> <li>Scalar value evaluated from the subsidiary function</li> <li>Derivative of the subsidiary function with respect to the displacement increment</li> <li>Derivative of the subsidiary function with respect to the load factor increment</li> </ol> <p>An example for the standard arc-length method is shown below: <pre><code>struct StandardArcLength {\n    void evaluateSubsidiaryFunction(SubsidiaryArgs&amp; args) const {\n      if (psi) {\n        const auto root = sqrt(args.DD.squaredNorm() + psi.value() * psi.value() * args.Dlambda * args.Dlambda);\n        args.f          = root - args.stepSize;\n        args.dfdDD      = args.DD / root;\n        args.dfdDlambda = (psi.value() * psi.value() * args.Dlambda) / root;\n      } else\n        DUNE_THROW(Dune::InvalidStateException,\n                   \"You have to call initialPrediction first. Otherwise psi is not defined\");\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void initialPrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      auto linearSolver\n          = Ikarus::ILinearSolver&lt;double&gt;(Ikarus::SolverTypeTag::d_LDLT);  // for the linear predictor step\n\n      nonLinearOperator.lastParameter() = 1.0;  // lambda =1.0\n\n      nonLinearOperator.template update&lt;0&gt;();\n      const auto&amp; R = nonLinearOperator.value();\n      const auto&amp; K = nonLinearOperator.derivative();\n\n      linearSolver.factorize(K);\n      linearSolver.solve(args.DD, -R);\n\n      const auto DD2 = args.DD.squaredNorm();\n\n      psi    = sqrt(DD2);\n      auto s = sqrt(psi.value() * psi.value() + DD2);\n\n      args.DD      = args.DD * args.stepSize / s;\n      args.Dlambda = args.stepSize / s;\n\n      nonLinearOperator.firstParameter() = args.DD;\n      nonLinearOperator.lastParameter()  = args.Dlambda;\n    }\n\n    template &lt;typename NonLinearOperator&gt;\n    void intermediatePrediction(NonLinearOperator&amp; nonLinearOperator, SubsidiaryArgs&amp; args) {\n      nonLinearOperator.firstParameter() += args.DD;\n      nonLinearOperator.lastParameter() += args.Dlambda;\n    }\n\n    std::string name = \"Arc length\";\n\n  private:\n    std::optional&lt;double&gt; psi;\n  };\n</code></pre></p>   <ol> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/controlRoutines/#path-following-techniques"},{"title":"Dirichlet boundary conditions","text":"","location":"01_framework/dirichletBCs/"},{"title":"Dirichlet boundary conditions","text":"","location":"01_framework/dirichletBCs/#dirichlet-boundary-conditions"},{"title":"Introduction","text":"<p>In finite element problems, it is essential to incorporate the Dirichlet boundary conditions, i.e.,  prescribing a part of the solution to a fixed value. Let us consider the following:</p> <p>$$  \\boldsymbol{u} = \\boldsymbol{g} \\quad \\text{on  } \\Gamma_\\mathrm{D}. $$ Here \\(  \\boldsymbol{u} \\) is the solution field with a prescribed value \\(\\boldsymbol{g}\\) on the boundary \\(\\Gamma_\\mathrm{D}\\).</p> <p>For the discrete algebraic problem, this translates to fixing the values of \\(u_i\\) to \\(g_i\\) in the approximation \\(  \\boldsymbol{u}^h = \\sum_i N^i u_i \\), where \\(  N^i \\) is the \\(i\\)-th ansatz function.</p> <p>The handling of such a function \\(\\boldsymbol{g}\\) is done by the class <code>Ikarus::DirichletValues</code>.</p>","location":"01_framework/dirichletBCs/#introduction"},{"title":"Interface","text":"<p>The interface of <code>Ikarus::DirichletValues</code> is represented by the following code snippet: <pre><code>Ikarus::DirichletValues dirichletValues2(basis); // (1)\nvoid fixBoundaryDOFs(f); // (2)\nvoid fixDOFs(f); // (3)\nconst auto&amp; basis() const; // (4)\nbool isConstrained(std::size_t i) const; // (5)\nauto fixedDOFsize() const; // (6)\nauto size() const ; // (7) \n</code></pre></p> <ol> <li>Create class by inserting a global basis, 1 Chapter 10.</li> <li>Accepts a functor to fix boundary degrees of freedom. <code>f</code> is  a functor that will be called with the boolean vector of fixed boundary.  degrees of freedom and the usual arguments of <code>Dune::Functions::forEachBoundaryDOF</code>,  as defined on page 388 of the Dune1 book.</li> <li>A more general version of <code>fixBoundaryDOFs</code>. Here, a functor is to be provided that accepts a basis and the corresponding boolean vector considering the Dirichlet degrees of freedom.</li> <li>Returns the underlying basis.</li> <li>Indicates whether the degree of freedom <code>i</code> is fixed.</li> <li>Returns the number of fixed degrees of freedom.</li> <li>Returns the number of all dirichlet degrees of freedom.</li> </ol>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9\u21a9</p> </li> </ol>","location":"01_framework/dirichletBCs/#interface"},{"title":"FE requirements","text":"","location":"01_framework/feRequirements/"},{"title":"FE requirements","text":"<p>Finite element requirements are a simple way to communicate the needs and expectations of a finite element.</p> <p>FE requirements are used to pass information from assemblers to finite elements. </p>","location":"01_framework/feRequirements/#fe-requirements"},{"title":"Construction and usage","text":"<p>Usually the construction is as follows: <pre><code>FErequirements req = FErequirements()\n                           .insertGlobalSolution(FESolutions::displacement, d)\n                           .insertParameter(FEParameter::loadfactor, lambda)\n                           .addAffordance(MatrixAffordances::stiffness);\nMatrixType A = sparseFlatAssembler.getReducedMatrix(req);\n</code></pre></p> <p>All the methods return a reference to <code>FErequirements</code>, so they can be chained together.</p> <p>As in line 2, the finite element solution can also be inserted. The solution is passed with the <code>enum</code> type  <code>FESolutions::displacement</code> vector <code>d</code>. This stores a reference to the vector.</p> <p>Additionally, if some parameters are to be passed, use the method <code>insertParameter</code> (line 3), where, similar to the  global solutions, an <code>enum</code> type of <code>FEParameter::loadfactor</code> is passed to indicate the meaning of the parameter,  followed by its value.</p> <p>Finally, the method <code>addAffordance</code> is used to indicate the request required from the finite element. Thus, there exist scalar, vector, matrix and general affordance collections.</p> <p>Currently, the following are defined:</p> <pre><code>  enum class ScalarAffordances {\n    noAffordance,\n    mechanicalPotentialEnergy,\n    microMagneticPotentialEnergy\n  };\n\n  enum class VectorAffordances {\n    noAffordance,\n    forces,\n    microMagneticForces\n  };\n\n  enum class MatrixAffordances {\n    noAffordance,\n    stiffness,\n    materialstiffness,\n    geometricstiffness,\n    stiffnessdiffBucklingVector,\n    microMagneticHessian,\n    mass\n  };\n\n  enum class FEParameter {\n    noParameter,\n    loadfactor,\n    time\n  };\n\n  enum class FESolutions {\n    noSolution,\n    displacement,\n    velocity,\n    director,\n    magnetizationAndVectorPotential\n  };\n</code></pre> <p>Inside the finite element, the information can then be conveniently extracted: <pre><code>const auto&amp; d      = req.getGlobalSolution(FESolutions::displacement);\nconst auto&amp; lambda = req.getParameter(FEParameter::loadfactor);\nif(req.hasAffordance(stiffness))\n  ...\n</code></pre> Thus, the local finite element can be developed.</p>  <p>Affordance<p>It is good style to indicate that you cannot fulfill an affordance by throwing an appropriate exception!</p> </p>","location":"01_framework/feRequirements/#construction-and-usage"},{"title":"FE result requirements","text":"<p>In addition to the above-mentioned finite element requirements, there are also result requirements.  They accept the same parameter types as the <code>FErequirements</code> and add one more, the <code>ResultType</code>. These are used in the <code>calculateAt</code> method of finite elements. They are used to communicate the results required from the finite elements.</p> <p>Its construction is shown below: <pre><code>ResultRequirements resultRequirements = Ikarus::ResultRequirements()\n        .insertGlobalSolution(FESolutions::displacement, d)\n        .insertParameter(FEParameter::loadfactor, lambda)\n        .addResultRequest(ResultType::cauchyStress,,ResultType::director);\n</code></pre></p> <p>The current supported results are:</p> <pre><code>  enum class ResultType {\n    noType,\n    magnetization,\n    gradientNormOfMagnetization,\n    vectorPotential,\n    divergenceOfVectorPotential,\n    BField,\n    HField,\n    cauchyStress,\n    director\n  };\n</code></pre> <p>The interface for result requirements is similar to the finite element requirements. They do, however, support querying specific results to be calculated.</p> <pre><code>if( req.isResultRequested( ResultType::cauchyStress)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::BField)) {\n  ...\n}\n\nif( req.isResultRequested( ResultType::director)) {\n  ...\n}\n</code></pre>","location":"01_framework/feRequirements/#fe-result-requirements"},{"title":"Finite elements","text":"","location":"01_framework/finiteElements/"},{"title":"Finite elements","text":"<p>Several disciplines associate finite elements with different meanings. In Ikarus, finite elements have two different objectives. The first one is to provide an evaluation of the scalars, vectors, and matrices.  These are associated with an algebraic representation of discrete energies, weak forms, or bilinear forms. These algebraic objects are usually constructed using some combination of local functions and  parameters stemming from the underlying physical problem, e.g., load factor, Young's modulus, or viscosity.</p> <p>The second task of finite elements is to evaluate derived results in the element parameter space, e.g., stresses or geometric quantities. This leads to the following interface for the finite elements:</p>","location":"01_framework/finiteElements/#finite-elements"},{"title":"Interface","text":"<p>Local functions provide the following interface <pre><code>ScalarType evaluateScalar(const FErequirements&amp; req);\nvoid evaluateVector(const FErequirements&amp; req, VectorType&amp; b);\nvoid evaluateMatrix(const FErequirements&amp; req, MatrixType&amp; A);\nvoid calculateLocalSystem(const FErequirements&amp; req, MatrixType&amp; A, VectorType&amp; b);\nvoid calculateAt(const Resultrequirements&amp; req, const Eigen::Vector&lt;double, Traits::mydim&gt;&amp; local,\n                     ResultTypeMap&lt;ScalarType&gt;&amp; result);\nvoid globalIndices(std::vector&lt;GlobalIndex&gt;&amp; globalIndices);\n</code></pre></p> <p>Please refer to the FE requirements to learn more about the finite element requirements and result requirements.  The first four methods receive an object of type <code>FErequirements</code>. This object is responsible for passing different types of information needed for the local evaluation of the local linear algebra objects. The first method, <code>evaluateScalar</code>, simply returns by value because it is cheaper to return a <code>double</code>, for example when evaluating energy. The other methods, <code>evaluateVector</code>, <code>evaluateMatrix</code>, and <code>calculateLocalSystem</code>, receive one or two additional output arguments where the results are to be written. This interface is needed to circumvent the dynamic memory allocation, that is required if these methods return by value.</p> <p>The method <code>calculateAt</code> is responsible for evaluating several results, and it receives the <code>ResultRequirements</code> object. These results are stored inside the output argument <code>result</code>, which is of the type <code>ResultTypeMap</code>. Additionally, there is the argument <code>local</code>, which contains the element coordinates where the results are to be evaluated.</p> <p>A typical <code>calculateAt</code> method is implemented as shown below: </p> <pre><code>typename ResultTypeMap&lt;double&gt;::ResultArray res;\nif(req.isResultRequested( ResultType::gradientNormOfMagnetization)) {\n  res.resize(1,1);\n  res(0,0)=...;\n  result.insertOrAssignResult(ResultType::gradientNormOfMagnetization,res);\n}\nif(req.isResultRequested( ResultType::BField)) {\n  res.setZero(3,1);\n  res=...;\n  result.insertOrAssignResult(ResultType::BField,res);\n}\nif(req.isResultRequested( ResultType::cauchyStress)) {\n  res.setZero(3,3);\n  res = ...;\n  result.insertOrAssignResult(ResultType::cauchyStress,res);\n}\n</code></pre>  <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code></p> <p><code>ResultTypeMap&lt;double&gt;::ResultArray</code> is an object of type <code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,0,3,3&gt;</code>. Thus, the maximum size of <code>result</code> is limited to a 3x3 matrix. This is used to circumvent dynamic memory allocations again.</p>  <p>The last method is the <code>globalIndices</code>. It is used to write a finite element's global indices to the output parameter <code>globalIndices</code>. This information originates from a <code>basis</code> object. See existing implementations for details.</p>","location":"01_framework/finiteElements/#interface"},{"title":"Linear and Non-linear Elasticity","text":"<ul> <li>To be added</li> </ul>","location":"01_framework/finiteElements/#linear-and-non-linear-elasticity"},{"title":"Enhanced Assumed Strain Elements","text":"<p>The Enhanced Assumed Strain (EAS) elements are a class of finite elements that helps to avoid the locking phenomenon. They are obtained by re-parametrizing the Hu-Washizu principle and enforcing an orthogonality condition.  This results in an extension of the standard pure displacement formulation with an enhanced strain field (\\(\\tilde\\epsilon\\))  as an additional independent variable.The locking characteristics of the pure displacement formulations can be eliminated with an appropriate choice of ansatz space for \\(\\tilde\\epsilon\\). For further theoretical aspects, the readers are referred to 1  and 2. The EAS formulation is currently implemented for the linear-elastic case, but  it could be extended to the non-linear regime. The currently implemented EAS elements are the following:</p> <ul> <li>Q1E4</li> <li>Q1E5</li> <li>Q1E7</li> <li>H1E9</li> <li>H1E21</li> </ul> <p>The notation used here is described as follows: the first alphabet stands for a Quadrilateral (Q) or a Hexahedral (H) element. The second index denotes the order of the element. E stands for the EAS element, and the number following that denotes the  number of EAS parameters used to enhance the strain field. The only difference amongst various EAS formulations arises  from the matrix, \\(\\mathbf{M}\\) which is used to approximate the enhanced strain field. An example for the calculation of the  matrix \\(\\mathbf{M}\\) for a Q1E4 element is shown below: <pre><code>template &lt;typename Geometry&gt;\nstruct EASQ1E4 {\n  static constexpr int strainSize         = 3;\n  static constexpr int enhancedStrainSize = 4;\n\n  EASQ1E4() = default;\n  explicit EASQ1E4(const Geometry&amp; geometry)\n      : geometry{std::make_unique&lt;Geometry&gt;(geometry)}, T0InverseTransformed{calcTransformationMatrix2D(geometry)} {}\n\n  auto calcM(const Dune::FieldVector&lt;double, 2&gt;&amp; quadPos) const {\n    Eigen::Matrix&lt;double, strainSize, enhancedStrainSize&gt; M;\n    M.setZero(strainSize, enhancedStrainSize);\n    const double xi   = quadPos[0];\n    const double eta  = quadPos[1];\n    M(0, 0)           = 2 * xi - 1.0;\n    M(1, 1)           = 2 * eta - 1.0;\n    M(2, 2)           = 2 * xi - 1.0;\n    M(2, 3)           = 2 * eta - 1.0;\n    const double detJ = geometry-&gt;integrationElement(quadPos);\n    M                 = T0InverseTransformed / detJ * M;\n    return M;\n  }\n\n  std::unique_ptr&lt;Geometry&gt; geometry;\n  Eigen::Matrix3d T0InverseTransformed;\n};\n</code></pre> It is to be noted that the ansatz spaces for the matrix \\(\\mathbf{M}\\) are to be modified such that they fulfill the orthogonality  condition in the \\(\\left[0,1\\right]\\) element domain used in DUNE, in contrast to the \\(\\left[-1,1\\right]\\) usually found in  literature.</p> <p>In order to add a new EAS element, the following additions are to be made: </p> <ol> <li>Create a <code>struct</code> to calculate the matrix \\(\\mathbf{M}\\) as shown above exemplarily for the Q1E4 element.</li> <li>Add the new variant to the corresponding list of 2D and 3D variants as shown below: <pre><code>template &lt;typename Geometry&gt;\nusing EAS2DVariant = std::variant&lt;EASQ1E4&lt;Geometry&gt;, EASQ1E5&lt;Geometry&gt;, EASQ1E7&lt;Geometry&gt;&gt;;\ntemplate &lt;typename Geometry&gt;\nusing EAS3DVariant = std::variant&lt;EASH1E9&lt;Geometry&gt;, EASH1E21&lt;Geometry&gt;&gt;;\n</code></pre></li> <li>Finally, add the new EAS variant with an appropriate switch statement (as shown below) to automatically call the  desired functions <pre><code>void setEASType(int numberOfEASParameters) {\n    if constexpr (Traits::mydim == 2) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 4:\n          easVariant = EASQ1E4(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 5:\n          easVariant = EASQ1E5(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 7:\n          easVariant = EASQ1E7(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 2D case.\");\n          break;\n      }\n    } else if constexpr (Traits::mydim == 3) {\n      switch (numberOfEASParameters) {\n        case 0:\n          onlyDisplacementBase = true;\n          break;\n        case 9:\n          easVariant = EASH1E9(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        case 21:\n          easVariant = EASH1E21(DisplacementBasedElement::getLocalView().element().geometry());\n          break;\n        default:\n          DUNE_THROW(Dune::NotImplemented, \"The given EAS parameters are not available for the 3D case.\");\n          break;\n      }\n    }\n  }\n</code></pre></li> </ol> <p>If the number of EAS parameters is set to zero, the pure displacement formulation is then utilised for analysis.</p>   <ol> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/finiteElements/#enhanced-assumed-strain-elements"},{"title":"Grids","text":"","location":"01_framework/grids/"},{"title":"Grids","text":"<p>In the context of the finite element method, the terms \"elements\" and \"meshes\" are often used. Each element is linked with certain attributes. The finite element (FE) code should thus be able to evaluate these attributes.  Here are some examples of attributes and the capabilities expected from the FE code:</p> <ul> <li>element number - provide a unique identifier for each element</li> <li>element shape in physical space, shape functions, ... - provide a description of the geometry</li> <li>element mass matrix, element stiffness matrix, element internal force vector, ... - provide quantities with physical meaning</li> <li>and more ...</li> </ul> <p>In the FE code, there is not one single class that serves to provide all these attributes to an element.  Different goals are achieved by different classes. A group of elements along with their attributes connected to  discretize the actual physical space is called the mesh.</p> <p>In Ikarus and i.e. in Dune, the description of the grid is decoupled from the description of the mesh to preserve its physical meaning. This helps to have the flexibility of discretizing a simple square-shaped grid with different basis functions like  Langrange or NURBS bases with different polynomial orders. This helps to attain higher levels of abstraction and fewer  iterations of modifying the existing code while studying different grids or the effects of different bases.</p> <p>For the notions of grids, grid entities, and grid factories, the definitions of Dune are utilized. For details, see 1 Chapter 5. All the grids that satisfy the <code>dune::grid</code> interface can be used within the Ikarus framework. This link provides an overview of the available <code>dune::grid</code> modules.</p> <p>There also exists an IGA-based grid called dune-iga to perform isogeometric analysis (refer 2).</p> <p>It is important to note that the grid only provides geometric information and their relationship to their neighbors.  Even though geometry is typically constructed by some ansatz functions, grids do not provide this information to the  user because some global bases provide ansatz functions for the soultion fields. Thus, the user can choose if the  problem should be formulated using the iso-parametric concept, i.e., the same ansatz functions for geometry and  solution fields, or if the ansatz functions for the solution should be independent. The basis defined by Dune is directly  used here. Thus, they use the same interface. For details, see1 Chapter 10.</p>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9\u21a9</p> </li> <li> <p>J. Austin Cottrell, Thomas J. R. Hughes, and Yuri Bazilevs. Isogeometric Analysis: Toward Integration of CAD and FEA. Wiley, 2009.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/grids/#grids"},{"title":"Local basis","text":"","location":"01_framework/localBasis/"},{"title":"Local Basis","text":"<p>Each finite element includes a kind of local basis in terms of ansatz functions.  These ansatz functions need to be evaluated in the parameter domain of the finite element.</p>","location":"01_framework/localBasis/#local-basis"},{"title":"Interface","text":"<p>In the exported module <code>dune-localfefunctions</code>, we provide  a thin wrapper with basic caching functionality for dune bases. For the definitions of bases, refer Chapter 8.2.1 of the Dune book1. Thus <code>Dune::CachedLocalBasis</code> (<code>#include &lt;dune/cachedlocalBasis/cachedlocalBasis.hh&gt;</code>) provides the following interface: <pre><code>Dune::LocalBasis(const DuneLocalBasis&amp; p_basis)  // Constructor (1)\nvoid evaluateFunction(const DomainType&amp; local, Eigen::VectorX&lt;RangeFieldType&gt;&amp; N);\nvoid evaluateJacobian(const DomainType&amp; local,Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\nvoid evaluateFunctionAndJacobian(const DomainType&amp; local,Eigen::VectorX&lt;RangeFieldType&gt;&amp; N,\n                                 Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; dN);\n\nvoid evaluateSecondDerivatives(const DomainType&amp; local, Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim*(gridDim + 1) / 2&gt;&amp; dN);                                 \n\nconst Eigen::VectorX&lt;RangeFieldType&gt;&amp; evaluateFunction(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim&gt;&amp; evaluateJacobian(const unsigned int&amp; integrationPointIndex);\nconst Eigen::Matrix&lt;RangeFieldType, Eigen::Dynamic, gridDim*(gridDim + 1) / 2&gt;&amp; evaluateSecondDerivatives(const unsigned int&amp; integrationPointIndex);\nauto viewOverIntegrationPoints(); // (2)\nauto viewOverFunctionAndJacobian(); // (3)\n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt;\nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints);\n\nbool isBound(int i) const; // (4)\nconst Dune::QuadraturePoint&lt;DomainFieldType, gridDim&gt;&amp; indexToIntegrationPoint(int i) const; // (5)\n</code></pre></p> <ol> <li>The constructor only accepts a local basis that satisfies the concept <code>Concepts::DuneLocalBasis</code>. In keeping with the spirit of duck-typing, this also allows for the use of a local basis from the Dune module.</li> <li>This returns a vector of structs containing the integration point and its index. Therefore, the syntax is usually <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Returns a view over the  ansatz functions and the ansatz function Jacobians at the integration points</li> <li>Checks if the i-th derivatives are bounded.</li> <li>Convert an integration point index to a full integration point.</li> </ol> <p>The first two function calls, <code>evaluateFunction</code>  and <code>evaluateJacobian</code>, can be used to calculate the function values  \\( N(\\boldsymbol{\\xi}) \\) and the spatial derivatives \\( N_{,\\boldsymbol{\\xi}}(\\boldsymbol{\\xi}) \\). One must allocate the objects and pass them as mutable references. The same holds for <code>evaluateSecondDerivatives</code>.</p> <p>In contrast to this, there are three other methods that receive an integration point index.  These methods return a <code>const</code> reference to the evaluated ansatz function values and their first and second derivatives.</p> <p>This functionality is dependent on a previous call to <code>bind(...)</code>. This binds the local basis to one quadrature rule and caches the passed <code>bindDerivatives(..)</code>. An error is thrown if <code>evaluateFunction(const unsigned int&amp; integrationPointIndex)</code> is called before binding. Finally, to bind to an integration rule and cache the value and ansatz function Jacobian, one would use the following syntax:</p> Usage with integration point indexusing integration point coordinates   <pre><code>using LocalFEType = LagrangeSimplexLocalFiniteElement&lt;double,double,dim,2&gt;;\nLocalFEType localFE;\n\nDune::CachedLocalBasis(localFE.localBasis());\nconst auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView.element().type(), order);\nlocalBasis.bind(rule, bindDerivatives(0, 1));\n\nfor (const auto&amp; [gpIndex, gp] : localBasis.viewOverIntegrationPoints()) {\n  const auto&amp; N = localBasis.evaluateFunction(gpIndex);\n  const auto&amp; dN = localBasis.evaluateJacobian(gpIndex);\n}\n</code></pre>   <pre><code>using LocalFEType = LagrangeSimplexLocalFiniteElement&lt;double,double,dim,2&gt;;\nLocalFEType localFE;\n\nDune::CachedLocalBasis(localFE.localBasis());\nconst auto&amp; rule = Dune::QuadratureRules&lt;double, Traits::mydim&gt;::rule(localView.element().type(), order);\nEigen::VectorXd N;\nEigen::Matrix&lt;double, Eigen::Dynamic, gridDim&gt; dN;\n\nfor(auto&amp; gp : rule){\n  localFunction.evaluateFunction(gp.position(), N); \n  localFunction.evaluateJacobian(gp.position(), dN);\n  localFunction.evaluateFunctionAndJacobian(gp.position(), N, dN); // (1) \n}\n</code></pre> <ol> <li>Alternative to the two lines above (Line 6 and 7)</li> </ol>      <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/localBasis/#interface"},{"title":"Local functions","text":"","location":"01_framework/localFunctions/"},{"title":"Local functions","text":"<p>Local functions are functions that are bound to single grid elements. Therefore, they are constructed from some local basis, a coefficient vector, and the geometry of the grid element. Since the implementation is quite involved, <code>localfefunctions</code> do not reside at Ikarus but in the separate  module dune-localfefunctions.</p> <p>Usually, local functions are need to be evaluated in the local coordinate system \\( \\mathbb{\\xi} \\in T_{\\text{ref}} \\subset\\mathbb{R}^n \\) :</p> \\[ f: \\boldsymbol{\\xi}^n \\rightarrow \\mathbb{R}^m \\] <p>where \\(T_{\\text{ref}}\\) is the reference element, e.g., for a hypercube, \\(T_{\\text{ref}}= [0,1]^d\\).</p>","location":"01_framework/localFunctions/#local-functions"},{"title":"Interface","text":"<p>Local functions provide the following interface: <pre><code>LocalFunction(const Dune::CachedLocalBasis&lt;DuneBasis&gt;&amp; p_basis, const CoeffContainer&amp; coeffs_,\n              const std::shared_ptr&lt;const Geometry&gt;&amp; geo,\n              Dune::template index_constant&lt;ID&gt; = Dune::template index_constant&lt;std::size_t(0)&gt;{}); // (1)\n\nFunctionReturnType evaluate(const DomainType&amp; local); \nFunctionReturnType evaluate(const unsigned int&amp; integrationPointIndex); \n\nauto evaluateDerivative(const DomainType&amp; local,...); \nauto evaluateDerivative(const unsigned int&amp; integrationPointIndex,...); \nauto viewOverIntegrationPoints(); // (2) \n\ntemplate&lt;std::size_t ID=0&gt; \nconstexpr int order(Dune::index_constant&lt;ID&gt; ); // (3) \n\ntemplate&lt;std::size_t ID=0&gt; \nauto basis(Dune::index_constant&lt;ID&gt; ); // (4) \n\ntemplate&lt;std::size_t ID=0&gt; \nauto coefficientsRef(Dune::index_constant&lt;ID&gt;); // (5) \n\ntemplate &lt;typename IntegrationRule, typename... Ints&gt; \nvoid bind(IntegrationRule&amp;&amp; p_rule, Derivatives&lt;Ints...&gt;&amp;&amp; ints); // (6) \n\nauto clone (); // (7) \n\ntemplate&lt;typename ScalarType, std::size_t ID=0&gt; \nauto rebindClone (ScalarType, Dune::index_constant&lt;ID&gt;); // (8) \n</code></pre></p> <ol> <li>The constructor takes a <code>Dune::CachedLocalBasis</code>, a vector of coefficients and a shared pointer to the geometry of the grid elements.     Additionally, the local function can be tagged with a compile-time constant, e.g., <code>Dune::template index_constant&lt;0&gt;</code> or <code>Dune::Indices::_0</code>.</li> <li>This returns a vector of structs representing the integration point and its index. Therefore, the syntax is <code>for (const auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()) {...}</code></li> <li>Returns the order of the local function with respect to the coefficients. An id tag can be passed, which returns the order with respect to a tagged function. For details, see Tagging leaf local functions.</li> <li>Returns the basis of the local function. An id tag can be passed, which returns the basis of a specific tagged function. For details see Tagging leaf local functions.</li> <li>Returns a reference to the coefficient of the underlying leaf local finite elements. An id tag can be passed, which returns the basis of a specific tagged function. It can return a const or non-const reference. The non-const version is deactivated, if there is more than one leaf node with the passed id tag.  For details, see Tagging leaf local functions.</li> <li>This function is passed to the given <code>localBasis</code>. See link</li> <li>Clones the local function and stores a copy of all leave nodes.</li> <li>Clones the local function and rebinds the scalar type of the coefficients with id tag <code>ID</code>. This comes in handy if, for example, one wants to replace doubles with an autodiff type.</li> </ol> <p>The \"...\" in the <code>evaluateDerivative</code> function call refers to several possible variadic templates. The implementation looks like the following:</p> Usage with integration point indexusing integration point coordinates   <pre><code>using namespace Dune::DerivativeDirections; \nlocalFunction.bind(rule, bindDerivatives(0,1));     \nfor(auto&amp; [gpIndex, gp] : localFunction.viewOverIntegrationPoints()){ \n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll)); // (1) \n  localFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); // (2) \n} \n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction </li> <li>Compute the spatial Jacobian of localFunction and transform it to the grid element</li> </ol>   <pre><code>using namespace Dune::DerivativeDirections; \nfor(auto&amp; gp : rule){ \n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll)); // (1) \n  localFunction.evaluateDerivative(gp.position(), wrt(spatialAll), on(gridElement)); // (2) \n} \n</code></pre> <ol> <li>Compute the spatial Jacobian of localFunction </li> <li>Compute the spatial Jacobian of localFunction and transform it to the grid element</li> </ol>    <p>where the first call implements</p> \\[ \\operatorname{grad}_\\boldsymbol{\\xi} f : \\boldsymbol{\\xi} \\rightarrow \\mathbb{R}^{m \\times d}. \\] <p>The second one takes into account the fact that the local function is defined in some physical space \\(\\boldsymbol{X}\\) with the coordinate \\(\\boldsymbol{x}\\). Therefore, it transforms the Jacobian from the reference element \\(\\operatorname{grad}_{\\boldsymbol{\\xi}}\\) to the Jacobian on the grid element \\(\\operatorname{grad}_\\boldsymbol{x}\\). This behavior is activated, if <code>on(gridElement)</code> is passed; otherwise, if the derivatives on the reference element is needed, pass <code>on(referenceElement)</code>.  Here, <code>gridElement</code> and <code>referenceElement</code> are global constants in the namespace <code>Dune::DerivativeDirections</code>.</p> <p>Thus, if <code>on(gridElement)</code> is passed, the local function usually implements</p> \\[ \\operatorname{grad}_\\boldsymbol{x} = \\operatorname{grad}_{\\boldsymbol{\\xi}} \\boldsymbol{J}^{-1}   \\] <p>where \\(J\\) is the Jacobian of the mapping from the reference element \\(T_{\\text{ref}}\\) to the element living in physical space \\(T\\). For details, see page 22 of the Dune book1.</p> <p>Instead of passing <code>spatialAll</code> to <code>wrt(..)</code>, there are other helper functions such as:</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(spatial(0))); // (1)  \nlocalFunction.evaluateDerivative(gpIndex, wrt(spatial(1))); // (2) \n</code></pre> <ol> <li>Compute the first column of the spatial Jacobian of <code>localFunction</code></li> <li>Compute the second column of the spatial Jacobian of <code>localFunction</code></li> </ol> <p>which can also be combined with <code>on(...)</code>.</p>","location":"01_framework/localFunctions/#interface"},{"title":"Derivatives w.r.t. coefficients","text":"<p><pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j))); \n</code></pre> which evaluates the first derivative for a vector space valued function,e.g., for \\(f(\\boldsymbol{\\xi}) = \\sum_{I=1}^n N^I(\\boldsymbol{\\xi}) \\boldsymbol{x}_I\\),  we arrive at a matrix \\(\\boldsymbol{A}\\) such that</p> \\[ [\\boldsymbol{A}]_{ij}  = A_{ij} =  \\frac{\\partial f_i(\\boldsymbol{\\xi})}{\\partial \\boldsymbol{x}_j} \\] <p>and the second derivative</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k)), along(q)); \n</code></pre> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = q_i A_{ijk} =  \\frac{\\partial^2 (q_i  f_i(\\boldsymbol{\\xi}))}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k} \\] <p>where \\(\\boldsymbol{q}\\) is an arbitrary vector of the same size as \\(f\\), i.e., it is the direction of the derivative in this case.  \\(\\boldsymbol{A}\\) and \\(\\boldsymbol{B}\\) are simply then the returned matrices and do not have any special meaning.  If a vector is not passed while evaluating the second derivative, the result would be a third-order tensor for a vector-valued function \\(f\\). As a result, a direction derivative in the direction given by <code>along(q)</code> is computed to return a matrix \\(\\boldsymbol{B}\\) in this case.  This helps for both readability and performance. See the example later for more details.</p>","location":"01_framework/localFunctions/#derivatives-wrt-coefficients"},{"title":"Derivatives w.r.t. coefficients and spatial derivatives","text":"<p>Spatial derivatives and derivatives w.r.t. the coefficients can be combined. Therefore, it is legal to call</p> <pre><code>auto B = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q)); \nauto b1 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(0)), along(q)); \nauto b2 = localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatial(1)), along(q)); \n</code></pre>  <p>Warning</p> <p>The order of spatial and coefficient derivatives does not matter. The returned value is always rearranged so that the first derivative is the spatial one.</p>  <p>The first line is then equivalent to</p> \\[ [\\boldsymbol{B}]_{jk} =  B_{jk} = Q_{il} A_{iljk} =  \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{\\xi} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\] <p>For the second and third line, we have</p> \\[\\begin{align} \\boldsymbol{b}_{0,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^0} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}, \\\\ \\boldsymbol{b}_{1,jk} = \\frac{\\partial^2 ([\\operatorname{grad}_{\\xi^1} f(\\xi)]_{i} q_i )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\end{align}\\] <p>These objects are also returned when the second and third lines above are used.</p> <p>All of these function calls, once again, can be combined with <code>on(gridElement)</code> as shown below:</p> <pre><code>localFunction.evaluateDerivative(gpIndex, wrt(coeff(j,k),spatialAll), along(Q), on(gridElement)); \n</code></pre> <p>which computes</p> \\[ \\frac{\\partial^2 ([\\operatorname{grad}_\\boldsymbol{x} f(\\boldsymbol{\\xi})]_{il} Q_{il} )}{\\partial \\boldsymbol{x}_j\\partial \\boldsymbol{x}_k}. \\]  <p>Warning</p> <p>Currently, only first-order spatial derivatives and second-order derivatives w.r.t. the coefficients are supported.</p>","location":"01_framework/localFunctions/#derivatives-wrt-coefficients-and-spatial-derivatives"},{"title":"Example: Dirichlet energy","text":"<p>This example shows how the energy, gradient, and Hessian of a dirichlet energy can be calculated. $$ E(\\boldsymbol{u}) = \\frac{1}{2} \\int_\\Omega ||\\operatorname{grad}_\\boldsymbol{x} \\boldsymbol{u}(\\boldsymbol{x})|| ^2 \\textrm{d} \\boldsymbol{x} $$</p> <p>If the energy is to be minimized w.r.t. the coefficients of the nodes, the energy, gradient, and Hessian w.r.t. the coefficients are to be calculated. Of course, this depends on the optimization algorithms, but for now, the general case where all three are needed is considered.</p> <pre><code>auto dirichletEnergy() { \n  double energy = 0; \n  // bind localBasis to some integration rule \n  // create uNodalCoeffs \n  Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); \n    energy+= 0.5 * (gradu.transpose() * gradu).trace() * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n  } \n} \n</code></pre> <pre><code>auto gradientDirichletEnergy(Eigen::VectorXd&amp; g) { \n  //.bind localBasis to some integration rule \n  // create uNodalCoeffs \n  constexpr int size =  // spatial size of u \n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    const auto gradu = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll), on(gridElement)); \n    for (auto i : fe.size()) { //loop over coeffs, i.e.nodes of the finite element \n      const auto graduDCoeffs \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), on(gridElement)); \n      Eigen::Vector&lt;double, size&gt; tmp; \n      tmp.setZero(); \n      for (int k = 0; k &lt; gridDimension; ++k) \n        tmp += graduDCoeffs[k] * gradu.col(k);  // (1) \n      g.segment&lt;size&gt;(i * size) += tmp * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position());\n    } \n  } \n} \n</code></pre> <ol> <li><code>graduDCoeffs</code> contains in <code>graduDCoeffs[0]</code> the derivatives w.r.t. the coefficient of the first column, and at <code>graduDCoeffs[1]</code> the derivatives w.r.t. the second column of <code>gradu</code>.</li> </ol> <pre><code>auto hessianDirichletEnergy(Matrix&amp; h) { \n  //... bind localBasis to some integration rule \n  // and create uNodalCoeffs \n  constexpr int size =  // spatial size of u \n      Ikarus::StandardLocalFunction uFunction(localBasis, uNodalCoeffs, sharedGeometry); \n  for (const auto&amp; [gpIndex, gp] : uFunction.viewOverIntegrationPoints()) { \n    //.. calculate the inverse Jacobian of the geometry \n    for (auto i : loop over coeffs, i.e.nodes of the finite element) { \n      const auto graduDCoeffsI \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeff(i)), on(gridElement)); \n      for (auto j : fe.size()) { //loop over coeffs, i.e.nodes of the finite element \n        const auto graduDCoeffsJ \n          = uFunction.evaluateDerivative(gpIndex, wrt(spatialAll, coeffs), on(gridElement), coeffIndices(j)); \n        Eigen::Matrix&lt;double, size, size&gt; tmp; \n        tmp.setZero(); \n        for (int k = 0; k &lt; gridDimension; ++k) \n          tmp += graduDCoeffsI[k] * graduDCoeffsJ[k]; \n        h.block&lt;size, size&gt;(i * size, j * size) += tmp * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n      } \n    } \n  } \n} \n</code></pre>","location":"01_framework/localFunctions/#example-dirichlet-energy"},{"title":"Implementations","text":"<p>In the following, the local functions that are currently available are summarized. The ansatz functions are denoted as \\(N^i(\\boldsymbol{\\xi})\\) in the table below.</p>    Name Interpolation formula Note Header     Standard $$ \\boldsymbol{x} = \\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i  $$ - <code>standardLocalFunction.hh</code>   Projection-Based2 $$ \\boldsymbol{x} = P\\left(\\sum_{i=1}^n N^i(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\right) $$ This is one version of geometric finite elements. These are finite elements suited  for interpolation on manifolds. Here \\(P: \\mathbb{R}^m \\rightarrow \\mathcal{M}\\) is an operator that projects  the usual linear interpolation onto a manifold. <code>projectionBasedLocalFunction.hh</code>","location":"01_framework/localFunctions/#implementations"},{"title":"How to implement your own local functions","text":"<p>To implement your own local function, the file <code>ikarus/localFunctions/impl/localFunctionTemplate.hh</code> is made available.</p> <p>The file can be copied, and then you can rename the class to your preferred name and implement the functions mentioned below.  If a particular function is not required, it has to be deleted explicitly. Then, if someone calls that function, it returns a zero matrix or vector of appropriate size.</p> <p>These functions are all templated with <code>DomainTypeOrIntegrationPointIndex</code>, which is an integration point index or position. Additionally, <code>On&lt;TransformArgs&gt;</code> specifies whether the function should be evaluated on the reference element or the grid element (see above). <pre><code>FunctionReturnType evaluateFunctionImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                        const On&lt;TransformArgs&gt;&amp;) const; // (1) \n\nJacobian evaluateDerivativeWRTSpaceAllImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                           const On&lt;TransformArgs&gt;&amp; transArgs) const; // (2) \n\nJacobianColType evaluateDerivativeWRTSpaceSingleImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                     int spaceIndex, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (3) \n\n\nCoeffDerivMatrix evaluateDerivativeWRTCoeffsImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                 int coeffsIndex, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (4) \n\nCoeffDerivMatrix evaluateSecondDerivativeWRTCoeffsImpl(const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition,\n                                                       const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n                                                       const Along&lt;AlongArgs...&gt;&amp; alongArgs,\n                                                       const On&lt;TransformArgs&gt;&amp; transArgs) const; // (5) \n\nstd::array&lt;CoeffDerivEukRieMatrix, gridDim&gt; evaluateDerivativeWRTCoeffsANDSpatialImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, int coeffsIndex,\n    const On&lt;TransformArgs&gt;&amp; transArgs) const; // (6) \n\n\nCoeffDerivEukRieMatrix evaluateDerivativeWRTCoeffsANDSpatialSingleImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, int coeffsIndex, int spatialIndex,\n    const On&lt;TransformArgs&gt;&amp; transArgs) const;  // (7) \n\n\nauto evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n    const Along&lt;AlongArgs...&gt;&amp; alongArgs, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (8) \n\nCoeffDerivMatrix evaluateThirdDerivativeWRTCoeffsTwoTimesAndSpatialSingleImpl(\n    const DomainTypeOrIntegrationPointIndex&amp; ipIndexOrPosition, const std::array&lt;size_t, 2&gt;&amp; coeffsIndex,\n    const int spatialIndex, const Along&lt;AlongArgs...&gt;&amp; alongArgs, const On&lt;TransformArgs&gt;&amp; transArgs) const; // (9) \n</code></pre></p> <ol> <li>This is called by <code>localFunction.evaluate(...)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(coeff(j,k)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j)))</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatialAll,coeff(j,k)), along(A))</code>. <code>A</code> can be accessed via <code>std::get&lt;0&gt;(alongArgs.args)</code>.</li> <li>This is called by <code>localFunction.evaluateDerivative(..., wrt(spatial(i),coeff(j,k)), along(v))</code>. <code>v</code> can be accessed via <code>std::get&lt;0&gt;(alongArgs.args)</code>.</li> </ol>","location":"01_framework/localFunctions/#how-to-implement-your-own-local-functions"},{"title":"Expressions","text":"<p>Expression templates are usually used in linear algebra libraries, e.g., Eigen or Blaze. The syntax is similar to the one provided by UML but only acts on local functions. Expression templates are used here to combine existing local functions in order to obtain new nested ones.</p> <p>For example, consider the following code: <pre><code>... \nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0, sharedGeometry); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1, sharedGeometry); \n</code></pre> Two local functions that satisfy the interface described above are created. Now it is possible to combine these functions and get an object that also satisfies the concept above. Thus, the following is possible: <pre><code>... \nauto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0, sharedGeometry); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1, sharedGeometry); \nauto k = f + g; \nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d))); \n</code></pre></p> <p>Currently, binary and unary expressions are supported. The following expressions are defined:</p>    Name Mathematical formula Code Note     Sum $$ \\boldsymbol{f} + \\boldsymbol{g}  $$ <code>f+g</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) needs to be of the same size.   DotProduct $$ \\boldsymbol{f} \\cdot \\boldsymbol{g} = f_i g_i $$ <code>dot(f,g)</code> \\(\\boldsymbol{f}\\)  and  \\(\\boldsymbol{g}\\) needs to be of the same size.   normSquared $$ \\boldsymbol{f} \\cdot \\boldsymbol{f} = f_i f_i $$ <code>normSquared(f)</code>    Negate $$ -\\boldsymbol{f}  $$ <code>-f</code>    sqrt $$ \\sqrt{f}  $$ <code>sqrt(f)</code> The function \\(f\\) needs a scalar return type.   log $$ \\log{f}  $$ <code>log(f)</code> The function \\(f\\) needs a scalar return type. Here, log is the natural logarithm.   pow $$ f^n  $$ <code>pow&lt;n&gt;(f)</code> The function \\(f\\) needs a scalar return type. \\(n\\) is an integer given during compile-time.   Scale $$  a f , \\quad a \\in  \\mathbf{R}$$ <code>a*f</code> and <code>f/a</code> <code>a</code> has to satisfy <code>std::is_arithmetic&lt;..&gt;</code>   LinearStrains $$ \\frac{1}{2}\\left(\\boldsymbol{H}+\\boldsymbol{H}^T \\right),\\quad \\boldsymbol{H} = \\mathrm{grad}(\\boldsymbol{f})  $$ <code>linearStrains(f)</code> If you call the formula on the left with <code>on(gridElement)</code>, it will assume the transformed derivatives.   GreenLagrangianStrains $$ \\frac{1}{2}\\left(\\boldsymbol{H}+\\boldsymbol{H}^T +\\boldsymbol{H}^T \\boldsymbol{H}\\right),\\quad \\boldsymbol{H} = \\mathrm{grad}(\\boldsymbol{f})  $$ <code>greenLagrangianStrains(f)</code> If you call the formula on the left with <code>on(gridElement)</code>, it will assume the transformed derivatives.    <p>These expressions can also be nested. As a result, it is valid to write <pre><code>auto f = Ikarus::StandardLocalFunction(localBasis, coeffVectors0); \nauto g = Ikarus::StandardLocalFunction(localBasis, coeffVectors1); \nauto k = -sqrt(dot(2*f+f,5*g)); \nk.evaluateDerivative(ipIndex, wrt(coeff(i), spatial(d))); \n</code></pre></p> <p>To use these expressions, there are additional exported static types for all expressions. <pre><code>constexpr bool isLeaf; // (1) \nconstexpr bool children; // (2) \n</code></pre></p> <ol> <li>This is true if the underlying expression is one of the above local functions that really contain the coefficients; see Implementations.</li> <li>Returns the number of children (2 for binary expressions and 1 for unary expressions).</li> </ol>  <p>Note</p> <p>To use these expression, simply include the header <code>#include &lt;dune/localfefunctions/expressions.hh&gt;</code>.</p>","location":"01_framework/localFunctions/#expressions"},{"title":"Tagging leaf local functions","text":"<p>In the context of mixed finite elements, there are usually several local functions that contribute to the energy. These stem from different local bases. For example, consider the Q1P0 element, where displacements are interpolated by using the four bilinear ansatz functions and the element-wise constant pressure field.</p> <p>Then, to obtain gradients and Hessians, we need to differentiate w.r.t. different coefficients.  This can be done by tagging the local function during construction. <pre><code>using namespace Dune::Indices; \nauto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0, sharedGeometry, _0); \nauto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1, sharedGeometry, _1); \nauto k = dot(f,g); \nk.evaluateDerivative(ipIndex, wrt(coeff(_0,i,_1,j))); // Second derivative w.r.t. the nodal coefficients\n</code></pre> To explain the last line above, let us consider that the function f is constructed as \\(f= \\sum_{I=0}^n N^L f_L\\) and similarly  \\(g= \\sum_{I=0}^m M^K g_K\\), where \\(N\\) and \\(M\\) are ansatz functions and \\(f_L\\) and \\(g_K\\) are nodal coefficients.</p> <p>Thus, the above call translates to</p> \\[\\begin{align} \\frac{\\partial^2 (\\boldsymbol{f} \\cdot \\boldsymbol{g} )}{\\partial \\boldsymbol{f}_i\\partial \\boldsymbol{g}_j}, \\end{align}\\] <p>where the correct sizes of the result are derived at compile-time. The complete Hessian of \\(\\boldsymbol{f} \\cdot \\boldsymbol{g}\\) can be calculated by the following: <pre><code>using namespace Dune::Indices; \nauto hessianDirichletEnergy(Matrix&amp; h) { \n  //... bind localBasis to some integration rule \n  using namespace Dune::Indices; \n  auto f = Ikarus::StandardLocalFunction(localBasis0, coeffVectors0, sharedGeometry, _0); \n  auto g = Ikarus::StandardLocalFunction(localBasis1, coeffVectors1, sharedGeometry, _1); \n  auto k = dot(f,g); \n  constexpr int sizef = f.correctionSize; // spatial size of the correction of the coefficients of f \n  constexpr int sizeg = g.correctionSize; // spatial size of the correction of the coefficients of g \n  constexpr int coeffSizef = coeffVectors0.size(); \n  constexpr int coeffSizeg = coeffVectors1.size(); \n\n  Dune::MultiTypeBlockMatrix&lt;Dune::MultiTypeBlockVector&lt;MatrixBlock00,MatrixBlock01&gt;, \n                                       Dune::MultiTypeBlockVector&lt;MatrixBlock10,MatrixBlock11&gt; &gt; KBlocked; // (1) \n\n\n  for (const auto&amp; [gpIndex, gp] : k.viewOverIntegrationPoints()) { \n    for (size_t I = 0; I &lt; coeffSizef; ++I) \n      for (size_t J = 0; J &lt; coeffSizef; ++J)  \n        KBlocked[_0,_0].block&lt;sizef, sizef&gt;(I * sizef, J * sizef)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_0,I,_0,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n\n    for (size_t I = 0; I &lt; coeffSizef; ++I) \n      for (size_t J = 0; J &lt; coeffSizeg; ++J) \n        KBlocked[_0,_1].block&lt;sizef, sizeg&gt;(I * sizef, J * sizeg)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_0,I,_1,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I) \n      for (size_t J = 0; J &lt; coeffSizeg; ++J) \n        KBlocked[_1,_1].block&lt;sizeg, sizeg&gt;(I * sizeg, J * sizeg)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_1,I,_1,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n\n    for (size_t I = 0; I &lt; coeffSizeg; ++I) \n      for (size_t J = 0; J &lt; coeffSizef; ++J) \n        KBlocked[_1,_0].block&lt;sizef, sizeg&gt;(I * sizeg, J * sizef)  \n          += k.evaluateDerivative(gpIndex, wrt(coeff(_1,I,_0,J))) * gp.weight() * sharedGeometry-&gt;integrationElement(gp.position()); \n    } \n} \n</code></pre></p> <ol> <li>This block structure is not necessary. Additionally, in this example, all types (MatrixBlock00, MatrixBlock01, MatrixBlock10, MatrixBlock11) are considered as <code>Eigen::MatrixXd</code>.</li> </ol>","location":"01_framework/localFunctions/#tagging-leaf-local-functions"},{"title":"Writing your own expressions","text":"<p>It is also possible to write your own expressions. To do so, please take a look at the existing expressions.  The <code>sqrt</code> and <code>normSquared</code> expressions are the most general unary and binary expressions implemented.</p>","location":"01_framework/localFunctions/#writing-your-own-expressions"},{"title":"Implementing the return value","text":"<p>Implementing a return value is the first step in implementing an expression.  This is done by using the following function: <pre><code>template &lt;typename LFArgs&gt; \nauto evaluateValueOfExpression(const LFArgs &amp;lfArgs) const; \n</code></pre></p>  <p>Warning</p> <p>The interface dictates that the return value needs to be an <code>Eigen</code> type. Thus, even if a scalar double is to be returned, it is to be wrapped in <code>Eigen::Vector&lt;double, 1&gt;</code></p>  <p>Additionally, the evaluation of the derivative is to be implemented as shown below: <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt; \nauto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const; \n</code></pre></p>","location":"01_framework/localFunctions/#implementing-the-return-value"},{"title":"Evaluate the underlying functions","text":"<p>Expressions always act on existing expressions. Therefore, to have the correct return value for the expression, the underlying quantities are to be evaluated. <code>this-&gt;m()</code> is used to access unary functions, and <code>this-&gt;l()</code> and <code>this-&gt;r()</code> are used to access binary expressions.</p> <p>To evaluate unary functions, the following syntax is used:</p> <p><pre><code>const auto mEvaluated = evaluateFunctionImpl(this-&gt;m(), lfArgs); \n</code></pre> and for binary functions, <pre><code>const auto l_Evaluated = evaluateFunctionImpl(this-&gt;l(), lfArgs); \nconst auto r_Evaluated = evaluateFunctionImpl(this-&gt;r(), lfArgs); \n</code></pre> Because the expression conforms to the syntax of a local function, its derivative can also be evaluated.</p> <p>In the function <code>evaluateDerivativeOfExpression</code>, the template argument <code>DerivativeOrder</code> contains the derivative order. Additionally, the derivative types can also be accessed using the static booleans, as shown below: <pre><code>    static constexpr bool hasTwoCoeff; \n    static constexpr bool hasSingleCoeff; \n    static constexpr bool hasNoCoeff; \n    static constexpr bool hasNoSpatial; \n    static constexpr bool hasOneSpatialAll; \n    static constexpr bool hasOneSpatialSingle; \n    static constexpr bool hasOneSpatial; \n</code></pre></p> <p>Using the dot-product as a binary expression example, we have <pre><code>template &lt;int DerivativeOrder, typename LFArgs&gt; \n    auto evaluateDerivativeOfExpression(const LFArgs &amp;lfArgs) const { \n      const auto u = evaluateFunctionImpl(this-&gt;l(), lfArgs); \n      const auto v = evaluateFunctionImpl(this-&gt;r(), lfArgs); \n      if constexpr (DerivativeOrder == 1)  // (1) \n      { \n        const auto u_x = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (2) \n        const auto v_x = evaluateDerivativeImpl(this-&gt;r(), lfArgs); \n        return Ikarus::eval(v.transpose() * u_x + u.transpose() * v_x); // (3) \n      } else if constexpr (DerivativeOrder == 2) {   // (4) \n        const auto &amp;[u_x, u_y] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (5) \n        const auto &amp;[v_x, v_y] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n        if constexpr (LFArgs::hasNoSpatial and LFArgs::hasTwoCoeff) { // (6) \n          const auto alonguArgs = replaceAlong(lfArgs, along(v)); // (7) \n          const auto alongvArgs = replaceAlong(lfArgs, along(u));  \n\n          const auto u_xyAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (8) \n          const auto v_xyAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs); \n\n          return Ikarus::eval(u_xyAlongv + transpose(u_x) * v_y + transpose(v_x) * u_y + v_xyAlongu); \n        } else if constexpr (LFArgs::hasOneSpatial and LFArgs::hasSingleCoeff) { // (9) \n          const auto u_xy = evaluateDerivativeImpl(this-&gt;l(), lfArgs); // (10) \n          const auto v_xy = evaluateDerivativeImpl(this-&gt;r(), lfArgs); \n          if constexpr (LFArgs::hasOneSpatialSingle and LFArgs::hasSingleCoeff) { // (11) \n            return Ikarus::eval(transpose(v) * u_xy + transpose(u_x) * v_y + transpose(v_x) * u_y \n                                + transpose(u) * v_xy); \n          } else if constexpr (LFArgs::hasOneSpatialAll and LFArgs::hasSingleCoeff) { // (12) \n            std::array&lt;std::remove_cvref_t&lt;decltype(Ikarus::eval(transpose(v) * u_xy[0]))&gt;, gridDim&gt; res; // (13) \n            for (int i = 0; i &lt; gridDim; ++i) \n              res[i] = Ikarus::eval(transpose(v) * u_xy[i] + transpose(u_x.col(i)) * v_y + transpose(v_x.col(i)) * u_y \n                                    + transpose(u) * v_xy[i]); \n            return res; \n          } \n        } \n      } else if constexpr (DerivativeOrder == 3) { // (14)                                      \n        if constexpr (LFArgs::hasOneSpatialSingle) {  // (15) \n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); // (16) \n\n          const auto &amp;[u_x, u_y, u_z] = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (17) \n          const auto &amp;[v_x, v_y, v_z] = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n          const auto &amp;[u_xy, u_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (18) \n          const auto &amp;[v_xy, v_xz]    = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs); \n\n          const auto alonguArgs             = replaceAlong(lfArgs, along(u)); \n          const auto alongvArgs             = replaceAlong(lfArgs, along(v)); \n          const auto argsForDyzalongv_xArgs = replaceAlong(argsForDyz, along(v_x)); // (19) \n          const auto argsForDyzalongu_xArgs = replaceAlong(argsForDyz, along(u_x)); \n\n          const auto u_xyzAlongv = evaluateDerivativeImpl(this-&gt;l(), alongvArgs); // (20) \n          const auto v_xyzAlongu = evaluateDerivativeImpl(this-&gt;r(), alonguArgs); \n          const auto u_yzAlongvx = evaluateDerivativeImpl(this-&gt;l(), argsForDyzalongv_xArgs); // (21) \n          const auto v_yzAlongux = evaluateDerivativeImpl(this-&gt;r(), argsForDyzalongu_xArgs); \n\n          return Ikarus::eval(u_xyzAlongv + transpose(u_xy) * v_z + transpose(u_xz) * v_y + v_yzAlongux + u_yzAlongvx \n                              + transpose(v_xz) * u_y + transpose(v_xy) * u_z + v_xyzAlongu); \n        } else if constexpr (LFArgs::hasOneSpatialAll) { // (22) \n          const auto &amp;alongMatrix = std::get&lt;0&gt;(lfArgs.alongArgs.args); // (23) \n\n          const auto uTimesA = eval(u * alongMatrix); \n          const auto vTimesA = eval(v * alongMatrix); \n\n          const auto &amp;[gradu, u_c0, u_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;l(), lfArgs); // (24) \n          const auto &amp;[gradv, v_c0, v_c1]  = evaluateFirstOrderDerivativesImpl(this-&gt;r(), lfArgs); \n          const auto &amp;[gradu_c0, gradu_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;l(), lfArgs); // (25) \n          const auto &amp;[gradv_c0, gradv_c1] = evaluateSecondOrderDerivativesImpl(this-&gt;r(), lfArgs); \n\n          const auto graduTimesA = (gradu * alongMatrix.transpose()).eval(); \n          const auto gradvTimesA = (gradv * alongMatrix.transpose()).eval(); \n\n          const auto argsForDyz = lfArgs.extractSecondWrtArgOrFirstNonSpatial(); \n\n          const auto alonguAArgs          = replaceAlong(lfArgs, along(uTimesA)); \n          const auto alongvAArgs          = replaceAlong(lfArgs, along(vTimesA)); \n          const auto alonggraduTimesAArgs = replaceAlong(argsForDyz, along(graduTimesA)); \n          const auto alonggradvTimesAArgs = replaceAlong(argsForDyz, along(gradvTimesA)); \n\n          const auto u_xyzAlongv            = evaluateDerivativeImpl(this-&gt;l(), alongvAArgs); \n          const auto v_xyzAlongu            = evaluateDerivativeImpl(this-&gt;r(), alonguAArgs); \n          const auto v_c0c1AlongGraduTimesA = evaluateDerivativeImpl(this-&gt;r(), alonggraduTimesAArgs); \n          const auto u_c0c1AlongGradvTimesA = evaluateDerivativeImpl(this-&gt;l(), alonggradvTimesAArgs); \n          decltype(eval(u_xyzAlongv)) res; \n\n          res = u_xyzAlongv + v_xyzAlongu + v_c0c1AlongGraduTimesA + u_c0c1AlongGradvTimesA; \n          for (int i = 0; i &lt; gridDim; ++i) \n            res += (transpose(u_c1) * gradv_c0[i] + transpose(v_c1) * gradu_c0[i] + transpose(v_c0) * gradu_c1[i] \n                    + transpose(u_c0) * gradv_c1[i]) \n                   * alongMatrix(0, i); \n\n          return res; \n\n        } \n      }  \n    } \n</code></pre></p> <ol> <li>Compile-time branch for first-order derivatives</li> <li>Evaluates the derivative of <code>this-&gt;l()</code> in relation to the only derivative contained within the local function arguments <code>lfArgs</code>.</li> <li>Evaluates the return value; derivatives and function values are combined as dictated by the product rule.</li> <li>Compile-time branch for second-order derivatives</li> <li>We have four cases for evaluating functions because we are in the second-order derivatives branch: the function value, the function derivative w.r.t. the first argument or the second argument, and the function's derivative w.r.t. both arguments.    Here, the function <code>evaluateFirstOrderDerivativesImpl</code> returns the derivatives w.r.t. the first argument and the second argument.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\), this calls returns    \\begin{flalign*}    \\verb+u_x+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{\\xi}} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\xi_0} \\quad \\text{or} \\quad \\verb+u_x+ = \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_I}\\\\    \\verb+u_y+ &amp;= \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{u}_J}    \\end{flalign*}    The first one would be returned if it is called as    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \n</code></pre>    and the second one if it is called as    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \n</code></pre>    and the third without any spatial derivative is returned using    <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j))); \n</code></pre>    Therefore, this function separates the two <code>wrt</code> arguments and returns the corresponding first order derivatives.</li> <li>Compile-time branch for the case where no spatial derivatives are requested but only the derivatives w.r.t. coefficients are needed.</li> <li>Creates a new argument variable where the <code>along</code> argument is replaced by <code>v</code>.</li> <li>This function evaluates the derivatives of <code>l</code> w.r.t. to both <code>wrt</code> arguments. Furthermore, it takes the <code>along</code> argument since otherwise the returned object would be a 3-dimensional array.    If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  and \\(\\boldsymbol{v}\\) of the same size as \\(\\boldsymbol{u}\\) this calls returns    \\begin{flalign*}    \\verb+u_xyAlongv + &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i    \\end{flalign*}    This is the same if the following is called:    <pre><code>    u.evaluateDerivative(gpIndex, wrt(coeff(i,j)),along(v)); \n</code></pre></li> <li>Compile-time branch for the case where one spatial derivative and one derivative w.r.t. the coefficients is needed.</li> <li>This function evaluates the derivatives of <code>l</code> w.r.t. to both <code>wrt</code> arguments.     If we consider the left function as \\(\\boldsymbol{u}(\\boldsymbol{\\xi},\\boldsymbol{u}_I)\\)  this calls returns     \\begin{flalign*}     \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\quad \\text{or} \\quad \\verb+u_xy+ = \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\xi_0\\partial\\boldsymbol{u}_I}     \\end{flalign*}     The first one would be returned if it is called as    <pre><code>    u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \n</code></pre> and the second one if it is called as    <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \n</code></pre> In the first case the result is stored in an array. Thus, in the first index, the derivative w.r.t. to the first spatial coordinate is stored. Therefore, we have    <pre><code>spatialAllCoeffDeriv = u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i))); \nspatialAllCoeffDeriv[0] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i))); \nspatialAllCoeffDeriv[1] // derivative as in u.evaluateDerivative(gpIndex, wrt(spatial(1),coeff(i))); \n</code></pre></li> <li>Compile-time branch for the case where one single spatial derivatives and one derivative w.r.t. coefficients is needed.</li> <li>Compile-time branch for the case where all spatial derivatives and one derivative w.r.t. coefficients is needed.</li> <li>The return type here is an array of single spatial derivatives and each derived w.r.t. the coefficient. Thus the type inside the array must be deduced here.</li> <li>Compile-time branch for third order derivatives</li> <li>Compile-time branch for single spatial derivatives</li> <li>To obtain derivatives w.r.t. to the second and third <code>wrt</code> argument, we extract the arguments here. E.g., for the following request:    <pre><code> u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre> This call would extract the arguments as    <pre><code> newArgs =  \"wrt(coeff(i,j)),along(matrix))\" //THIS IS NO VALID SYNTAX \n</code></pre> This can then be used as    <pre><code>u.evaluateDerivative(gpIndex, newArgs); \n</code></pre></li> <li>As in the second order derivative case, it returns all the three first order derivatives. E.g., for the case,     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre>     the returned values would be     \\begin{flalign*}     \\verb+u_x+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}} \\\\     \\verb+u_y+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_I} \\\\     \\verb+u_z+ &amp;= \\frac{\\partial \\boldsymbol{u} }{\\partial\\boldsymbol{u}_J}     \\end{flalign*}</li> <li>This returns the derivatives w.r.t. the given spatial direction and w.r.t. the first and second coefficient.  E.g., for the case,     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j)),along(matrix)); \n</code></pre>     the returned values would be     \\begin{flalign*}     \\verb+u_xy+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_I} \\\\     \\verb+u_xz+ &amp;= \\frac{\\partial^2 \\boldsymbol{u} }{\\partial\\boldsymbol{\\xi}\\partial\\boldsymbol{u}_J} \\\\     \\end{flalign*}</li> <li>Creates a new argument variable where the <code>along</code> argument is replaced by <code>v_x</code>.</li> <li>This return call would be     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatial(0),coeff(i,j),along(v)); \n</code></pre>     In mathematical notation, it returns     \\begin{flalign*}     \\verb+u_xyzAlongv  + &amp;= \\frac{\\partial^3 u_i }{\\partial \\xi_0\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} v_i     \\end{flalign*}</li> <li>This return would be     <pre><code>v_x = v.evaluateDerivative(gpIndex, wrt(spatial(0)); \nu_yzAlongvx = u.evaluateDerivative(gpIndex, wrt(coeff(i,j),along(v_x)); \n</code></pre>     In mathematical notation, it returns     \\begin{flalign*}     \\verb+u_yzAlongvx+ &amp;= \\frac{\\partial^2 u_i }{\\partial\\boldsymbol{u}_I\\partial\\boldsymbol{u}_J} \\left[\\frac{\\partial \\boldsymbol{v}}{\\xi_0}\\right]_i     \\end{flalign*}</li> <li>Compile-time branch for all spatial derivatives</li> <li>Obtain the <code>along</code> argument defined, for example, in     <pre><code>u.evaluateDerivative(gpIndex, wrt(spatialAll,coeff(i,j),along(matrix)); \n</code></pre></li> <li>Similar to the single spatial case</li> <li>Similar to the single spatial case</li> </ol> <p>If your expression is working, it can be added to <code>dune/localfefunctions/expressions.hh</code> by submitting a PR  to dune-localfefunctions.</p>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/localFunctions/#evaluate-the-underlying-functions"},{"title":"Manifolds","text":"","location":"01_framework/manifolds/"},{"title":"Manifold elements","text":"<p>Usually optimization problems are defined in terms of a cost function, such as:</p> <p>$$  \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) $$ where \\( f: \\mathcal{M} \\rightarrow \\mathbb{R} \\).</p> <p>Usually \\( \\mathcal{M} \\) is an Euclidean vector space \\( \\mathbb{R}^n \\).</p> <p>In a finite element context, for example, in 2D elasticity problems, we have a  two-dimensional displacement for each node. As a result, if there are \\(n \\) nodes, we optimize in \\( {\\mathbb{R}^{2n}} \\).</p> <p>The nodal degrees of freedom should be wrapped in <code>Ikarus::RealTuple&lt;double,2&gt;</code> in this case.</p> <p>Another case of optimization is on non-linear manifolds. These arise typically for Cosserat materials \\( \\mathcal{S}\\mathcal{O}(3) \\)1,  Reissner-Mindlin shells \\( \\mathcal{S}^2 \\)2 and micro-magnetics \\( \\mathcal{S}^{2} \\) or incompressible materials.</p>","location":"01_framework/manifolds/#manifold-elements"},{"title":"Interface","text":"<p>The general interface of the manifold elements is represented by the following concept. <pre><code>namespace Ikarus::Concepts {\n  template &lt;typename ManifoldType&gt;\n  concept Manifold = requires(ManifoldType var, typename ManifoldType::CorrectionType correction, std::ostream&amp; s,\n                              typename ManifoldType::CoordinateType value) {\n    typename ManifoldType::ctype; // (1)\n    ManifoldType::valueSize; // (2)\n    ManifoldType::correctionSize; // (3)\n    typename ManifoldType::CoordinateType; // (4)\n    typename ManifoldType::CorrectionType; // (5)\n    { var.getValue() } -&gt; std::convertible_to&lt;typename ManifoldType::CoordinateType&gt;; // (6)\n    { var.setValue(value) } -&gt; std::same_as&lt;void&gt;; // (7)\n    { var+=correction };  // (8)\n    //...\n  };\n}  \n</code></pre></p> <ol> <li>The type for the coordinate values, usually <code>double</code>.</li> <li>The number of values to store for the state of the element. E.g., the three-dimensional unit vector needs three entries to store its state.</li> <li>The size of the correction for an element. <code>valueSize</code> and <code>correctionSize</code> are the same in Euclidean space. But, for example, the three-dimensional unit vector needs a two-dimensional correction (which lives in the tangent space).</li> <li>The type to store the element coordinates is usually <code>Eigen::Vector&lt;double,ManifoldType::valueSize&gt;</code></li> <li>The type to store the element correction type is usually <code>Eigen::Vector&lt;double,ManifoldType::correctionSize&gt;</code></li> <li>Access the underlying coordinate vector of the manifold element.</li> <li>Directly set the value. E.g., set <code>Ikarus::UnitVector&lt;double,3&gt; a; a.setValue(Eigen::Vector3d::UnitZ());</code></li> <li>Update the element with a correction vector. E.g.,      <pre><code>   Ikarus::RealTuple&lt;double,3&gt; a; \n   a+= Eigen::Vector3d::UnitX();\n\n   Ikarus::UnitVector&lt;double,3&gt; b; \n   b+= Eigen::Vector2d::UnitX();\n</code></pre></li> </ol>","location":"01_framework/manifolds/#interface"},{"title":"Implementations","text":"Name Formal definition Notes Header     \\(n\\)-th dimensional Euclidean space $$ \\boldsymbol{x} \\in \\mathbb{R}^n  $$  <code>realTuple.hh</code>   Unit sphere $$ \\boldsymbol{x} \\in \\mathcal{S}^{n-1}, \\quad \\mathcal{S}^{n-1} = \\left\\{ \\boldsymbol{x} \\in \\mathbb{R}^n :  \\boldsymbol{x}\\cdot  \\boldsymbol{x}  = 1 \\right\\}  $$  <code>unitVector.hh</code>      <ol> <li> <p>Oliver Sander. Geodesic finite elements for cosserat rods. International Journal for Numerical Methods in Engineering, 82(13):1645\u20131670, 2010. doi:10.1002/nme.2814.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> </ol>","location":"01_framework/manifolds/#implementations"},{"title":"Nonlinear operator","text":"","location":"01_framework/nonlinearOperator/"},{"title":"Nonlinear operator","text":"<p>The class <code>NonLinearOperator</code> consists of a collection of a function and its derivatives, including their dependence  on parameters. </p> <p>Let us assume a function <code>f(x)</code> and its derivative <code>df(x)</code>. Then, a <code>NonLinearOperator</code> can be constructed as follows:</p> <pre><code>double x               = 13;\nauto fvLambda  = [&amp;](auto&amp;&amp; x) { return f(x); };\nauto dfvLambda = [&amp;](auto&amp;&amp; x) { return df(x); };\n\nauto nonLinOp = Ikarus::NonLinearOperator(linearAlgebraFunctions(fvLambda, dfvLambda), parameter(x));\n</code></pre>  <p>Note</p> <p>It is assumed that the second function is the derivative of the first function, the third function is the derivative of the second function (2nd derivative of the first function), and so on.</p>  <p><code>linearAlgebraFunctions(...)</code> and <code>parameter(...)</code> are helper functions. They are necessary to distinguish which argument is a function and which argument is a parameter.</p> <p><code>nonLinOp</code> provides the following features: <pre><code>void updateAll() // (1)\nvoid update&lt;n&gt;() // (2)\nauto&amp; value() // (3)\nauto&amp; derivative() // (4)\nauto&amp; secondDerivative() // (5)\nauto&amp; nthDerivative&lt;n&gt;() // (6)\nauto&amp; firstParameter() // (7)\nauto&amp; secondParameter() // (8)\nauto&amp; nthParameter&lt;n&gt;() // (9)\nauto&amp; lastParameter() // (10)\nauto subOperator&lt;n,m,...&gt;() // (11)\n</code></pre></p> <ol> <li>Evaluates all functions.</li> <li>Evaluates the n-th function in <code>linearAlgebraFunctions(...)</code> . Counting starts from 0, as always in C++.</li> <li>Returns the result of the function evaluation.</li> <li>Returns the result of the evaluation of the first derivative (if the function for the first derivative is passed to the nonlinear operator during construction).</li> <li>Returns the result of the evaluation of the second derivative (if the function for the second derivative is passed to the nonlinear operator during construction).</li> <li>Returns the result of the evaluation of the n-th derivative (if the function for the n-th derivative is passed to the nonlinear operator during construction).</li> <li>Returns the value of the first parameter.</li> <li>Returns the value of the second parameter (if available).</li> <li>Returns the value of the n-th parameter (if available).</li> <li>Returns the value of the last parameter.</li> <li>Creates an <code>Ikarus::NonLinearOperator</code> with a subset of the derivatives. For example, let us consider a nonlinear operator with     (function, first derivative, second derivative). <code>subOperator&lt;0,1&gt;()</code> then returns a nonlinear operator with     (function, first derivative).</li> </ol>","location":"01_framework/nonlinearOperator/#nonlinear-operator"},{"title":"Observer and observables","text":"","location":"01_framework/observer/"},{"title":"Oberserver and Observable","text":"<p>To write output messages when desired by the user, the observer pattern is implemented in Ikarus. Four things are necessary to understand the implementation of observer patterns: <code>Messages</code>, <code>IObservable</code>,  <code>IObserver</code> and <code>Subscriptions</code>.</p>","location":"01_framework/observer/#oberserver-and-observable"},{"title":"Messages","text":"<p>A message class is a list of possible events that can happen and might be of interest. The messages that are used for  nonlinear solvers are listed below as an example. <pre><code>enum class NonLinearSolverMessages {\n  BEGIN,\n  INIT,\n  ITERATION_STARTED,\n  ITERATION_ENDED,\n  RESIDUALNORM_UPDATED,\n  CORRECTIONNORM_UPDATED,\n  SOLUTION_CHANGED,\n  FINISHED_SUCESSFULLY,\n  END\n};\n</code></pre></p>","location":"01_framework/observer/#messages"},{"title":"IObservable","text":"<p>A class can be observable. The class then sends notifications when events are happening. To become observable, a class  must inherit from <code>IObservable&lt;MessageType&gt;</code>, for example, <pre><code>class NewtonRaphson : public IObservable&lt;NonLinearSolverMessages&gt; {...};\n</code></pre> The function <code>this-&gt;notify(MessageType::Message)</code> is called at the appropriate position in the code to send a  notification. This could be, for example, <pre><code>this-&gt;notify(NonLinearSolverMessages::SOLUTION_CHANGED);\n</code></pre></p>","location":"01_framework/observer/#iobservable"},{"title":"IObserver","text":"<p>A class can be an observer. The class is then notified when events are happening and can perform actions. A very simple example is shown below. To become an observer, the class must inherit from <code>IObserver&lt;MessageType&gt;</code>, where <code>MessageType</code> is the <code>enum</code> of messages to use (see above).  <pre><code>class OurFirstObserver : public IObserver&lt;NonLinearSolverMessages&gt; {\npublic:\n  void updateImpl(NonLinearSolverMessages message) override {\n    if (message == NonLinearSolverMessages::ITERATION_STARTED) std::cout &lt;&lt; \"Iteration started.\\n\";\n  }\n};\n</code></pre> The observer has to implement the function <code>void updateImpl(MessageType message)</code>. In this function, all actions can be implemented that should be performed when the corresponding message is received.</p> <p>To connect observer and observable, one has to call <code>observalbe.subscribe(MessageType::Message,observer)</code>. Example: <pre><code>Ikarus::NewtonRaphson nr(...);\nauto ourSimpleObserver = std::make_shared&lt;OurFirstObserver&gt;();\nnr.subscribe(NonLinearSolverMessages::ITERATION_STARTED, ourSimpleObserver);\n};\n</code></pre></p>","location":"01_framework/observer/#iobserver"},{"title":"Subscriptions","text":"<p>There are a couple of options for the subscription: <pre><code>subscribe(MessageType::Message,observer) // (1)\nsubscribeAll(observer) // (2)\nsubscribeAll({observer1,observer2}) // (3)\nunSubscribe(...) // (4)\n</code></pre></p> <ol> <li>Subscribes to one specific message.</li> <li>Subscribes to all the messages in <code>enum</code>.</li> <li>Multiple observers can subscribe at once.</li> <li>Unsubscribe from specific messages or all messages.</li> </ol> <p>To send a message together with data, the sender (observable) calls <pre><code>this-&gt;notify(MessageType::Message,data);\n</code></pre> and the receiver (observer) has to implement <pre><code>void updateImpl(MessageType message, data) override {...}\n</code></pre> To see all available options for <code>data</code>, we refer to the file <code>observer.hh</code>.</p>","location":"01_framework/observer/#subscriptions"},{"title":"Solvers","text":"","location":"01_framework/solvers/"},{"title":"Solvers","text":"<p>In Ikarus, there are essentially two types of solvers: linear and non-linear.</p>","location":"01_framework/solvers/#solvers"},{"title":"Linear solver","text":"<p>It solves for the vector \\( \\boldsymbol{x} \\) in</p> <p>$$ \\boldsymbol{A}  \\boldsymbol{x} =  \\boldsymbol{b} $$ where \\(\\boldsymbol{A} \\) and \\(\\boldsymbol{b}\\) are any matrix or vector, respectively. These solvers can be direct or iterative. Furthermore, they depend on the underlying structure of the  matrix \\(\\boldsymbol{A} \\), i.e., whether it is stored in a <code>dense</code> or <code>sparse</code> format.</p> <p>Currently, only the linear solvers provided by the Eigen  library are supported.</p> <p>Linear solvers can be constructed by calling the constructor:</p> <pre><code>ILinearSolver(const SolverTypeTag&amp; solverTypeTag)\n</code></pre> <p>There exists an enum type <code>SolverTypeTag</code> with the following values:</p> <pre><code>  enum class SolverTypeTag {\n    si_ConjugateGradient,\n    si_LeastSquaresConjugateGradient,\n    si_BiCGSTAB,\n    sd_SimplicialLLT,\n    sd_SimplicialLDLT,\n    sd_SparseLU,\n    sd_SparseQR,\n    sd_CholmodSupernodalLLT,\n    sd_UmfPackLU,\n    sd_SuperLU,\n    d_PartialPivLU,\n    d_FullPivLU,\n    d_HouseholderQR,\n    d_ColPivHouseholderQR,\n    d_FullPivHouseholderQR,\n    d_CompleteOrthogonalDecomposition,\n    d_LLT,\n    d_LDLT,\n  };\n</code></pre> <p>The prefixes <code>s_</code> and  <code>d_</code> indicate whether the linear solver can be used for <code>sparse</code> or <code>dense</code> matrices, respectively. Furthermore, there is also a second prefix for sparse solvers: <code>d</code> and <code>i</code> for direct solvers and for iterative solvers, respectively. Thus, using <code>si_ConjugateGradient</code> means that this solver is for sparse matrices and is an iterative solver.</p>  <p>Note</p> <p>All dense solvers are currently direct solvers. Therefore, we do not distinguish them.</p>  <p>The naming of the solvers is the same as in the Eigen library.  For more details on the solvers, we refer to Eigen's documentation for dense decompositions and to Eigen's documentation for sparse decompositions.</p>","location":"01_framework/solvers/#linear-solver"},{"title":"Interface","text":"<p>Similar to Eigen's interface, the following functions are provided: <pre><code>void analyzePattern(const MatrixType&amp; A);  // (1)\nvoid factorize(const MatrixType&amp; A); // (2)\nILinearSolver&amp; compute(const MatrixType&amp; A); // (3)\nvoid solve(Eigen::VectorX&lt;ScalarType&gt;&amp;x, const Eigen::VectorX&lt;ScalarType&gt;&amp; b); // (4)\n</code></pre></p> <ol> <li>If the matrix is sparse, Eigen can collect information on the sparsity pattern of the matrix for a faster <code>solve</code> step. This pattern does not change if the non-zero entries are modified.</li> <li>This method applies a decomposition technique for direct solvers, e.g., LU decomposition. For iterative solvers, the method is a non-linear operator.</li> <li>It calls both the functions <code>analyzePattern</code> and <code>factorize</code>.</li> <li>Solves the problem and stores the result in <code>x</code>.</li> </ol>  <p>Tip</p> <p>If your algorithm relies on special features or attributes of a linear solver, then the solver is to be directly used. For example, if the <code>.determinant()</code> method of <code>Eigen::SimplicialLDLT</code> is required, it must be called directly because <code>ILinearSolver</code>does not support it.</p>","location":"01_framework/solvers/#interface"},{"title":"Nonlinear solver","text":"<p>Non-linear solvers are usually used to solve a kind of optimization problem, e.g., root-finding or minimization problems like: \\begin{align}   \\boldsymbol{R}(\\boldsymbol{x}) \\stackrel{!}{=} \\boldsymbol{0} \\quad \\text{or} \\quad   \\min_{\\boldsymbol{x} \\in \\mathcal{M}} f(\\boldsymbol{x} ) \\end{align}</p> <p>It has the following interface: <pre><code>void setup(const NewtonRaphsonSettings&amp; p_settings); // (1)\nSolverInformation solve(const SolutionType&amp; dx_predictor = NoPredictor{}); // (2)\nauto&amp; nonLinearOperator(); // (3)\n</code></pre></p> <ol> <li>With this function, several properties of the nonlinear solver can be set. E.g., residual tolerance or maximum number of iterations</li> <li>Solves the non-linear problem. An initial guess to the function can be passed, otherwise, a zero vector is assumed.    It returns the <code>SolverInformation</code> which contains information like the success of the solution step and more. </li> <li>Just returns the underlying <code>nonLinearOperator</code>, see link.</li> </ol>  <p>Note</p> <p>To ease the construction process, the non-linear solver can provide a method <code>make[...]</code> that allows shorter syntax since no <code>std::shared_ptr</code> has to be constructed specifying the template arguments.  The construction of the nonlinear solvers can be very different. Therefore, we do not impose an interface for the constructors.</p>","location":"01_framework/solvers/#nonlinear-solver"},{"title":"Implementations","text":"Name Purpose Constraints on nonlinear operator Header Properties     Newton-Raphson Root finding Value and gradient <code>newtonRaphson.hh</code> Locally quadratic convergence   Newton-Raphson with scalar subsidiary function Root finding with a scalar function as additional constraint Value, gradient and a scalar function <code>newtonRaphsonWithScalarSubsidiaryFunction.hh</code> Locally quadratic convergence   Trust-Region Minimization Value, gradient and Hessian <code>trustRegion.hh</code> Globally convergent and locally quadratic convergence    <p>To see the Newton-Raphson implementation, we refer to the tests inside <code>nonLinearOperatorTest.cpp</code>, and for the  trust-region method, <code>trustRegionTest.cpp</code>.</p>","location":"01_framework/solvers/#implementations"},{"title":"Index","text":"","location":"02_examples/"},{"title":"Examples","text":"<p>In order to understand several features of Ikarus, a set of examples is provided within the finite element framework. These can be found at IkarusExamples. The installation and execution  methodologies are briefly discussed in the README file  of the repository. Each example is given a unique identification in the beginning of the file name of the form <code>iksXXX</code>. This unique identification is also used in the following instead of the complete <code>*.cpp</code> file name. Auxiliary files  for the examples, such as <code>*.msh</code>, <code>*.geo</code> or <code>*.parset</code> can be found in <code>../../src/testFiles/</code>.  In order to add a new example, create a pull request with your executable file in the repository IkarusExamples and, in  parallel, update the documentation here. See How to Contribute and  How to Edit for more information.  </p> <p>The available examples are :</p>    Identification Name of the example     iks001 Compute the value of \\(\\pi\\)   iks002 Cantilever beam with point load   iks003 Deformation of an incompressible rubber block   iks004 Plate subjected to a surface load   iks005 Newton-Raphson method   iks006 Non-linear Elasticity for 2D solids   iks007 Von-Mises truss   iks008 Cook's membrane","location":"02_examples/#examples"},{"title":"Cantilever beam with point load","text":"","location":"02_examples/cantileverBeam/"},{"title":"Cantilever beam with point load","text":"<p>The example <code>iks002_cantileverBeamOneDGrid.cpp</code> shows a simple implementation of a one dimensional Timoshenko beam which is clamped on the left  hand side. A point load is applied on the right hand side of the beam. It uses <code>Dune::OneDGrid</code> to generate the required  grid. A simple implementation is shown here where the stiffness matrices are assembled explicitly. Advanced  implementations of matrix assembly and other features of Ikarus is showcased in the other examples.</p>","location":"02_examples/cantileverBeam/#cantilever-beam-with-point-load"},{"title":"Compute the value of pi","text":"","location":"02_examples/computePi/"},{"title":"Compute the value of \\(\\pi\\)","text":"<p>The examples <code>iks001_computePi.cpp</code> shows the calculation of \\(\\pi\\) by computing the area and circumference of a unit circle. This example helps to understand the <code>Grid</code> module from Dune and the refinement techniques it brings. The example shows that a global refinement doesn't refine the number of grid entities on the boundary of the circle, which leads to a poor approximation of \\(\\pi\\) while it comparing with the area and circumference of the circle. On the other hand, it also shows how elements on the boundaries can be marked and refined, thereby resulting in an accurate approximation of \\(\\pi\\).</p>","location":"02_examples/computePi/#compute-the-value-of-pi"},{"title":"Cook's membrane","text":"","location":"02_examples/cooksMembrane/"},{"title":"Cook's membrane","text":"<p>The Cook's membrane problem adapted from the paper1 is implemented in the example <code>iks008_cooksMembrane.cpp</code>. This problem can be solved not only with structured meshes provided, but also with unstructured and triangular meshes. The input parameters like material and grid parameters are read from the file <code>iks008_cooksMembrane.parset</code>. The problem can be solved also with the standard planar solid element, or with enhanced assumed strain elements. For more details on the element technologies, refer the documentation. <code>iks008</code> solves the problem with a set of existing finite elements and compares the convergence rates. </p>   <ol> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> </ol>","location":"02_examples/cooksMembrane/#cooks-membrane"},{"title":"Compression of an incompressible rubber block","text":"","location":"02_examples/incompressibleRubberBlock/"},{"title":"Deformation of an incompressible rubber block","text":"","location":"02_examples/incompressibleRubberBlock/#deformation-of-an-incompressible-rubber-block"},{"title":"Description","text":"<p><code>iks003_incompressible_LinearElasticity.cpp</code> uses a finite element technology with displacement and pressure as independent degrees of freedom to simulate the deformation of an incompressible rubber block. The potential energy  for such a system is defined in the <code>Solid struct</code> by the function <code>calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code>.  This function uses the principles of automatic differentiation to provide the stiffness matrix and other necessary quantities to perform a static structural analysis.</p>","location":"02_examples/incompressibleRubberBlock/#description"},{"title":"Code highlights","text":"<p>The <code>struct</code> named <code>Solid</code> is created as an object of <code>AutoDiffFE</code>. It is constructed as shown below: <pre><code>Solid(const Basis &amp;basis, const typename LocalView::Element &amp;element, double emod, double nu)\n    : BaseAD(basis, element), localView_{basis.localView()}, emod_{emod}, nu_{nu} {\n  localView_.bind(element);\n  mu_       = emod_ / (2 * (1 + nu_));\n  lambdaMat = convertLameConstants({.emodul = emod_, .nu = nu_}).toLamesFirstParameter();\n}\n</code></pre> It takes a reference to the basis function (<code>&amp;basis</code>), the element (<code>&amp;element</code>), and the material parameters, namely Young's modulus  (<code>emod</code>) and Poisson's ratio (<code>nu</code>), as arguments during construction. The function <code>convertLameConstants()</code> is a helper function to switch between the Lame parameters.</p> <p><code>ScalarType calculateScalarImpl(const FERequirementType &amp;par, const Eigen::VectorX&lt;ScalarType&gt; &amp;dx)</code> is  then defined, returning a scalar value, in this case the energy. The energy is then calculated as follows: <pre><code>energy += (0.5 * (2 * mu_ * symgradu.squaredNorm() - 1 / lambdaMat * Dune::power(pressure, 2)) + pressure * divU\n           - x.dot(fext))\n          * geo.integrationElement(gp.position()) * gp.weight();  // plane strain for 2D\n</code></pre> Here:  - <code>symgradu</code> is the symmetric part of the gradient of displacements  - <code>lambdaMat</code> is the first Lame parameter - <code>pressure</code> and <code>x</code> is the nodal pressure and current position, respectively - <code>divU</code> is the divergence of the displacement vector - <code>fext</code> is the external force vector - <code>gp.position()</code> and <code>gp.weight()</code> are the positions and weights from the quadrature rule - <code>geo.integrationElement()</code> returns the determinant of Jacobian required from the iso-parametric concept</p> <p>A Yasp 2D grid1 is created of the size \\(L\\) x \\(h\\) with 20 elements in both directions as shown below:  <pre><code>using Grid        = Dune::YaspGrid&lt;gridDim&gt;;\nconst double L    = 1;\nconst double h    = 1;\nconst size_t elex = 20;\nconst size_t eley = 20;\n\nDune::FieldVector&lt;double, 2&gt; bbox       = {L, h};\nstd::array&lt;int, 2&gt; elementsPerDirection = {elex, eley};\nauto grid                               = std::make_shared&lt;Grid&gt;(bbox, elementsPerDirection);\nauto gridView                           = grid-&gt;leafGridView();\n</code></pre> A linear Lagrangian basis is opted for the displacements and a constant basis for the pressure degrees of freedom using the <code>composite</code> basis feature from Dune as shown below: <pre><code>auto basis = Ikarus::makeConstSharedBasis(\ngridView, composite(power&lt;2&gt;(lagrange&lt;1&gt;(), FlatInterleaved()), lagrange&lt;0&gt;(), FlatLexicographic()));\n</code></pre> The displacement degrees of freedom at position \\(y=0\\) are fixed using the following snippet: <pre><code>Ikarus::DirichletValues dirichletValues(basis);\ndirichletValues.fixDOFs([](auto &amp;basis_, auto &amp;dirichletFlags) {\n  Dune::Functions::forEachBoundaryDOF(subspaceBasis(basis_, _0),\n                   [&amp;](auto &amp;&amp;localIndex, auto &amp;&amp;localView, auto &amp;&amp;intersection) {\n                       if (std::abs(intersection.geometry().center()[1]) &lt; 1e-8)\n                         dirichletFlags[localView.index(localIndex)] = true;\n  });\n}); \n</code></pre> Here, all the element edges lying on the boundary of the physical domain are looped over and checked to see if the first index  of the center of the edge (<code>intersection.geometry().center()[1]</code>) is closer to zero. If this is the case, the corresponding displacement  degrees of freedom (obtained via <code>subspaceBasis(basis_, _0)</code>) are set to <code>true</code> and used by the assembler later.</p> <p>A <code>sparse</code> and a <code>dense</code> assembler are used to arrive at the stiffness matrix and the external load vector using the  finite element requirements as described here. <pre><code>auto sparseFlatAssembler = SparseFlatAssembler(fes, dirichletValues);\nauto denseFlatAssembler  = DenseFlatAssembler(fes, dirichletValues);\n  auto req = FErequirements().addAffordance(Ikarus::AffordanceCollections::elastoStatics);\n\nauto fextFunction = [&amp;](auto &amp;&amp;lambdaLocal, auto &amp;&amp;dLocal) -&gt; auto &amp; {\n  req.insertGlobalSolution(Ikarus::FESolutions::displacement, dLocal)\n      .insertParameter(Ikarus::FEParameter::loadfactor, lambdaLocal);\n  return denseFlatAssembler.getReducedVector(req);\n};\nauto KFunction = [&amp;](auto &amp;&amp;lambdaLocal, auto &amp;&amp;dLocal) -&gt; auto &amp; {\n  req.insertGlobalSolution(Ikarus::FESolutions::displacement, dLocal)\n      .insertParameter(Ikarus::FEParameter::loadfactor, lambdaLocal);\n  return sparseFlatAssembler.getReducedMatrix(req);\n};\n</code></pre> The <code>SparseLU</code> package from the Eigen library is used to solve the linear system of equations. </p> <p>For post-processing, the function <code>Dune::Functions::makeDiscreteGlobalBasisFunction()</code> is used to create a function for  the displacements and pressure using the basis functions and the nodal values. <code>Dune::VTKWriter</code> is used to write  the <code>*.vtu</code> files. The results can then be plotted, for example, using Paraview. <pre><code>auto disp\n    = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;Dune::FieldVector&lt;double, 2&gt;&gt;(subspaceBasis(*basis, _0), d);\nauto pressure = Dune::Functions::makeDiscreteGlobalBasisFunction&lt;double&gt;(subspaceBasis(*basis, _1), d);\nDune::VTKWriter vtkWriter(gridView, Dune::VTK::nonconforming);\nvtkWriter.addVertexData(disp, Dune::VTK::FieldInfo(\"displacement\", Dune::VTK::FieldInfo::Type::vector, 2));\nvtkWriter.addVertexData(pressure, Dune::VTK::FieldInfo(\"pressure\", Dune::VTK::FieldInfo::Type::scalar, 1));\nvtkWriter.write(\"iks003_incompressibleLinearElasticity\");\n</code></pre></p>","location":"02_examples/incompressibleRubberBlock/#code-highlights"},{"title":"Takeaways","text":"<ul> <li><code>Ikarus::AutoDiffFE</code> can be used to arrive at the stiffness matrix and external load vector from the energy function.</li> <li>Helper functions are included to switch between the Lame parameters.</li> <li>Grids from Dune can be directly incorporated within the Ikarus framework.</li> <li>Sparse and dense assemblers can be used to construct the global stiffness matrices and load vectors.</li> <li>Solvers from the Eigen library can be used to solve the linear system of equations.</li> <li>Post-processing can be done via Paraview after writing the <code>*.vtu</code> files using <code>Dune::VTKWriter</code>.</li> </ul>   <ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> </ol>","location":"02_examples/incompressibleRubberBlock/#takeaways"},{"title":"Plate subjected to a surface load","text":"","location":"02_examples/kirchhoffPlate/"},{"title":"Plate subjected to a surface load","text":"<p>Kirchhoff type plate element is implemented in <code>iks004_kirchhoffPlate.cpp</code> using the automatic differentiation technique as commented before. The basis used for discretization is a NURBS basis from the <code>dune-iga</code> module. The problem is solved and convergence plots are created by comparing the solutions to available analytical solutions for simply supported and clamped boundaries.</p>","location":"02_examples/kirchhoffPlate/#plate-subjected-to-a-surface-load"},{"title":"Newton-Raphson method","text":"","location":"02_examples/newtonRaphsonMethod/"},{"title":"Newton-Raphson method","text":"<p><code>iks005_newtonRaphson.cpp</code> shows a basic example of the Newton-Raphson method to solve a non-linear set of equations. A function which shows the algorithm explicitly is provided and another function which is implemented in Ikarus is demonstrated. The function which depicts the Ikarus implementation uses a non-linear operator to perform the Newton-Raphson iterations. A logger can also be subscribed to in order to observe the residual norms, for instance.</p>","location":"02_examples/newtonRaphsonMethod/#newton-raphson-method"},{"title":"Non-linear elasticity for 2D solids","text":"","location":"02_examples/nonLinearElasticity/"},{"title":"Non-linear Elasticity for 2D solids","text":"<p>Again, automatic differentiation based implementation is used to perform a non-linear analysis for a 2D block in <code>iks006_nonlinear2DSolid.cpp</code>. Various methods to obtain a 2D grid via Dune is also shown in the commented section in the beginning. Python is used to provide a Neumann boundary condition providing a demonstration for the usage of a Python-based code within the Ikarus framework. Load control method is chosen as the desired control routine and Newton-Raphson (or Trust region methods) are used to solve the non-linear problem itself.</p>","location":"02_examples/nonLinearElasticity/#non-linear-elasticity-for-2d-solids"},{"title":"Von Mises truss","text":"","location":"02_examples/vonMisesTruss/"},{"title":"Von Mises truss calculation","text":"<p><code>iks007_vonMisesTruss.cpp</code> shows a way to use the tools and features mentioned in the previous examples to solve the  standard Von-Mises truss example found in literature (refer Section 21)</p> <p>/bibliography</p>   <ol> <li> <p>R. V. Mises. \u00dcber die stabilit\u00e4tsprobleme der elastizit\u00e4tstheorie. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik, 3(6):406\u2013422, 1923. doi:10.1002/zamm.19230030602.\u00a0\u21a9</p> </li> </ol>","location":"02_examples/vonMisesTruss/#von-mises-truss-calculation"},{"title":"Build the documentation locally","text":"","location":"03_contribution/buildDocumentationLocally/"},{"title":"How to edit this documentation","text":"","location":"03_contribution/buildDocumentationLocally/#how-to-edit-this-documentation"},{"title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,   see the download page.</li> </ul>","location":"03_contribution/buildDocumentationLocally/#prerequisites"},{"title":"Preview the documentation locally","text":"<ul> <li>Change the cmake option, for example, in Clion: Open <code>File --&gt; Settings --&gt; Build,Execution,Deployment --&gt; Cmake</code>.    Add <code>-DBUILD_DOCS=TRUE</code> to your cmake options    </li> <li>Choose target <code>localSite</code> and build it (for instance, click on the hammer)</li> </ul> <p></p> <ul> <li>After a couple of seconds, build messages should appear that look similar to the picture below.   </li> <li>Click on <code>Services</code> in the footer, double-click on <code>Docker</code> and unfold <code>Containers</code>. There should be    one container with a blue box, while the other containers have a blue box with a white square inside   (see figure below). In this example, the container we are looking for is <code>elegant_bassi</code>.   The name will be different on your computer, but the relevant criterion for finding the container   is the blue box.   </li> <li>Click on the container with the blue box and navigate to <code>Port Bindings</code>.</li> <li>Add a new port by clicking on <code>+</code>, activate <code>Host port</code> under <code>Modifiy options</code> and enter    <code>8000</code> in both fields (see image below). Confirm with <code>OK</code>.   </li> <li>Click on <code>Save</code> in the lower right corner. This will restart the container. Messages will appear    saying that the build failed. These messages can be ignored. The build process restarts automatically.</li> <li>After a few seconds, Click on this link.</li> <li>Now you should see a live preview of the documentation in your browser.</li> <li>You can edit the documentation in CLion. <code>Ctrl</code> + <code>s</code> saves the documentation and updates it in   the browser window.</li> <li>Cancel the build process to stop the live preview. To restart the live preview, you will have to   modify the container settings again. Therefore, it is recommended to stop the live preview   only after you have finished working on the documentation. </li> </ul>","location":"03_contribution/buildDocumentationLocally/#preview-the-documentation-locally"},{"title":"Code style","text":"","location":"03_contribution/codeStyle/"},{"title":"Code style","text":"<p>This section explains some general implementational ideas used in  various parts of the code. It is dedicated to the users who would like to extend or modify the implemented functionality and/or would like to learn more about the implementation strategies and certain theoretical aspects.</p>","location":"03_contribution/codeStyle/#code-style"},{"title":"General remarks","text":"<ul> <li>The directories and filenames use <code>camelCase</code>.</li> <li>The source files and the header files have a <code>cpp</code> and a <code>hh</code> extension, respectively.</li> <li>A <code>clang-format</code> file is used, which needs to be executed in each extended or modified file before a PR can be merged.</li> <li>Readability and value semantics are the essence of the code.</li> <li>Commenting within the code and the other code styles were influenced by the books by Robert C. Martin1 and John K. Ousterhout2.</li> </ul>","location":"03_contribution/codeStyle/#general-remarks"},{"title":"Separation of interface and implementation","text":"<p>The notion of a description of an interface and a discussion of its implementation  are found in many pages. The question of what an interface and an implementation mean is answered here with an example of a car.</p>","location":"03_contribution/codeStyle/#separation-of-interface-and-implementation"},{"title":"Interface of a car","text":"<p>Let's first define the interface of a car. A car is from a certain brand, and it has a maximum velocity. The car's interface is thus:</p> <ul> <li><code>brand()</code>: a function which returns the brand name as a <code>string</code></li> <li><code>maxvelocity()</code>: a function which returns the maximum velocity as a <code>double</code></li> </ul> <p>This can be written in a more formalized way, e.g., as a C++20 concept, but we currently write it in this documentation as shown above.</p> <p>Every object that is then to be declared as a car has to have a member function <code>brand()</code> which returns a string,  and a member function <code>maxVeloctiy()</code> which returns a double.</p>","location":"03_contribution/codeStyle/#interface-of-a-car"},{"title":"Implementation of a car","text":"<p>Let's now implement a car. <pre><code>class MyCar\n{\n  public:\n  std::string brand() {return \"MyBrand\";}\n  double maxVelocity() \n  {\n    double velocity;\n    // calculate maximum velocity with some complicated calculations\n    return velocity;\n  }\n};\n</code></pre> The class <code>MyCar</code> fulfills the car interface and is therefore considered a car. There can be many other classes that fulfill the car interface. For example, someone could also implement a class <code>AnotherCar</code>.</p> <p>Thus, the following definitions are summarized: - Interface: Defines a set of requirements - Implementation: A specific class which fulfills the interface</p>   <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>John K. Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2021.\u00a0\u21a9</p> </li> </ol>","location":"03_contribution/codeStyle/#implementation-of-a-car"},{"title":"Edit the documentation","text":"","location":"03_contribution/howToEdit/"},{"title":"How to edit this documentation","text":"","location":"03_contribution/howToEdit/#how-to-edit-this-documentation"},{"title":"Prerequisites","text":"<ul> <li>Ikarus cloned on your computer,    see the download page.</li> </ul>","location":"03_contribution/howToEdit/#prerequisites"},{"title":"Edit a page","text":"<ul> <li>Open Ikarus</li> <li>Go to the folder <code>docs\\website</code></li> <li>Go to the Markdown file that corresponds to the page to be edited</li> <li>Apply your changes using any desired tool</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>","location":"03_contribution/howToEdit/#edit-a-page"},{"title":"Add a new page","text":"<ul> <li>Open Ikarus</li> <li>Go to the folder <code>docs\\website</code> and create a new Markdown file,    e.g. <code>MyAdditionalPage.md</code>. The new Markdown file could be added in any relevant existing folder or added to a new folder starting with a consecutive folder number, e.g., <code>XX_myFolder</code> </li> <li>Open the file <code>docs\\mkdocs.yml</code></li> <li>Find the navigation section which starts with <code># Navigation</code></li> <li>The navigation section describes the navigation on the left side of the website. Add <code>XX_myFolder/MyAdditionalPage.md</code> where you want it to appear</li> <li>Create a pull request</li> <li>Once the pull request is accepted, the website is automatically updated</li> </ul>","location":"03_contribution/howToEdit/#add-a-new-page"},{"title":"Insert a LaTeX formula","text":"<p>The Markdown format:</p> <p><code>$$ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} $$</code> </p> <p>The compiled output:</p> \\[ \\mathbf{X} \\left( \\xi,\\eta \\right) = \\begin{bmatrix} \\xi^2 \\\\ 5\\xi\\eta \\end{bmatrix} \\]","location":"03_contribution/howToEdit/#insert-a-latex-formula"},{"title":"Insert a C++ code","text":"<p>The Markdown format: <pre><code>    ```cpp\n    double complicatedCalculation(double number, double anotherNumber) \n    {\n      return number*anotherNumber;\n    };\n    ```\n</code></pre></p> <p>The compiled output:</p> <pre><code>double complicatedCalculation(double number, double anotherNumber) \n{\n  return number*anotherNumber;\n};\n</code></pre>","location":"03_contribution/howToEdit/#insert-a-c-code"},{"title":"Insert tables, warnings and notes","text":"<p>Look at the Markdown file (<code>03_contribution/howToEdit.md</code>) to see how tables, warnings and notes can be inserted.</p>    Grid Entity Interface      <code>GridViewType leafGridView()</code>    <code>GridViewType levelGridView(int level)</code>      <p>Insert a warning</p> <p>Note that the four spaces at the beginning of this line are essential for the warning to be displayed correctly.</p>   <p>References</p> <p>For available features in the documentation see Mkdocs-Material and Mkdocs.</p>","location":"03_contribution/howToEdit/#insert-tables-warnings-and-notes"},{"title":"Open Tasks","text":"","location":"03_contribution/openTask/"},{"title":"Open tasks","text":"<p>Thank you for your interest in contributing to this code base. The following task are open for your contributions.</p>","location":"03_contribution/openTask/#open-tasks"},{"title":"Local functions","text":"<ul> <li> <p>Implementing a unit normal field function1 and its derivatives w.r.t. its coefficients \\( \\boldsymbol{x}_i \\)</p> \\[  \\boldsymbol{n} = \\frac{\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2}{||\\boldsymbol{a}_1 \\times \\boldsymbol{a}_2||}, \\quad \\text{with } \\boldsymbol{a}_{\\alpha} = \\sum_{i=1}^n N^i_{,\\alpha}(\\boldsymbol{\\xi}) \\boldsymbol{x}_i \\] <p>To implement this, see link.</p> </li> <li> <p>Support second derivatives</p> </li> <li>Add \\( \\operatorname{div} \\) and \\( \\operatorname{curl} \\) wrapper</li> </ul>","location":"03_contribution/openTask/#local-functions"},{"title":"Control routines","text":"<ul> <li>Dynamics (Explicit/ implicit time stepping)</li> </ul>","location":"03_contribution/openTask/#control-routines"},{"title":"Control routines - addons","text":"<ul> <li>Extended systems</li> <li>Nonlinear dependence of \\(F_{ext}\\) on \\(\\mathbf{D}\\) and \\(\\lambda\\) for path-following techniques, see control routines.</li> </ul>","location":"03_contribution/openTask/#control-routines-addons"},{"title":"Finite element helper","text":"<ul> <li>Implement a default mass matrix</li> </ul>","location":"03_contribution/openTask/#finite-element-helper"},{"title":"Finite elements","text":"<ul> <li>Nonlinear Reissner-Mindlin shell 2</li> <li>Kirchhoff-Love shell</li> <li>3D-Beam</li> <li>Implement forces and stiffness matrix of <code>NonLinearElasticityFE</code></li> <li>Standard beam and plate formulations</li> </ul>","location":"03_contribution/openTask/#finite-elements"},{"title":"Further addons","text":"<ul> <li>Python binding (pybind11)</li> <li>Muesli</li> </ul>  <p>Code style</p> <p>For details on the code style, refer link.</p>    <ol> <li> <p>This is usually needed for a Kirchhoff-Love shell implementation, see 3.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> </ol>","location":"03_contribution/openTask/#further-addons"},{"title":"Blog","text":"","location":"04_blog/"},{"title":"Hello world!","text":"<p>...</p>","location":"04_blog/2022/01/31/hello-world/"},{"title":"C++ recommendations","text":"","location":"05_cppReferences/cppRef/"},{"title":"C++ recommendations","text":"<p>Since Ikarus is written in C++, we summarize our recommendations to dig deeper into C++ coding on this page.</p>","location":"05_cppReferences/cppRef/#c-recommendations"},{"title":"Should I write a member function or a free function?","text":"<ol> <li>Scott Meyers recommends the algorithm in the link.</li> </ol>","location":"05_cppReferences/cppRef/#should-i-write-a-member-function-or-a-free-function"},{"title":"When to use const?","text":"<ol> <li>Refer the blog of Arthur O'Dwyer</li> </ol>","location":"05_cppReferences/cppRef/#when-to-use-const"},{"title":"How should I pass my parameters to a function and return from a function?","text":"<ol> <li>Refer Herb Sutter's Cppcon Talk 2014</li> </ol>","location":"05_cppReferences/cppRef/#how-should-i-pass-my-parameters-to-a-function-and-return-from-a-function"},{"title":"Best practices","text":"<ol> <li>C++ Core Guidelines</li> <li>Jason Turner's collection of best practices</li> <li>More C++ idioms</li> </ol>","location":"05_cppReferences/cppRef/#best-practices"},{"title":"Further references","text":"<ol> <li>Cppcon Videos - These videos are released after every C++ conference. For beginners, the \"Back to basics\" track is recommended.</li> <li>Godblot - Online compiler with assembler output. It's useful to quickly determine whether something will be fast or slow.    Furthermore, libraries like Eigen can be added. Also, any other header files found on the internet can be included with the link.</li> </ol>","location":"05_cppReferences/cppRef/#further-references"},{"title":"Videos","text":"<p>Here we collect some useful videos on general coding or coding with C++:</p> <ol> <li>Clean Code - Uncle Bob / Lesson 1 How to write code cleanly, see also 1</li> <li>CppCon 2014: Herb Sutter \"Back to the Basics! Essentials of Modern C++ Style\"</li> <li>CppCon 2018: Jonathan Boccara \u201c105 STL Algorithms in Less Than an Hour\u201d \"Almost\" all algorithms in the STL</li> <li>Back to Basics: Object-Oriented Programming - Jon Kalb - CppCon 2019 How to do modern \"Object-Oriented Programming\" (If you really have to)</li> <li>CppCon 2021 - Back To Basics</li> <li>CppCon 2019 Back to Basics</li> </ol>","location":"05_cppReferences/cppRef/#videos"},{"title":"Books","text":"<ol> <li>[Meyers S. 1995]2</li> <li>[Gamma E. et al. 1995]3</li> <li>[Meyers S. 2005]4</li> <li>[Reddy M. 2011]5</li> <li>[Iglberger K. 2022]6</li> </ol>   <ol> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Klaus Iglberger. C++ Software Design: Design Principles and Patterns for High-Quality Software. O'Reilly, 2022.\u00a0\u21a9</p> </li> </ol>","location":"05_cppReferences/cppRef/#books"},{"title":"Literature","text":"","location":"99_Literature/99_Literature/"},{"title":"Literature","text":"<ol> <li> <p>Oliver Sander. DUNE\u2014The Distributed and Unified Numerics Environment. Volume 140. Springer Nature, 2020. doi:10.1007/978-3-030-59702-3.\u00a0\u21a9</p> </li> <li> <p>Gerald A. Wempner. Discrete approximations related to nonlinear theories of solids. International Journal of Solids and Structures, 7(11):1581\u20131599, 1971. doi:10.1016/0020-7683(71)90038-2.\u00a0\u21a9</p> </li> <li> <p>M.A. Crisfield. A fast incremental/iterative solution procedure that handles \u201csnap-through\u201d. Computers &amp; Structures, 13(1):55\u201362, 1981. doi:10.1016/0045-7949(81)90108-5.\u00a0\u21a9</p> </li> <li> <p>E. Ramm. Strategies for Tracing the Nonlinear Response Near Limit Points. In W. Wunderlich, E. Stein, and K.-J. Bathe, editors, Nonlinear Finite Element Analysis in Structural Mechanics, pages 63\u201389. Springer Berlin Heidelberg, Berlin, Heidelberg, 1981. doi:10.1007/978-3-642-81589-8_5.\u00a0\u21a9</p> </li> <li> <p>E. Riks. The Application of Newton\u2019s Method to the Problem of Elastic Stability. Journal of Applied Mechanics, 39(4):1060\u20131065, 1972. doi:10.1115/1.3422829.\u00a0\u21a9</p> </li> <li> <p>J. C. Simo and M. S. Rifai. A class of mixed assumed strain methods and the method of incompatible modes. Int. J. Numer. Meth. Engng., 29(8):1595\u20131638, June 1990. doi:10.1002/nme.1620290802.\u00a0\u21a9</p> </li> <li> <p>U. Andelfinger and E. Ramm. EAS-elements for two-dimensional, three-dimensional, plate and shell structures and their equivalence to HR-elements. International Journal for Numerical Methods in Engineering, 36(8):1311\u20131337, 1993. doi:10.1002/nme.1620360805.\u00a0\u21a9</p> </li> <li> <p>J. Austin Cottrell, Thomas J. R. Hughes, and Yuri Bazilevs. Isogeometric Analysis: Toward Integration of CAD and FEA. Wiley, 2009.\u00a0\u21a9</p> </li> <li> <p>Philipp Grohs, Hanne Hardering, Oliver Sander, and Markus Sprecher. Projection-based finite elements for nonlinear function spaces. SIAM J Numer Anal, 57(1):404\u2013428, 2019. doi:10.1137/18M1176798.\u00a0\u21a9</p> </li> <li> <p>Oliver Sander. Geodesic finite elements for cosserat rods. International Journal for Numerical Methods in Engineering, 82(13):1645\u20131670, 2010. doi:10.1002/nme.2814.\u00a0\u21a9</p> </li> <li> <p>Alexander M\u00fcller and Manfred Bischoff. A consistent finite element formulation of the geometrically non-linear reissner-mindlin shell model. Archives of Computational Methods in Engineering, pages 1\u201347, 2022. doi:10.1007/s11831-021-09702-7.\u00a0\u21a9</p> </li> <li> <p>Robert D. Cook. Improved Two-Dimensional Finite Element. J. Struct. Div., 100(9):1851\u20131863, September 1974. doi:10.1061/JSDEAG.0003877.\u00a0\u21a9</p> </li> <li> <p>R. V. Mises. \u00dcber die stabilit\u00e4tsprobleme der elastizit\u00e4tstheorie. ZAMM - Journal of Applied Mathematics and Mechanics / Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik, 3(6):406\u2013422, 1923. doi:10.1002/zamm.19230030602.\u00a0\u21a9</p> </li> <li> <p>Robert C Martin. Clean Code. Pearson Education, 2008.\u00a0\u21a9</p> </li> <li> <p>John K. Ousterhout. A Philosophy of Software Design. Yaknyam Press, 2021.\u00a0\u21a9</p> </li> <li> <p>J. Kiendl, K.-U. Bletzinger, J. Linhard, and R. W\u00fcchner. Isogeometric shell analysis with kirchhoff\u2013love elements. Computer Methods in Applied Mechanics and Engineering, 198(49):3902\u20133914, 2009. doi:10.1016/j.cma.2009.08.013.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs, PDF Version. Pearson Education, 1995.\u00a0\u21a9</p> </li> <li> <p>Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH, 1995.\u00a0\u21a9</p> </li> <li> <p>Scott Meyers. Effective C++: 55 specific ways to improve your programs and designs. Pearson Education, 2005.\u00a0\u21a9</p> </li> <li> <p>Martin Reddy. API Design for C++. Elsevier, 2011.\u00a0\u21a9</p> </li> <li> <p>Klaus Iglberger. C++ Software Design: Design Principles and Patterns for High-Quality Software. O'Reilly, 2022.\u00a0\u21a9</p> </li> </ol>","location":"99_Literature/99_Literature/#literature"}]}